/*******************************************************************************************
 * Initiate and Decision making class.******************************************************
 * Ramin Edjlal*****************************************************************************
 * Call Of Constructor From Constructor***************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * The Storing AllDraw Object in Self Constructor Caused Stack Overflow*******************0.12**4**Managements and Cuation Programing**********************(+)
 * Link List Of Storing String Caused A Stack Over Flow***********************************0.12**4**Managements and Cuation Programing**********************(+)
 * Wait For Finished Current AStarGreedy Caused To Long Time*************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Need To Heuristic (Arvin) Function(s) to Manage Cell in Form1**************************0.12**4**Managements and Cuation Programing**********************(+)
 * First Scanning Movements of Things Anomaly*********************************************0.12**4**Managements and Cuation Programing**********************(+)
 * In Current Version of Heuristic Table Doesn’t Reached(Zero)****************************0.12**4**Managements and Cuation Programing**********************(+)
 * In Current Version InitiateForEveryThisngsHome Dosn't Work*****************************0.12**4**Managements and Cuation Programing**********************(+)
 * In This Version Thinking Taking A LotofTime(AStarGreedyt Array Tree)**********************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Work In AStarGreedys. But Scanning Dosen’t Works************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Adding Clone Caused To Stack Overflow**************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Clone Caused To StackOverFlow**********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Row And Column Become Zero in Virtualization*******************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Initiate Error*************************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Seems To Be Logical Drawing ***********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * int Suddenly Changing****************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * AllDraw Object Sub Objects List When Return from local Scope Become Zero.**************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Dosn't Work*******************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * int Order Of Visualization Changed Suddenly******************************************0.12**4**Managements and Cuation Programing**********************(+)
 * int Changes with no movement*********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Table Not Gate (Inversion of Table List) Doesn’t help to do Normally*******************0.12**4**Managements and Cuation Programing**********************(+)
 * Literally Errors Correction************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * From Arrangements of Things Reaches Suddenly Things Location OccuRS********************0.12**4**Managements and Cuation Programing**********************(+)
 * The Arrangements is Logical************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * The int changes and the arrangements changes are not clearly obvious*****************0.12**4**Managements and Cuation Programing**********************(+)
 * int Changes Solved. no movements*****************************************************0.12**4**Managements and Cuation Programing**********************(+)(-+)
 * Things movements Anomally**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Chess Rules Anomally*******************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Function Not Work************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Work But the Table is Empty**************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Table is Not Empty But the Movement is Not Logical*************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Clear Dirty Part.**********************************************************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Need to Restricted Approval. Taking a lot of time Thinking Computation*****************0.12**4**Managements and Cuation Programing**********************(+)
 * No movements In Virtualization*********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Chess Rules Abnormal Thinking movements. No movement greater than 2********************0.12**4**Managements and Cuation Programing**********************(+)
 * Problem For Drawing of Thinking Things*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Constant Result**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * One movements Right .Heuristic Remaining Constant Results******************************0.12**4**Managements and Cuation Programing**********************(+)
 * Constant Heuristic Result**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Need To Add A Heuristic Useful Another*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Function Does’ Work Allis suddenly Become Zero that Previously Working*******0.12**4**Managements and Cuation Programing**********************(+)
 * No Movement Greater than one order in Computer 'Alice'*********************************0.12**4**Managements and Cuation Programing**********************(+)
 * Tow movements in Computer 'Alice' Of two Different Order int*************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Not Work Greater than 3 Length Count of A************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'They Don't Really Take care about us'. Misleading in Heuristic King Supported*********0.12**4**Managements and Cuation Programing**********************(+)
 * Non Order Movments*********************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Misleading at Stage three. no illegal movement greater than three**********************0.12**4**Managements and Cuation Programing**********************(+)
 * Thinking Order Misleading**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Hit Mechanism Malfunctional************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Tow movements At One 'Alice' Order time************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Computer By Computer 'Alice' by 'Bob' Caused to Loop Heuristic.**************0.12**4**Managements and Cuation Programing**********************(+)
 * Learning Automata of  also leads to re loop heuristic***************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Heuristic Learning Automata 'Alice' By 'Bob' Leads to Re loop**************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Things Loop 'Alice' By 'Bob'*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Self 'Check' Detection Failure By 'Alice'***********************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Penalty' Value Of All Become zero althouth the one should be non Penalty**************0.88**1**Risk Control********************************************(*)
 * Clone Dosn't Copy All Content of AllDraw Dummy*****************************************0.12**4**Managements and Cuation Programing**********************(+)
 * CheckRemovable By Self King Solved.Penalty Action Misleading****************************0.88**1**Risk Control********************************************(-*)QC-OK.
 * 'Check' Detection Failure***************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Mechanisam Of Order in Predict Failed.*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Alice' King Virtualization or Table Content of King Misleading************************0.12**4**Managements and Cuation Programing**********************(+)
 * With The All Things Heuristic Signing Mechnisam Some Movments become null Table.********0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedy First Search Not Working. Misleading MalFunction Virtualization.******************0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedy First Table is Null at Bob Order.*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedy First SetVirtualization and Table Misleading By Alice.****************************0.12**4**Managements and Cuation Programing**********************(+)
 * No Reason Logically For MalFunction  Refrigtz.Timer AStarGreedy First Dynamic Refrigtz.Timer.*******************0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedyt Thinking Taking a lot of time.***********************************************0.12**4**Managements and Cuation Programing**********************([+]
 * AStarGreedy First Not Work.*******************************************************************0.12**4**Managements and Cuation Programing**********************[+]
 * AStarGreedy First Not Work.Refrigtz.Timer Stop At Greater than 2,3,4,5,6,7 Movments.*******************0.12**4**Managements and Cuation Programing**********************[+]
 * No Reason For MalFunction of AStarGreedytNotFoundHeuristicAStarGreedyt.***********************0.12**4**Managements and Cuation Programing**********************[+]
 * Problem Solved.No Reason to NullExeption of AStarGreedytHeuristic Algorithm.***************0.88**1**Risk Control********************************************[-*]QC-OK.
 * Function Evaluation Disabled .At Initiate AStarGreedytGenetic Found Sysntax.**************0.88**1**Risk Control********************************************[*]
 * Index Was Out Of Range Exeption Was Not Handled.Colud Not Be Handle.*******************0.12**4**Managements and Cuation Programing**********************{+}
 * No Logical Mechanism To Reconstructe Current AllDraw Objects.**************************0.12**4**Managements and Cuation Programing**********************{+}
 * AStarGreedy First Sysntax is legal and The table is constant table.***************************0.12**4**Managements and Cuation Programing**********************{+}
 * Table Content Empty. No Syntax Exist.**************************************************0.12**4**Managements and Cuation Programing**********************{+}
 * Game Begin From First When the Soldiers Move Ordinary Complete in AStarGreedy First***********0.88**1**Risk Control********************************************{*}QC-OK.
 * New Instatnt Of Program Cuase to Begin Fron First.*************************************0.12**4**Managements and Cuation Programing**********************<+>
 * No Logically Reason For New Game Of Program. New Instatnt Not Detected.****************0.12**4**Managements and Cuation Programing**********************<+>
 * Internal New Instatnt Of FormeRefregitz is MalFunction.********************************0.12**4**Managements and Cuation Programing**********************<+>
 * AStarGreedy First CC Changes to CC Normal Game.***********************************************0.12**4**Managements and Cuation Programing**********************<+>
 * Game CC UnContoroled.******************************************************************0.12**4**Managements and Cuation Programing**********************<+>
 * MalFunction of Syntax and Movments.By Alice and Bob.***********************************0.12**4**Managements and Cuation Programing**********************<+>
 * Threading Solved! The OutOfRangeIndex Not Work.****************************************0.12**4**Managements and Cuation Programing**********************[-+]
 * Vituallization error!No Best Matches between Truth of table content and irtualization**0.12**4**Managements and Cuation Programing**********************[+]
 * Dynamic Programming for Stroring ADraw THISDummy Adraw Value MalFunction.**************0.12**4**Managements and Cuation Programing**********************(+)
 * Order is Constant in Dynamic Programming.**********************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Table MalFunction at Dynamic Programming.At Step 3.************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Some Movments are MalFuncational at Dynamic Programming.*******************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Overlay Tow Part of ADraw and StoreADraw Sections at Different levels Tab Cal.0.12**4**Managements and Cuation Programing**********************(+)
 * Not to be needing again calculation. MalFunction is depend of tow part.****************0.12**4**Managements and Cuation Programing**********************(+)
 * BackWard Loos of Things AllDraw Mechnisam.*********************************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Some Dynamic Programming MalFunction Movments.*****************************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Syntax and Forward and Backward Movments Syntax is MalFunction.************************0.12**4**Managements and Cuation Programing**********************<+>
 * Database and Virtualization Forward and Backward MalFunction***************************0.12**4**Managements and Cuation Programing**********************<+>
 * Reproduction of Thinfs Missleading.****************************************************0.88**1**Risk Control********************************************<*>QC-OK.
 * Reproduction of Some Things are MalFunction Movments.**********************************0.12**4**Managements and Cuation Programing**********************{+}
 * AStarGreedy Count of Dynamic Programming Misleadig.AStarGreedy Operation Count Mal Function.*********0.88**1**Risk Control********************************************(*)QC-OK.
 * Heuristic By Alice is MalFunction.******************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * ObjectDanger Identification By Alice is MalFunction.*****************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Check Identification By Alice is MalFunction.*******************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Check Recognized But CheckMate Not Recognized!***********************************************0.12**4**Managements and Cuation Programing**********************(_+)
 * Penalty Regard Mechanism Misleading.***************************************************0.12**4**Managements and Cuation Programing**********************{+}
 * Inhereted LearningAtamata Caused to Shared Parent Allocated Variable.******************0.12**4**Managements and Cuation Programing**********************{+}
 * 'Check' By 'Alice' Not Removed Unreasonably.********************************************0.88**1**Risk Control********************************************{*}QC-OK.
 * AStarGreedyt Heuristic Found MalFunction at Check Alice.************************************0.12**4**Managements and Cuation Programing**********************{+}
 * Sortments of ADRAW and Construction is MalFunction at AStarGreedy Dynamic Programming.********0.12**4**Managements and Cuation Programing**********************{+}
 * Heuristic AStarGreedy First were Worked Out Unreasonably such Situation(Golden Sword Magic).***0.88**1**Risk Control********************************************{*}QC-OK.
 * Converted 'King' of 'Alice' to 'Elephant' UnReasonably.********************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Long Game' ; But MalFunction of Game.*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Always' in Current game is 'Bob'.*****************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Current Table of ADRAW is Correct Table But the Game is MalFunction.*******************0.12**4**Managements and Cuation Programing**********************(+)
 * Move of Current Table AStarGreedy First Heuristic found ;found an ovelay in 'Bob' and 'Alice'**0.12**4**Managements and Cuation Programing**********************(+)
 * Current Table in High Level Become Null and prevent of 'LongGame' Strategy.************0.12**4**Managements and Cuation Programing**********************(+)
 * 'LongGame' Become short Undetectably Unreasonably;Clear Store Non Detectably.**********0.88**1**Risk Control********************************************(*)QC-OK.
 * All Draw AStarGreedy First section some movments have not been accurred considerably.*********0.88**1**Risk Control********************************************(*)QC-OK.
 * 'Long Game' Breaks Suddendly without Monitor Caused.***********************************0.12**4**Managements and Cuation Programing**********************{+}
 * Overlay Some Movments of 'Long Game' Breaked.Caused Probability to break.**************0.12**4**Managements and Cuation Programing**********************{+}
 * SomeTimes All Situation of Current Games Become Cleared and No Table Founded.**********0.12**4**Managements and Cuation Programing**********************{+}
 * Gray Soldeir is Only Movmnets and Converts in Heuristic and No Move are detectable.*****0.12**4**Managements and Cuation Programing**********************{+}
 * DEEPLY Recursive Tree of Second Version Become in Some Null At Hurristic Finsished.****0.12**4**Managements and Cuation Programing**********************{+}
 * AStarGreedy Heuristic Content is Zero. No Calculation of AStarGreedy Heuristic Calculation.************0.12**4**Managements and Cuation Programing**********************{+}
 * MalFunction of Dep Heuristic Person and MalFunction Movments of CC AStarGreedy Heuristic********0.88**1**Risk Control********************************************{*}QC-OK.
 * Mal Function of Reconstruction of AStarGreedy Objects In Initiate AStarGreedy First.*****************0.12**4**Managements and Cuation Programing**********************<+>
 * Hurisic Operantional Have Mal Function Behaviour.**************************************0.12**4**Managements and Cuation Programing**********************<+>
 * Table Zero of AStarGreedy First Heuristic Mal Function.****************************************0.12**4**Managements and Cuation Programing**********************<+>
 * AStarGreedy First Initiate Method Result Object Content Mal Function.*************************0.12**4**Managements and Cuation Programing**********************<+>
 * Table Nopt Found Of AStarGreedy First Heuristic.Mal Function of Initiate and Heuristic.*********0.12**4**Managements and Cuation Programing**********************<+>
 * Table Foundation Successfule. Traversaling of All Tree Not Successfule.****************0.12**4**Managements and Cuation Programing**********************<+>
 * Table Some Movments Intiaiazation Mal Function.****************************************0.12**4**Managements and Cuation Programing**********************{+}
 * BackWard Max Check CheckMate Mechanism For Best Heuristic is Unknown**************************0.12**4**Managements and Cuation Programing**********************{+}
 * Minister After Calculation AStarGreedyHeuristic At AStarGreedyHeuristic becomes Null.******************0.88**1**Risk Control********************************************(*)QC-OK
 * All Objects Possible Movments Not calculating During AStarGreedytsearch Method.***********0.88**1**Risk Control********************************************{*}QC_OK
 * Mechanisam olf AStarGreedytHeuristic and Hurisistic is QC-Ok. But Table foundation Illegal.0.88**1**Risk Control********************************************<*>QC-OK
 * Full Game Indexing Parameters Misleading UnLogically.*************************************0.88**1**Risk Control********************************************(*)QC_OK
 * Index out of Range Unlogically at Full Game Soldier Order Brown.**************************0.88**1**Risk Control********************************************<*>QC_OK
 * Execution make zero table but trace make valid table.*************************************0.88**1**Risk Control********************************************{*}Qc-OK.
 * Virtualization need to more hardware capabilities gone to malfunction virtualization.******0.88**1**Risk Control*******************************************{*}QC-BAD.
 * MalFunction on AllDraw Hadeling of Draw Midle Target Motion Graphics.**********************0.88**1**Risk Control*******************************************{*}QC-BAD.
 * ********************************************************************************************************************************************************(+:Sum(63)) 
 * 1394/12/19**********************************************************************************************************************************************(*:Sum(4))
 * ********************************************************************************************************************************************************(-:sum(2)) (_:Sum(0)):2:(+:Sum(3)) (-:Sum(1)) (*:Sum(2)) 3: (+:Sum(4)) (*:Sum(1)) 4:(+:Sum(6))  5:(+:Sum(2)) (-:Sum(1)) 6:(+:Sum(6)) (*:Sum(2)) 7.(+:Sum(2)) (*:Sum(1)) 8.(+:Sum(1)) 9.(+:Sum(4)) (*:Sum(1)) (-:Sum(1)) 10.(+:Sum(4)) (*:Sum(2)) 11.(+:Sum(4)) 12.(+:Sum(2)) (*:Sum(2)) 13.(+:Sum(4)) 14.(+:Sum(2)) (*:Sum(1)) 15.(+:Sum(6)) 16.(+:Sum(2)) 17.(QC-OK.:Sum(13))
 */
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel;
namespace RefrigtzDLL
{



    [Serializable]

    public class AllDraw //: IDisposable
    {
        public static bool LeafSemaphoreIndex = false;
        //Initiate Variables. 
        bool[] ThinkingAllowed = { false, false, false, false, false, false, false, false, false, false, false, false };



        [field: NonSerialized] List<Task> tH = new List<Task>();
        [field: NonSerialized] List<Task> TH = new List<Task>();

        public static bool Deeperthandeeper = false;

        public static bool FirstTraversalTree = true;
        public static int NumberOfLeafComputation = 0;
        public bool IsCurrentDraw = false;


        public int HaveKilled = 0;
        StringBuilder Space = new StringBuilder("&nbsp;");
        int Spaces = 0;
        bool SetDeptIgnore = false;
        long Now = DateTime.Now.Hour * (36000000 * 24) + DateTime.Now.Minute * 36000000 + DateTime.Now.Second * 600000 + DateTime.Now.Millisecond;
        long Later = DateTime.Now.Hour * (36000000 * 24) + DateTime.Now.Minute * 36000000 + DateTime.Now.Second * 600000 + DateTime.Now.Millisecond;
        StackFrame callStack = new StackFrame(1, true);
        int[,] Tabl = new int[8, 8];
        public int OrderP = 0;
        public static int DepthIterative = 0;
        int PerceptionCount = 0;
        public String OutPutAction = "";
        public static StringBuilder OutPut = new StringBuilder("");
        public static StringBuilder ActionString = new StringBuilder("");
        public static bool ActionStringReady = false;
        //static variable to be Initiate
        List<int[]> ValuableSelfSupported = new List<int[]>();
        public static bool RegardOccurred = false;
        public static int SuppportCountStaticGray = 0;
        public static int SuppportCountStaticBrown = 0;
        int CurrentAStarGredyMax = 0;
        public static int TaskBegin = 0;
        public static int TaskEnd = 0;
        public static String Root = System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]);
        public static int OrderPlate = 1;
        public static bool Blitz = false;
        public static int ConvertedKind = -2;
        public static bool ConvertWait = true;
        public static bool Stockfish = false;
        public static bool Person = true;
        public static bool THISSecradioButtonGrayOrderChecked = false;
        public static bool THISSecradioButtonBrownOrderChecked = false;
        public static String THIScomboBoxMaxLevelText = "";
        public static AllDraw THISDummy = null;
        public static bool StateCP = false;
        public static bool StateCC = false;
        public static int LastRow = -1;
        public static int LastColumn = -1;
        public static int NextRow = -1;
        public static int NextColumn = -1;
        public static int MovmentsNumber = 0;
        public static int MaxAStarGreedyHeuristicProgress = 0;
        public static bool EndOfGame = false;
        const int ThresholdBlitz = 10000;
        const int ThresholdFullGame = 20000;
        public bool SetRowColumnFinished = false;
        public static int MinThinkingTreeDepth = Int32.MaxValue;
        static int MaxDuringLevelThinkingCreation = 0;
        public int MaxHeuristicxT = Int32.MinValue;
        public bool MovementsAStarGreedyHeuristicFoundT = false;
        public bool IgnoreSelfObjectsT = false;
        public bool UsePenaltyRegardMechnisamT = true;
        public bool BestMovmentsT = false;
        public bool PredictHeuristicT = true;
        public bool OnlySelfT = false;
        public bool AStarGreedyHeuristicT = false;
        public int[] Index = { -1, -1, -1, -1, -1, -1 }, jindex = { -1, -1, -1, -1, -1, -1 }, Kind = { -1, -1, -1, -1, -1, -1 };
        public bool ArrangmentsChanged = false;
        public static int AStarGreedytMaxCount = 0;
        public static bool FoundATable = false;
        public static int Less = Int32.MinValue;
        public bool CastlesKing = false;
        List<int[,]> MaxHeuristicAStarGreedytBackWardTable = new List<int[,]>();
        public static int increasedProgress = 0;
        public static int CurrentHeuristic = Int32.MinValue;
        public static int SignAttack = 1;
        public static int SignObjectDangour = 1;
        public static int SignReducedAttacked = -1;
        public static int SignSupport = 1;
        public static int SignKiller = 1;
        public static int SignMovments = 1;
        public static int SignDistance = -1;
        public static int SignKingSafe = -1;
        public static int SignKingDangour = -1;
        public static bool DrawTable = true;
        public static int[,] TableVeryfy = new int[8, 8];
        public static int MaxAStarGreedy = 1;
        public static int[,] TableVeryfyConst = new int[8, 8];
        public static List<int[,]> TableCurrent = new List<int[,]>();
        public static bool NoTableFound = false;
        public static bool DynamicAStarGreedytPrograming = false;
        public static List<AllDraw> StoreADraw = new List<AllDraw>();
        public static List<int> StoreADrawAStarGreedy = new List<int>();
        public static bool UseDoubleTime = false;
        public static int AStarGreedyiLevelMax;
        public static bool AStarGreadyFirstSearch = true;
        public static String ImageRoot = AllDraw.Root + "\\Images";
        public static String ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
        public static bool RedrawTable = true;
        public static String SyntaxToWrite = "";
        public static bool SodierConversionOcuured = false;
        public static int SodierMovments = 1;
        public static int ElefantMovments = 1;
        public static int HourseMovments = 1;
        public static int CastleMovments = 1;
        public static int MinisterMovments = 1;
        public static int KingMovments = 1;
        /*public int SodierMidle = 8;
        public int SodierHigh = 16;
        public int ElefantMidle = 2;
        public int ElefantHigh = 4;
        public int HourseMidle = 2;
        public int HourseHight = 4;
        public int CastleMidle = 2;
        public int CastleHigh = 4;
        public int MinisterMidle = 1;
        public int MinisterHigh = 2;
        public int KingMidle = 1;
        public int KingHigh = 2;
        */
        public int SodierMidle = 0;
        public int SodierHigh = 0;
        public int ElefantMidle = 0;
        public int ElefantHigh = 0;
        public int HourseMidle = 0;
        public int HourseHight = 0;
        public int CastleMidle = 0;
        public int CastleHigh = 0;
        public int MinisterMidle = 0;
        public int MinisterHigh = 0;
        public int KingMidle = 0;
        public int KingHigh = 0;
        //ChessPerdict APredict = null;
        int RW = 0;
        int CL = 0;
        int Ki = 0;
        int RW1 = 0;
        int CL1 = 0;
        int Ki1 = 0;
        int MaxLess1 = 0;
        int RW2 = 0;
        int CL2 = 0;
        int Ki2 = 0;
        int MaxLess2 = 0;
        int RW3 = 0;
        int CL3 = 0;
        int Ki3 = 0;
        int MaxLess3 = 0;
        int RW4 = 0;
        int CL4 = 0;
        int Ki4 = 0;
        int MaxLess4 = 0;
        int RW5 = 0;
        int CL5 = 0;
        int Ki5 = 0;
        int MaxLess5 = 0;
        int RW6 = 0;
        int CL6 = 0;
        int Ki6 = 0;
        int MaxLess6 = 0;
        public static int LoopHeuristicIndex = 0;
        static List<int> RWList = new List<int>();
        static List<int> ClList = new List<int>();
        static List<int> KiList = new List<int>();
        static public List<int[,]> TableListAction = new List<int[,]>();
        public int Move = 0;
        static public int MouseClick = 0;
        int[] AStarGreedyIndex = new int[20];

        public List<int[,]> TableList = new List<int[,]>();
        public int AStarGreedy = 0;
        public DrawSoldier[] SolderesOnTable = new DrawSoldier[16];
        public DrawElefant[] ElephantOnTable = new DrawElefant[4];
        public DrawHourse[] HoursesOnTable = new DrawHourse[4];
        public DrawCastle[] CastlesOnTable = new DrawCastle[4];
        public DrawMinister[] MinisterOnTable = new DrawMinister[2];
        public DrawKing[] KingOnTable = new DrawKing[2];
        List<int[]> MaxHeuristicAStarGreedytBackWard = new List<int[]>();
        const int MaxSoldeirFounded = 2;
        const int MaxElephntFounded = 6;
        const int MaxHourseFounded = 10;
        const int MaxCastlesFounded = 14;
        const int MaxMinisterFounded = 18;
        const int MaxKingFounded = 22;
        [NonSerialized()] public Task ob;
        //Making String datastructure to root variable
        public AllDraw AStarGreedyString = null;

        //Error Handling
        static void Log(Exception ex)
        {
            long Time = TimeElapced.TimeNow();
            Object a = new Object();
            lock (a)
            {
                string stackTrace = ex.ToString();
                File.AppendAllText(AllDraw.Root + "\\ErrorProgramRun.txt", stackTrace + ": On" + DateTime.Now.ToString()); // path of file where stack trace will be stored.
            }
            //AllDraw.OutPut.Append("\r\nALLDrawLog:" + (TimeElapced.TimeNow() - Time).ToString());
        }
        //Determine when a MoveOccured.
        //Note for before move.At most one  moves.
        public static bool IsAeMoveOccured(bool IsMove)
        {
            long Time = TimeElapced.TimeNow();
            bool Is = false;
            if (!IsMove)
            {
                int IsInt = (new Random()).Next(0, 32);
                Is = System.Convert.ToBoolean(IsInt % 2);
            }
            //AllDraw.OutPut.Append("\r\nIsAeMoveOccured:" + (TimeElapced.TimeNow() - Time).ToString());
            return Is;
        }
        void TimeEnd()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Now = DateTime.Now.Hour * (60000 * 24) + DateTime.Now.Minute * 60000 + DateTime.Now.Second * 1000 + DateTime.Now.Millisecond;
            long Later = Now;
            do
            {
                Later = DateTime.Now.Hour * (60000 * 24) + DateTime.Now.Minute * 60000 + DateTime.Now.Second * 1000 + DateTime.Now.Millisecond;

            } while (Later - Now < 3 * 60000);

            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("TimeEnd:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

        }
        //Determine and set numbers of all curent state table severasl kinds node.
        public void SetObjectNumbers(int[,] TabS)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //Initiate
                SodierMidle = 0;
                SodierHigh = 0;
                ElefantMidle = 0;
                ElefantHigh = 0;
                HourseMidle = 0;
                HourseHight = 0;
                CastleMidle = 0;
                CastleHigh = 0;
                MinisterMidle = 0;
                MinisterHigh = 0;
                KingMidle = 0;
                KingHigh = 0;
                for (int h = 0; h < 8; h++)
                    for (int s = 0; s < 8; s++)
                    {
                        //Cal Solider Gray
                        if (TabS[h, s] == 1)
                        {
                            //Increase
                            SodierMidle++;
                            SodierHigh++;
                        }//Elephant Gray
                        else if (TabS[h, s] == 2)
                        {
                            //Increase
                            ElefantMidle++;
                            ElefantHigh++;
                        }
                        //Hoirse Gray
                        else if (TabS[h, s] == 3)
                        {
                            //Increase
                            HourseMidle++;
                            HourseHight++;
                        }
                        //Castle Gray
                        else if (TabS[h, s] == 4)
                        {
                            //Increase
                            CastleMidle++;
                            CastleHigh++;
                        }
                        //Minister Gray
                        else if (TabS[h, s] == 5)
                        {
                            //Increase
                            MinisterMidle++;
                            MinisterHigh++;
                        }
                        //King Gray
                        else if (TabS[h, s] == 6)
                        {
                            //Increase
                            KingMidle++;
                            KingHigh++;
                        }
                        else//Solder Brown
                            if (TabS[h, s] == -1)
                        {
                            //Increase
                            SodierHigh++;
                        }
                        else if (TabS[h, s] == -2)//Elepant Brown
                        {
                            //Increase
                            ElefantHigh++;
                        }
                        else if (TabS[h, s] == -3)//Hourse Brown
                        {
                            //Increase
                            HourseHight++;
                        }
                        else if (TabS[h, s] == -4)//Castle Brown
                        {
                            //Increase
                            CastleHigh++;
                        }
                        else if (TabS[h, s] == -5)//Mincter Brown
                        {
                            //Increase
                            MinisterHigh++;
                        }
                        else if (TabS[h, s] == -6)//King Brown
                        {
                            //Incrrease
                            KingHigh++;
                        }
                    }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("SetObjectNumbers:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

        }
        //Found of Specific Objects uniqued
        float[] FoundLocationOfObject(ref int[,] Tabl, int Kind, bool IsGray)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //Initaite
                float[] Location = { -1, -1 };
                //Locate and search
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                    {
                        //When is Gray
                        if (IsGray)
                        {
                            //When object found
                            if (Tabl[i, j] == Kind)
                            {
                                //Srote location
                                Location[0] = i;
                                Location[1] = j;
                                //Clear Objects from table
                                Tabl[i, j] = 0;

                            }
                        }
                        else//Is Brown
                        {
                            //When Found
                            if (Tabl[i, j] * -1 == Kind)
                            {
                                //Store Location
                                Location[0] = i;
                                Location[1] = j;
                                //Clear from table
                                Tabl[i, j] = 0;

                            }
                        }

                    }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundLocationOfObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                //returnb location
                return Location;

            }
        }
        [field: NonSerialized]
        private readonly CancellationTokenSource feedCancellationTokenSource =
            new CancellationTokenSource();
        [field: NonSerialized] private readonly Task feedTask;



        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                //feedCancellationTokenSource.Cancel();
                //feedTask.Wait();

                //feedCancellationTokenSource.Dispose();
                //feedTask.Dispose();
            }
        }
        //Constructor
        public AllDraw(int Order, bool MovementsAStarGreedyHeuristicTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechnisa, bool BestMovment, bool PredictHurist, bool OnlySel, bool AStarGreedyHuris, bool Arrangments)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                

                MaxHeuristicxT = Int32.MinValue;
                MovementsAStarGreedyHeuristicFoundT = MovementsAStarGreedyHeuristicTFou;
                IgnoreSelfObjectsT = IgnoreSelfObject;
                UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisa;
                BestMovmentsT = BestMovment;
                PredictHeuristicT = PredictHurist;
                OnlySelfT = OnlySel;
                AStarGreedyHeuristicT = AStarGreedyHuris;
                ArrangmentsChanged = Arrangments;
                Object Om = new Object();
                lock (Om)
                {
                    FoundATable = false;
                }
                CastlesKing = false;
                increasedProgress = 0;
                Object ol = new Object();
                lock (ol)
                {
                    CurrentHeuristic = Int32.MinValue;

                    DrawTable = false;

                    TableVeryfy = new int[8, 8];

                    TableVeryfyConst = new int[8, 8];

                    TableCurrent.Clear();

                    NoTableFound = false;

                    DynamicAStarGreedytPrograming = false;

                    UseDoubleTime = false;
                    AStarGreadyFirstSearch = true;
                    ImageRoot = AllDraw.Root + "\\Images";
                    ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
                }
                RedrawTable = true;
                SodierConversionOcuured = false;
                SodierMovments = 1;
                ElefantMovments = 1;
                HourseMovments = 1;
                CastleMovments = 1;
                MinisterMovments = 1;
                KingMovments = 1;
                /*SodierMidle = 8;
                SodierHigh = 16;
                ElefantMidle = 2;
                ElefantHigh = 4;
                HourseMidle = 2;
                HourseHight = 4;
                CastleMidle = 2;
                CastleHigh = 4;
                MinisterMidle = 1;
                MinisterHigh = 2;
                KingMidle = 1;
                KingHigh = 2;*/
                //APredict = null;
                RW = 0;
                CL = 0;
                Ki = 0;
                RW1 = 0;
                CL1 = 0;
                Ki1 = 0;
                MaxLess1 = 0;
                RW2 = 0;
                CL2 = 0;
                Ki2 = 0;
                MaxLess2 = 0;
                RW3 = 0;
                CL3 = 0;
                Ki3 = 0;
                MaxLess3 = 0;
                RW4 = 0;
                CL4 = 0;
                Ki4 = 0;
                MaxLess4 = 0;
                RW5 = 0;
                CL5 = 0;
                Ki5 = 0;
                MaxLess5 = 0;
                RW6 = 0;
                CL6 = 0;
                Ki6 = 0;
                MaxLess6 = 0;
                LoopHeuristicIndex = 0;
                Move = 0;
                //MouseClick = 0;
                AStarGreedyIndex = new int[20];
                AStarGreedy = 0;
                SolderesOnTable = null;
                ElephantOnTable = null;
                HoursesOnTable = null;
                CastlesOnTable = null;
                MinisterOnTable = null;

                KingOnTable = null;
                MaxHeuristicAStarGreedytBackWard.Clear();

                //Initiayte Locally Variables.
                TableList = new List<int[,]>();
                //APredict = new ChessPerdict(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged//, ref th
                //    );
                OrderP = Order;
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("AllDraw_1:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

            }
        }
        //Clone Copy Method
        public void Clone(AllDraw AA)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {



                if (AA == null)
                {
                    AA = new AllDraw(OrderP, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    AA.TableList.Add(CloneATable(TableList[0]));
                }
                AA.Tabl = new int[8, 8];
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                        AA.Tabl[i, j] = Tabl[i, j];
                AA.OrderP = OrderP;

                AA.PerceptionCount = PerceptionCount;
                AA.OutPutAction = OutPutAction;
                //static variable to be Initiate
                AA.ValuableSelfSupported = new List<int[]>();
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                        AA.ValuableSelfSupported.Add(ValuableSelfSupported[i]);
                AA.CurrentAStarGredyMax = CurrentAStarGredyMax;
                for (var i = 0; i < 6; i++)
                    AA.Index[i] = Index[i];
                for (var i = 0; i < 6; i++)
                    AA.jindex[i] = jindex[i];
                for (var i = 0; i < 6; i++)
                    AA.Kind[i] = Kind[i];
                if (AStarGreedyString != null)
                    AStarGreedyString.Clone(AA.AStarGreedyString);
                if (TableList.Count == 1)
                    SetObjectNumbers(TableList[0]);
                MaxHeuristicxT = Int32.MinValue;
                AA.MovementsAStarGreedyHeuristicFoundT = MovementsAStarGreedyHeuristicFoundT;
                AA.IgnoreSelfObjectsT = IgnoreSelfObjectsT;
                AA.UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisamT;
                AA.BestMovmentsT = BestMovmentsT;
                AA.PredictHeuristicT = PredictHeuristicT;
                AA.OnlySelfT = OnlySelfT;
                AA.AStarGreedyHeuristicT = AStarGreedyHeuristicT;
                AA.ArrangmentsChanged = ArrangmentsChanged;
                AA.CastlesKing = CastlesKing;


                AA.SodierMidle = SodierMidle;
                AA.SodierHigh = SodierHigh;
                AA.ElefantMidle = ElefantMidle;
                AA.ElefantHigh = ElefantHigh;
                AA.HourseMidle = HourseMidle;
                AA.HourseHight = HourseHight;
                AA.CastleMidle = CastleMidle;
                AA.CastleHigh = CastleHigh;
                AA.MinisterMidle = MinisterMidle;
                AA.MinisterHigh = MinisterHigh;
                AA.KingMidle = KingMidle;
                AA.KingHigh = KingHigh;
                //Initiate a new class object and clone a copy.

                AA.SolderesOnTable = new DrawSoldier[SodierHigh];
                AA.ArrangmentsChanged = ArrangmentsChanged;
                for (var i = 0; i < SodierHigh; i++)
                {

                    SolderesOnTable[i].Clone(ref AA.SolderesOnTable[i]);

                }
                AA.ElephantOnTable = new DrawElefant[ElefantHigh];
                for (var i = 0; i < ElefantHigh; i++)
                {

                    ElephantOnTable[i].Clone(ref AA.ElephantOnTable[i]);


                }
                AA.HoursesOnTable = new DrawHourse[HourseHight];
                for (var i = 0; i < HourseHight; i++)
                {

                    HoursesOnTable[i].Clone(ref AA.HoursesOnTable[i]);


                }
                AA.CastlesOnTable = new DrawCastle[CastleHigh];
                for (var i = 0; i < CastleHigh; i++)
                {

                    CastlesOnTable[i].Clone(ref AA.CastlesOnTable[i]);


                }
                AA.MinisterOnTable = new DrawMinister[MinisterHigh];
                for (var i = 0; i < MinisterHigh; i++)
                {

                    MinisterOnTable[i].Clone(ref AA.MinisterOnTable[i]);


                }
                AA.KingOnTable = new DrawKing[KingHigh];
                for (var i = 0; i < KingHigh; i++)
                {

                    KingOnTable[i].Clone(ref AA.KingOnTable[i]);


                }
                AA.AStarGreedy = AStarGreedy;

                if (AA.TableList.Count > 0)
                    AA.TableList.Clear();
                for (var i = 0; i < TableList.Count; i++)
                    AA.TableList.Add(CloneATable(TableList[i]));
                if (AA.TableList.Count > 0)
                    AA.SetObjectNumbers(AA.TableList[0]);
                AA.AStarGreedy = AStarGreedy;
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("Clone:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //a Constructor
        public AllDraw(int Order, bool MovementsAStarGreedyHeuristicTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechnisa, bool BestMovment, bool PredictHurist, bool OnlySel, bool AStarGreedyHuris, bool Arrangments, AllDraw THi)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                

                OrderP = Order;
                MaxHeuristicxT = Int32.MinValue;
                MovementsAStarGreedyHeuristicFoundT = MovementsAStarGreedyHeuristicTFou;
                IgnoreSelfObjectsT = IgnoreSelfObject;
                UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisa;
                BestMovmentsT = BestMovment;
                PredictHeuristicT = PredictHurist;
                OnlySelfT = OnlySel;
                AStarGreedyHeuristicT = AStarGreedyHuris;
                if (!Arrangments)
                    ArrangmentsChanged = Arrangments;
                else
                    ArrangmentsChanged = Arrangments;
                Object Om = new Object();
                lock (Om)
                {
                    AStarGreedytMaxCount = 0;
                }
                Object Omm = new Object();
                lock (Omm)
                {
                    FoundATable = false;
                }
                CastlesKing = false;
                increasedProgress = 0;
                Object ol = new Object();
                lock (ol)
                {
                    CurrentHeuristic = Int32.MinValue;

                    DrawTable = false;

                    TableVeryfy = new int[8, 8];

                    TableVeryfyConst = new int[8, 8];

                    TableCurrent.Clear();

                    NoTableFound = false;

                    DynamicAStarGreedytPrograming = false;
                    UseDoubleTime = false;
                    AStarGreadyFirstSearch = true;
                    ImageRoot = AllDraw.Root + "\\Images";
                    ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
                }
                RedrawTable = true;
                SodierConversionOcuured = false;
                SodierMovments = 1;
                ElefantMovments = 1;
                HourseMovments = 1;
                CastleMovments = 1;
                MinisterMovments = 1;
                KingMovments = 1;
                SodierMidle = 8;
                SodierHigh = 16;
                ElefantMidle = 2;
                ElefantHigh = 4;
                HourseMidle = 2;
                HourseHight = 4;
                CastleMidle = 2;
                CastleHigh = 4;
                MinisterMidle = 1;
                MinisterHigh = 2;
                KingMidle = 1;
                KingHigh = 2;

                //APredict = null;
                RW = 0;
                CL = 0;
                Ki = 0;
                RW1 = 0;
                CL1 = 0;
                Ki1 = 0;
                MaxLess1 = 0;
                RW2 = 0;
                CL2 = 0;
                Ki2 = 0;
                MaxLess2 = 0;
                RW3 = 0;
                CL3 = 0;
                Ki3 = 0;
                MaxLess3 = 0;
                RW4 = 0;
                CL4 = 0;
                Ki4 = 0;
                MaxLess4 = 0;
                RW5 = 0;
                CL5 = 0;
                Ki5 = 0;
                MaxLess5 = 0;
                RW6 = 0;
                CL6 = 0;
                Ki6 = 0;
                MaxLess6 = 0;
                LoopHeuristicIndex = 0;
                Move = 0;
                //MouseClick = 0;
                AStarGreedyIndex = new int[20];
                AStarGreedy = 0;
                /*SolderesOnTable = null;
                ElephantOnTable = null;
                HoursesOnTable = null;
                CastlesOnTable = null;
                MinisterOnTable = null;
                KingOnTable = null;
                */
                Object OOOO = new Object();
                lock (OOOO)
                {
                    MaxDuringLevelThinkingCreation = System.Convert.ToInt32(AllDraw.THIScomboBoxMaxLevelText);
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("AllDraw_2:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Check For Thinking Of Current Item Movments Finished.
        public bool AllCurrentAStarGreedyThinkingFinished(AllDraw Dum, int i, int j, int Kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //For All kind of Current Thinking depend of current type consider finshing state Thinking.
                bool Finished = false;
                {
                    //For Soldier
                    if (Kind == 1)
                    {

                        if (Dum.SolderesOnTable[i].SoldierThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Elephant
                    else if (Kind == 2)
                    {
                        if (Dum.ElephantOnTable[i].ElefantThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Hourse.
                    else if (Kind == 3)
                    {
                        if (Dum.HoursesOnTable[i].HourseThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Castles.
                    else if (Kind == 4)
                    {
                        if (Dum.CastlesOnTable[i].CastleThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Minsters.
                    else if (Kind == 5)
                    {
                        if (Dum.MinisterOnTable[i].MinisterThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Kings.
                    else if (Kind == 6)
                    {
                        if (Dum.KingOnTable[i].KingThinking[0].ThinkingFinished)
                            return true;
                    }
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("AllCurrentAStarGreedyThinkingFinished:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Finished;

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("AllDraw_2:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        //Rearrange AllDraw Object Content.
        public void SetRowColumn(int index, bool Verify = false)
        {
            AllDraw thisAStarGreedyString = this.AStarGreedyString;

            if (Verify)
            {
                if (SetRowColumn())
                    return;
                int Dummy = OrderP;
                //long Time = TimeElapced.TimeNow(); Spaces++;
                Object a1 = new Object();
                lock (a1)
                {

                    SetObjectNumbers(TableList[0]);

                    int So1 = 0;
                    int So2 = SodierMidle;
                    int El1 = 0;
                    int El2 = ElefantMidle;
                    int Ho1 = 0;
                    int Ho2 = HourseMidle;
                    int Br1 = 0;
                    int Br2 = CastleMidle;
                    int Mi1 = 0;
                    int Mi2 = MinisterMidle;
                    int Ki1 = 0;
                    int Ki2 = KingMidle;


                    SetRowColumnFinished = false;

                    Move = 0;
                    //Intiate Dummy Variables.
                    //When Conversion Occured.

                    //When Table Exist.
                    if (TableList.Count > 0)
                    {
                        //For Every Table Things.
                        for (int Column = 0; Column < 8; Column++)
                            for (int Row = 0; Row < 8; Row++)
                            {
                                /* if (!TableZero(Tabl))
                                 {

                                     if (TableEqual(CloneATable(TableList[index]), Tabl))
                                         return;
                                 }*/
                                if (CloneATable(TableList[index])[Row, Column] == 0)
                                    continue;
                                //When Things are Soldiers.
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 1)
                                {
                                    //Determine int
                                    Color a;

                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //When int is Gray. 
                                    if (a == Color.Gray)
                                    {

                                        //Construct Soder Gray.
                                        SolderesOnTable[So1].Row = Row;
                                        SolderesOnTable[So1].Column = Column;

                                        //Increase So1.
                                        So1++;
                                        if (So1 > SodierMidle)
                                        {
                                            SodierMidle++;
                                            SodierHigh++;
                                        }



                                    }
                                    //When int is Brown
                                    else
                                    {

                                        //Construct Soldeir Brown.
                                        SolderesOnTable[So2].Row = Row;
                                        SolderesOnTable[So2].Column = Column;

                                        //Increase So2.
                                        So2++;
                                        if (So2 > SodierHigh)
                                            SodierHigh++;


                                    }
                                }
                                else //For Elephant Objects.
                                    if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 2)
                                {
                                    //Initiate Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }    //If Gray Elepahnt
                                    if (a == Color.Gray)
                                    {


                                        //Construction of Draw Object.
                                        ElephantOnTable[El1].Row = Row;
                                        ElephantOnTable[El1].Column = Column;

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(El1, OrderP, 2);
                                        //Increament of Gray Index.
                                        El1++;
                                        //If New Object Increament Gray Objects.
                                        if (El1 > ElefantMidle)
                                        {
                                            ElefantMidle++;
                                            ElefantHigh++;
                                        }

                                    }
                                    else//For Brown Elephant .Objects
                                    {


                                        //Construction of Draw Brown Elephant Object. 
                                        ElephantOnTable[El2].Row = Row;
                                        ElephantOnTable[El2].Column = Column;

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(El2, OrderP, 2);
                                        //Increament of Index.
                                        El2++;
                                        //When New Brown Elephant Object Increament of Index.
                                        if (El2 > ElefantHigh)
                                            ElefantHigh++;


                                    }
                                }
                                else//For Hourse Objects.
                                        if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 3)
                                {
                                    //Initiate Local Varibale and int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }                //If Gray Hourse.
                                    if (a == Color.Gray)
                                    {



                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho1].Row = Row;
                                        HoursesOnTable[Ho1].Column = Column;


                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(Ho1, OrderP, 3);
                                        //Increament of Index.
                                        Ho1++;
                                        //when There is New Gray Hourse Increase.
                                        if (Ho1 > HourseMidle)
                                        {
                                            HourseMidle++;
                                            HourseHight++;
                                        }

                                    }//For Brown Hourses.
                                    else
                                    {


                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho2].Row = Row;
                                        HoursesOnTable[Ho2].Column = Column;

                                        //Increament of Index.
                                        Ho2++;
                                        //When New Brown Hourse Exist Exist Index.
                                        if (Ho2 > HourseHight)
                                            HourseHight++;

                                    }
                                }
                                else//For Castles Objects.
                                            if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 4)
                                {
                                    //Initiate of Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }         //For Gray int.
                                    if (a == Color.Gray)
                                    {



                                        //Construction of New Draw Gray Castles.
                                        CastlesOnTable[Br1].Row = Row;
                                        CastlesOnTable[Br1].Column = Column;
                                        //Increamnt of Index.
                                        Br1++;
                                        //When New Gray Briges Increamnt Max Index.
                                        if (Br1 > CastleMidle)
                                        {
                                            CastleMidle++;
                                            CastleHigh++;
                                        }

                                    }//For Brown Castles.
                                    else
                                    {


                                        //Construction Draw of New Brown Castles.
                                        CastlesOnTable[Br2].Row = Row;
                                        CastlesOnTable[Br2].Column = Column;

                                        //Increament of Index.
                                        Br2++;
                                        //wehn Brown New Castles Detected Increament Max Index.
                                        if (Br2 > CastleHigh)
                                            CastleHigh++;

                                    }
                                }
                                else//For Minister Objects.
                                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 5)
                                {
                                    //Initiate Local int Varibales.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //For Gray ints.
                                    if (a == Color.Gray)
                                    {




                                        //construction of new draw Gray Minster.
                                        MinisterOnTable[Mi1].Row = Row;
                                        MinisterOnTable[Mi1].Column = Column;

                                        //Increament of Index.
                                        Mi1++;
                                        //Wehn New Gray Minster Detected Increament Max Indexes.
                                        if (Mi1 > MinisterMidle)
                                        {
                                            MinisterMidle++;
                                            MinisterHigh++;
                                        }


                                    }//For Brown  ints.
                                    else
                                    {


                                        //Construction of New Draw Brown Minster.
                                        MinisterOnTable[Mi2].Row = Row;
                                        MinisterOnTable[Mi2].Column = Column;

                                        //Increament Index.
                                        Mi2++;
                                        //When New Brown Minister Detected Increament Max Index.
                                        if (Mi2 > MinisterHigh)
                                            MinisterHigh++;

                                    }
                                }
                                else//for King Objects.        
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 6)
                                {
                                    //Initiate Of int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //int consideration.
                                    if (a == Color.Gray)
                                    {



                                        //Construction of New Draw Gray King.
                                        KingOnTable[Ki1].Row = Row;
                                        KingOnTable[Ki1].Column = Column;

                                        //Increament of Index.
                                        Ki1++;
                                        //when New Draw  Object Detected Increament Max Index.
                                        if (Ki1 > KingMidle)
                                        {
                                            KingMidle++;
                                            KingHigh++;

                                        }

                                    }//For Brown King int
                                    else
                                    {


                                        //Construction of New Draw King Brown Object.
                                        KingOnTable[Ki2].Row = Row;
                                        KingOnTable[Ki2].Column = Column;

                                        //Increament of Index.
                                        Ki2++;
                                        //When New Object Detected Increament Of Brown King Max Index.
                                        if (Ki2 > KingHigh)
                                            KingHigh++;

                                    }

                                }
                            }

                        //Make Empty Remaining.


                    }



                    SetObjectNumbers(TableList[0]);
                    for (var i = So1; i < SodierMidle; i++)
                        SolderesOnTable[i] = null;

                    for (var i = So2; i < SodierHigh; i++)
                        SolderesOnTable[i] = null;

                    for (var i = El1; i < ElefantMidle; i++)
                        ElephantOnTable[i] = null;

                    for (var i = El2; i < ElefantHigh; i++)
                        ElephantOnTable[i] = null;

                    for (var i = Ho1; i < HourseMidle; i++)
                        HoursesOnTable[i] = null;

                    for (var i = Ho2; i < HourseHight; i++)
                        HoursesOnTable[i] = null;

                    for (var i = Br1; i < CastleMidle; i++)
                        CastlesOnTable[i] = null;

                    for (var i = Br2; i < CastleHigh; i++)
                        CastlesOnTable[i] = null;

                    for (var i = Mi1; i < MinisterMidle; i++)
                        MinisterOnTable[i] = null;

                    for (var i = Mi2; i < MinisterHigh; i++)
                        MinisterOnTable[i] = null;

                    for (var i = Ki1; i < KingMidle; i++)
                        KingOnTable[i] = null;

                    for (var i = Ki2; i < KingHigh; i++)
                        KingOnTable[i] = null;
                    if (TableList.Count > 0)
                    {
                        for (var i = 0; i < 8; i++)
                            for (var j = 0; j < 8; j++)
                                Tabl[i, j] = TableList[0][i, j];
                    }
                    SetRowColumnFinished = true;
                }
                //{ //AllDraw.OutPut.Append("\r\n"); for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space); //AllDraw.OutPut.Append("SetRowColumn:" + (TimeElapced.TimeNow() - Time).ToString()); }
                Spaces--;
                this.AStarGreedyString = thisAStarGreedyString;
                OrderP = Dummy;
            }
            else
            {
                int Dummy = OrderP;
            
                //long Time = TimeElapced.TimeNow(); Spaces++;
                Object a1 = new Object();
                lock (a1)
                {

                    SetObjectNumbers(TableList[0]);

                    int So1 = 0;
                    int So2 = SodierMidle;
                    int El1 = 0;
                    int El2 = ElefantMidle;
                    int Ho1 = 0;
                    int Ho2 = HourseMidle;
                    int Br1 = 0;
                    int Br2 = CastleMidle;
                    int Mi1 = 0;
                    int Mi2 = MinisterMidle;
                    int Ki1 = 0;
                    int Ki2 = KingMidle;


                    SetRowColumnFinished = false;

                    Move = 0;
                    //Intiate Dummy Variables.
                    //When Conversion Occured.
                    SolderesOnTable = new DrawSoldier[SodierHigh];
                    ElephantOnTable = new DrawElefant[ElefantHigh];
                    HoursesOnTable = new DrawHourse[HourseHight];
                    CastlesOnTable = new DrawCastle[CastleHigh];
                    MinisterOnTable = new DrawMinister[MinisterHigh];
                    KingOnTable = new DrawKing[KingHigh];
                    AllDraw.SodierConversionOcuured = false;

                    //When Table Exist.
                    if (TableList.Count > 0)
                    {
                        //For Every Table Things.
                        for (int Column = 0; Column < 8; Column++)
                            for (int Row = 0; Row < 8; Row++)
                            {
                                /* if (!TableZero(Tabl))
                                 {

                                     if (TableEqual(CloneATable(TableList[index]), Tabl))
                                         return;
                                 }*/
                                if (CloneATable(TableList[index])[Row, Column] == 0)
                                    continue;
                                //When Things are Soldiers.
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 1)
                                {
                                    //Determine int
                                    Color a;

                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //When int is Gray. 
                                    if (a == Color.Gray)
                                    {

                                        //Construct Soder Gray.
                                        SolderesOnTable[So1] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, So1);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(So1, OrderP, 1);

                                        //Increase So1.
                                        So1++;
                                        if (So1 > SodierMidle)
                                        {
                                            SodierMidle++;
                                            SodierHigh++;
                                        }



                                    }
                                    //When int is Brown
                                    else
                                    {

                                        //Construct Soldeir Brown.
                                        SolderesOnTable[So2] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, So2);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(So2, OrderP, 1);
                                        //Increase So2.
                                        So2++;
                                        if (So2 > SodierHigh)
                                            SodierHigh++;


                                    }
                                }
                                else //For Elephant Objects.
                                    if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 2)
                                {
                                    //Initiate Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }    //If Gray Elepahnt
                                    if (a == Color.Gray)
                                    {


                                        //Construction of Draw Object.
                                        ElephantOnTable[El1] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, El1);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(El1, OrderP, 2);
                                        //Increament of Gray Index.
                                        El1++;
                                        //If New Object Increament Gray Objects.
                                        if (El1 > ElefantMidle)
                                        {
                                            ElefantMidle++;
                                            ElefantHigh++;
                                        }

                                    }
                                    else//For Brown Elephant .Objects
                                    {


                                        //Construction of Draw Brown Elephant Object. 
                                        ElephantOnTable[El2] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, El2);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(El2, OrderP, 2);
                                        //Increament of Index.
                                        El2++;
                                        //When New Brown Elephant Object Increament of Index.
                                        if (El2 > ElefantHigh)
                                            ElefantHigh++;


                                    }
                                }
                                else//For Hourse Objects.
                                        if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 3)
                                {
                                    //Initiate Local Varibale and int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }                //If Gray Hourse.
                                    if (a == Color.Gray)
                                    {



                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho1] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Ho1);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(Ho1, OrderP, 3);
                                        //Increament of Index.
                                        Ho1++;
                                        //when There is New Gray Hourse Increase.
                                        if (Ho1 > HourseMidle)
                                        {
                                            HourseMidle++;
                                            HourseHight++;
                                        }

                                    }//For Brown Hourses.
                                    else
                                    {


                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho2] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Ho2);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(Ho2, OrderP, 3);
                                        //Increament of Index.
                                        Ho2++;
                                        //When New Brown Hourse Exist Exist Index.
                                        if (Ho2 > HourseHight)
                                            HourseHight++;

                                    }
                                }
                                else//For Castles Objects.
                                            if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 4)
                                {
                                    //Initiate of Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }         //For Gray int.
                                    if (a == Color.Gray)
                                    {



                                        //Construction of New Draw Gray Castles.
                                        CastlesOnTable[Br1] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Br1);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(Br1, OrderP, 4);
                                        //Increamnt of Index.
                                        Br1++;
                                        //When New Gray Briges Increamnt Max Index.
                                        if (Br1 > CastleMidle)
                                        {
                                            CastleMidle++;
                                            CastleHigh++;
                                        }

                                    }//For Brown Castles.
                                    else
                                    {


                                        //Construction Draw of New Brown Castles.
                                        CastlesOnTable[Br2] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Br2);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(Br2, OrderP, 4);
                                        //Increament of Index.
                                        Br2++;
                                        //wehn Brown New Castles Detected Increament Max Index.
                                        if (Br2 > CastleHigh)
                                            CastleHigh++;

                                    }
                                }
                                else//For Minister Objects.
                                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 5)
                                {
                                    //Initiate Local int Varibales.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //For Gray ints.
                                    if (a == Color.Gray)
                                    {




                                        //construction of new draw Gray Minster.
                                        MinisterOnTable[Mi1] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Mi1);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(Mi1, OrderP, 5);
                                        //Increament of Index.
                                        Mi1++;
                                        //Wehn New Gray Minster Detected Increament Max Indexes.
                                        if (Mi1 > MinisterMidle)
                                        {
                                            MinisterMidle++;
                                            MinisterHigh++;
                                        }


                                    }//For Brown  ints.
                                    else
                                    {


                                        //Construction of New Draw Brown Minster.
                                        MinisterOnTable[Mi2] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Mi2);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(Mi2, OrderP, 5);
                                        //Increament Index.
                                        Mi2++;
                                        //When New Brown Minister Detected Increament Max Index.
                                        if (Mi2 > MinisterHigh)
                                            MinisterHigh++;

                                    }
                                }
                                else//for King Objects.        
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 6)
                                {
                                    //Initiate Of int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //int consideration.
                                    if (a == Color.Gray)
                                    {



                                        //Construction of New Draw Gray King.
                                        KingOnTable[Ki1] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Ki1);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(Ki1, OrderP, 6);
                                        //Increament of Index.
                                        Ki1++;
                                        //when New Draw  Object Detected Increament Max Index.
                                        if (Ki1 > KingMidle)
                                        {
                                            KingMidle++;
                                            KingHigh++;

                                        }

                                    }//For Brown King int
                                    else
                                    {


                                        //Construction of New Draw King Brown Object.
                                        KingOnTable[Ki2] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Ki2);

                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(Ki2, OrderP, 6);
                                        //Increament of Index.
                                        Ki2++;
                                        //When New Object Detected Increament Of Brown King Max Index.
                                        if (Ki2 > KingHigh)
                                            KingHigh++;

                                    }

                                }
                            }

                        //Make Empty Remaining.


                    }



                    SetObjectNumbers(TableList[0]);
                    for (var i = So1; i < SodierMidle; i++)
                        SolderesOnTable[i] = null;

                    for (var i = So2; i < SodierHigh; i++)
                        SolderesOnTable[i] = null;

                    for (var i = El1; i < ElefantMidle; i++)
                        ElephantOnTable[i] = null;

                    for (var i = El2; i < ElefantHigh; i++)
                        ElephantOnTable[i] = null;

                    for (var i = Ho1; i < HourseMidle; i++)
                        HoursesOnTable[i] = null;

                    for (var i = Ho2; i < HourseHight; i++)
                        HoursesOnTable[i] = null;

                    for (var i = Br1; i < CastleMidle; i++)
                        CastlesOnTable[i] = null;

                    for (var i = Br2; i < CastleHigh; i++)
                        CastlesOnTable[i] = null;

                    for (var i = Mi1; i < MinisterMidle; i++)
                        MinisterOnTable[i] = null;

                    for (var i = Mi2; i < MinisterHigh; i++)
                        MinisterOnTable[i] = null;

                    for (var i = Ki1; i < KingMidle; i++)
                        KingOnTable[i] = null;

                    for (var i = Ki2; i < KingHigh; i++)
                        KingOnTable[i] = null;
                    if (TableList.Count > 0)
                    {
                        for (var i = 0; i < 8; i++)
                            for (var j = 0; j < 8; j++)
                                Tabl[i, j] = TableList[0][i, j];
                    }
                    SetRowColumnFinished = true;
                }
                //{ //AllDraw.OutPut.Append("\r\n"); for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space); //AllDraw.OutPut.Append("SetRowColumn:" + (TimeElapced.TimeNow() - Time).ToString()); }
                Spaces--;
                this.AStarGreedyString = thisAStarGreedyString;
                OrderP = Dummy;
                SetObjectNumbers(Tabl);
            }
        }
        public bool SetRowColumn()
        {
            int Dummy = OrderP;
            AllDraw thisAStarGreedyString = this.AStarGreedyString;
            //long Time = TimeElapced.TimeNow(); Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                SetObjectNumbers(TableList[0]);

                int So1 = 0;
                int So2 = SodierMidle;
                int El1 = 0;
                int El2 = ElefantMidle;
                int Ho1 = 0;
                int Ho2 = HourseMidle;
                int Br1 = 0;
                int Br2 = CastleMidle;
                int Mi1 = 0;
                int Mi2 = MinisterMidle;
                int Ki1 = 0;
                int Ki2 = KingMidle;


                SetRowColumnFinished = false;

                Move = 0;

                //When Table Exist.
                if (TableList.Count > 0)
                {
                    //For Every Table Things.
                    for (int Column = 0; Column < 8; Column++)
                        for (int Row = 0; Row < 8; Row++)
                        {
                            /* if (!TableZero(Tabl))
                             {

                                 if (TableEqual(CloneATable(TableList[0]), Tabl))
                                     return;
                             }*/
                            if (CloneATable(TableList[0])[Row, Column] == 0)
                                continue;
                            //When Things are Soldiers.
                            if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 1)
                            {
                                //Determine int
                                Color a;

                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //When int is Gray. 
                                if (a == Color.Gray)
                                {
                                    if (TableList[0][(int)SolderesOnTable[So1].Row, (int)SolderesOnTable[So1].Column] != 1)
                                        return false;

                                    //Increase So1.
                                    So1++;
                                    if (So1 > SodierMidle)
                                    {
                                        SodierMidle++;
                                        SodierHigh++;
                                    }



                                }
                                //When int is Brown
                                else
                                {

                                    if (TableList[0][(int)SolderesOnTable[So2].Row, (int)SolderesOnTable[So2].Column] != -1)
                                        return false;
                                    //Increase So2.
                                    So2++;
                                    if (So2 > SodierHigh)
                                        SodierHigh++;


                                }
                            }
                            else //For Elephant Objects.
                                if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 2)
                            {
                                //Initiate Local Variables.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }    //If Gray Elepahnt
                                if (a == Color.Gray)
                                {


                                    if (TableList[0][(int)ElephantOnTable[El1].Row, (int)ElephantOnTable[El1].Column] != 2)
                                        return false;
                                    //Increament of Gray 0.
                                    El1++;
                                    //If New Object Increament Gray Objects.
                                    if (El1 > ElefantMidle)
                                    {
                                        ElefantMidle++;
                                        ElefantHigh++;
                                    }

                                }
                                else//For Brown Elephant .Objects
                                {


                                    if (TableList[0][(int)ElephantOnTable[El2].Row, (int)ElephantOnTable[El2].Column] != -2)
                                        return false;
                                    //Increament of 0.
                                    El2++;
                                    //When New Brown Elephant Object Increament of 0.
                                    if (El2 > ElefantHigh)
                                        ElefantHigh++;


                                }
                            }
                            else//For Hourse Objects.
                                    if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 3)
                            {
                                //Initiate Local Varibale and int.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }                //If Gray Hourse.
                                if (a == Color.Gray)
                                {



                                    if (TableList[0][(int)HoursesOnTable[Ho1].Row, (int)HoursesOnTable[Ho1].Column] != 3)
                                        return false;
                                    //Increament of 0.
                                    Ho1++;
                                    //when There is New Gray Hourse Increase.
                                    if (Ho1 > HourseMidle)
                                    {
                                        HourseMidle++;
                                        HourseHight++;
                                    }

                                }//For Brown Hourses.
                                else
                                {


                                    if (TableList[0][(int)HoursesOnTable[Ho2].Row, (int)HoursesOnTable[Ho2].Column] != -3)
                                        return false;
                                    //Increament of 0.
                                    Ho2++;
                                    //When New Brown Hourse Exist Exist 0.
                                    if (Ho2 > HourseHight)
                                        HourseHight++;

                                }
                            }
                            else//For Castles Objects.
                                        if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 4)
                            {
                                //Initiate of Local Variables.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }         //For Gray int.
                                if (a == Color.Gray)
                                {



                                    if (TableList[0][(int)CastlesOnTable[Br1].Row, (int)CastlesOnTable[Br1].Column] != 4)
                                        return false;
                                    //Increamnt of 0.
                                    Br1++;
                                    //When New Gray Briges Increamnt Max 0.
                                    if (Br1 > CastleMidle)
                                    {
                                        CastleMidle++;
                                        CastleHigh++;
                                    }

                                }//For Brown Castles.
                                else
                                {


                                    if (TableList[0][(int)CastlesOnTable[Br2].Row, (int)CastlesOnTable[Br2].Column] != -4)
                                        return false;
                                    //Increament of 0.
                                    Br2++;
                                    //wehn Brown New Castles Detected Increament Max 0.
                                    if (Br2 > CastleHigh)
                                        CastleHigh++;

                                }
                            }
                            else//For Minister Objects.
                                            if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 5)
                            {
                                //Initiate Local int Varibales.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //For Gray ints.
                                if (a == Color.Gray)
                                {




                                    if (TableList[0][(int)MinisterOnTable[Mi1].Row, (int)MinisterOnTable[Mi1].Column] != 5)
                                        return false;
                                    //Increament of 0.
                                    Mi1++;
                                    //Wehn New Gray Minster Detected Increament Max 0es.
                                    if (Mi1 > MinisterMidle)
                                    {
                                        MinisterMidle++;
                                        MinisterHigh++;
                                    }


                                }//For Brown  ints.
                                else
                                {


                                    if (TableList[0][(int)MinisterOnTable[Mi2].Row, (int)MinisterOnTable[Mi2].Column] != -5)
                                        return false;
                                    //Increament 0.
                                    Mi2++;
                                    //When New Brown Minister Detected Increament Max 0.
                                    if (Mi2 > MinisterHigh)
                                        MinisterHigh++;

                                }
                            }
                            else//for King Objects.        
                            if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 6)
                            {
                                //Initiate Of int.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //int consideration.
                                if (a == Color.Gray)
                                {



                                    if (TableList[0][(int)KingOnTable[Ki1].Row, (int)KingOnTable[Ki1].Column] != 6)
                                        return false;
                                    //Increament of 0.
                                    Ki1++;
                                    //when New Draw  Object Detected Increament Max 0.
                                    if (Ki1 > KingMidle)
                                    {
                                        KingMidle++;
                                        KingHigh++;

                                    }

                                }//For Brown King int
                                else
                                {


                                    if (TableList[0][(int)KingOnTable[Ki2].Row, (int)KingOnTable[Ki2].Column] != -6)
                                        return false;
                                    //Increament of 0.
                                    Ki2++;
                                    //When New Object Detected Increament Of Brown King Max 0.
                                    if (Ki2 > KingHigh)
                                        KingHigh++;

                                }

                            }
                        }

                    //Make Empty Remaining.


                }



                SetObjectNumbers(TableList[0]);
                for (var i = So1; i < SodierMidle; i++)
                    SolderesOnTable[i] = null;

                for (var i = So2; i < SodierHigh; i++)
                    SolderesOnTable[i] = null;

                for (var i = El1; i < ElefantMidle; i++)
                    ElephantOnTable[i] = null;

                for (var i = El2; i < ElefantHigh; i++)
                    ElephantOnTable[i] = null;

                for (var i = Ho1; i < HourseMidle; i++)
                    HoursesOnTable[i] = null;

                for (var i = Ho2; i < HourseHight; i++)
                    HoursesOnTable[i] = null;

                for (var i = Br1; i < CastleMidle; i++)
                    CastlesOnTable[i] = null;

                for (var i = Br2; i < CastleHigh; i++)
                    CastlesOnTable[i] = null;

                for (var i = Mi1; i < MinisterMidle; i++)
                    MinisterOnTable[i] = null;

                for (var i = Mi2; i < MinisterHigh; i++)
                    MinisterOnTable[i] = null;

                for (var i = Ki1; i < KingMidle; i++)
                    KingOnTable[i] = null;

                for (var i = Ki2; i < KingHigh; i++)
                    KingOnTable[i] = null;
                if (TableList.Count > 0)
                {
                    for (var i = 0; i < 8; i++)
                        for (var j = 0; j < 8; j++)
                            Tabl[i, j] = TableList[0][i, j];
                }
                SetRowColumnFinished = true;
            }
            //{ //AllDraw.OutPut.Append("\r\n"); for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space); //AllDraw.OutPut.Append("SetRowColumn:" + (TimeElapced.TimeNow() - Time).ToString()); }
            Spaces--;
            this.AStarGreedyString = thisAStarGreedyString;
            OrderP = Dummy;
            return true;
        }

        //Waite semaphore
        void SetRowColumnFinishedWait()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                do
                {


                } while (!SetRowColumnFinished);
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("SetRowColumnFinishedWait:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Max Index List Of Heuristic AStarGreedy First Method.
        public void BeginIndexFoundingMaxLessofMaxList(int ListIndex, List<int> Founded, ref int LessB)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //When There is Maximum Huristsic AStar Gredy Back Ward in Blitz Games.
                if (MaxHeuristicAStarGreedytBackWard.Count > 0)
                {
                    //When List Index is LessB than Founded.
                    if (ListIndex < MaxHeuristicAStarGreedytBackWard.Count)
                        return;
                    //Initiate Variable.
                    bool Added = false;
                    //Recursive Method.
                    BeginIndexFoundingMaxLessofMaxList(ListIndex++, Founded, ref LessB);
                    //When Greater LessB of First index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][1])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][1];
                        Added = true;

                        Founded.Add(2);
                    }
                    //When Greater LessB of Second index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][5])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][5];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(6);
                    }
                    //When Greater LessB of Third index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][9])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][9];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(10);
                    }
                    //When Greater LessB of Foutrh index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][13])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][13];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(14);
                    }
                    //When Greater LessB of Fifth index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][18])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][18];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(19);
                    }
                    //When Greater LessB of Sith index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][22])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][22];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(23);
                    }
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BeginIndexFoundingMaxLessofMaxList:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Method for Check of Existence of Checkmate less than for checked mate.
        bool IsToCheckMateHasLessDeeperThanForCheckMate(AllDraw A, int Order, ref int ToCheckMate, ref int ForCheckMate, int AStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                //Initiate variables.
                bool AA = false;
                int CDummy = Order;
                //For Gray One.
                if (Order == 1)
                {

                    //For Solderis.
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == -1)
                            {
                                //Set.
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;



                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                }
                else
                {
                    //ChessRules.CurrentOrder = -1;
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }


                            Order *= -1;
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {


                            //When there is Brown checked mate.
                            if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }


                            Order *= -1;
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }

                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsToCheckMateHasLessDeeperThanForCheckMate:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                ChessRules.CurrentOrder = CDummy;
                return AA;
            }
        }
        //When Penalty Regard Branches expanded to sub branches.
        void IsPenaltyRegardCheckMateAtBranch(int Order, ref int Do, AllDraw Base)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                int CDummy = ChessRules.CurrentOrder;
                int COrder = Order;
                //For Gray Order.
                if (Order == 1)
                {
                    ChessRules AA = null;

                    //ChessRules.CurrentOrder = 1;
                    //For  Soldeirs.
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            //Create Rules Objects For Soldiers.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, SolderesOnTable[i].SoldierThinking[0].TableListSolder[j][SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]]
                                , SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]
                                , Order
                                , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0]
                                , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]);
                            //When CheckMate Occured for Current Sodiers
                            if (AA.CheckMate(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Order))
                                //When Self CheckMate
                                if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Return Ignore
                                    Do = -1;
                                    //Set Superposition.
                                    SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //When Enemy CheckMate
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard and Set Movements.
                                        Do = 1;
                                        //Regard Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        //Set Superpostion.
                                        SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = 1;
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Subbranchs.
                                for (var ii = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                    SolderesOnTable[ii].SoldierThinking[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }

                        }
                    //For Elephant.
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            //Create Elephant Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ElephantOnTable[i].ElefantThinking[0].TableListElefant[j][ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]]
                            , ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]
                            , Order
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0]
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]);
                            //When CheckMate Occured for Current Elephant.
                            if (AA.CheckMate(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Order))
                                //For Self Order CheckMate.
                                if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Set Penalty Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //For Enemy Order CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard Continue.
                                        Do = 1;
                                        //Regard Subolders.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        //Set Superposition.
                                        ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = 1;
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Subbranchs.
                                for (var ii = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    ElephantOnTable[ii].ElefantThinking[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Hourse.
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {


                            //Set Hourse Rules Objects.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, HoursesOnTable[i].HourseThinking[0].TableListHourse[j][HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]]
                            , HoursesOnTable[i].HourseThinking[0].TableListHourse[j]
                            , Order
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0]
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]);
                            //When CheckMate Occured.
                            if (AA.CheckMate(HoursesOnTable[i].HourseThinking[0].TableListSolder[j], Order))
                                //For Self CheckMate.
                                if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = 1;
                                        //Set Regard For Sub Branches.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Sub branchs For Hourse.
                                for (var ii = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Gray Briges.
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {


                            //Castles Gray Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CastlesOnTable[i].CastleThinking[0].TableListCastle[j][CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0], CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]]
                            , CastlesOnTable[i].CastleThinking[0].TableListCastle[j]
                            , Order
                            , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0]
                            , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]);
                            //When Current Gray Castles CheckMate.
                            if (AA.CheckMate(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Order))
                                //For Self CheckMate
                                if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Set Penalty Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Sub branchs.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = 1;
                                        //Set Regard Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Castles Gray Subbranchs.

                                for (var ii = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Ministers Gray.
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {


                            //Minister Gray Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, MinisterOnTable[i].MinisterThinking[0].TableListMinister[j][MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]]
                            , MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]
                            , Order
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0]
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]);
                            //When M ate Occured in Minister Gray.
                            if (AA.CheckMate(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Order))
                                //Self CheckMate.
                                if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superpostion.
                                    MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = 1;
                                        //Set Subbranchs Regard.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Gray Ministers Subbranchs.

                                for (var ii = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Gray King.
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {


                            //Gray King Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, KingOnTable[i].KingThinking[0].TableListKing[j][KingOnTable[i].KingThinking[0].RowColumnKing[j][0], KingOnTable[i].KingThinking[0].RowColumnKing[j][1]]
                            , KingOnTable[i].KingThinking[0].TableListKing[j]
                            , Order
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][0]
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][1]);
                            //When CheckMate Occured in King Gray.
                            if (AA.CheckMate(KingOnTable[i].KingThinking[0].TableListKing[j], Order))
                                //Self CheckMate.
                                if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superposition.
                                    KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For King Gray Subbranchs.

                                for (var ii = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                }
                //For Brown Order.
                else
                {
                    ChessRules AA = null;
                    //ChessRules.CurrentOrder = -1;
                    //For Solders Brown.
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            //Solders Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, SolderesOnTable[i].SoldierThinking[0].TableListSolder[j][SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]]
                            , SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]
                            , Order
                            , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0]
                            , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]);
                            //When Solders Brown CheckMate Occured.
                            if (AA.CheckMate(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Order))
                                //Self CheckMate.
                                if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Supperpoistion.
                                    SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs Soders Brown.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoition.
                                        SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = 1;
                                        //Penalty Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Solders Brown Subbranchs Calling.

                                for (var ii = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Elephant Brown 
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            //Elephant Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ElephantOnTable[i].ElefantThinking[0].TableListElefant[j][ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]]
                            , ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]
                            , Order
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0]
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]);
                            //CheckMate Occured in Elephenat Brown.
                            if (AA.CheckMate(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Order))
                                //Self CheckMate.
                                if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Superpoistion.
                                    ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regrading.
                                        Do = 1;
                                        //Superposition.
                                        ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = 1;
                                        //Regrad Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Subbranchs Elephenat Brown Calling.

                                for (var ii = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Hourse Brown 
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {


                            //Hourse Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, HoursesOnTable[i].HourseThinking[0].TableListHourse[j][HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]]
                            , HoursesOnTable[i].HourseThinking[0].TableListHourse[j]
                            , Order
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0]
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]);
                            //When Hourse Broin CheckMate Ocuucred.
                            if (AA.CheckMate(HoursesOnTable[i].HourseThinking[0].TableListSolder[j], Order))
                                //Self CheckMate.
                                if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Superposition.
                                    HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regrad.
                                        Do = 1;
                                        //Superposition.
                                        HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = 1;
                                        //Regrad Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Hourse Brown Calling Subbranchs.

                                for (var ii = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Castles Brown 
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {


                            //Castles Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CastlesOnTable[i].CastleThinking[0].TableListCastle[j][CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0], CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]]
                            , CastlesOnTable[i].CastleThinking[0].TableListCastle[j]
                            , Order
                            , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0]
                            , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]);
                            //When Brown Castles CheckMate Occured.
                            if (AA.CheckMate(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Order))
                                //Self CheckMate.
                                if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore CheckMate.
                                    Do = -1;
                                    //Superpoistion.
                                    CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = -1;
                                    //Subbranchs Penalty.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Brown Castles Calling Subbranches.

                                for (var ii = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Minister Brown 
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {


                            //Minister Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, MinisterOnTable[i].MinisterThinking[0].TableListMinister[j][MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]]
                            , MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]
                            , Order
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0]
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]);
                            //When Minister Borwn CheckMate Occcured.
                            if (AA.CheckMate(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Order))
                                //Self CheckMate.
                                if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Superpoistion.
                                    MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranches.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard SubBranches.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }


                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Minister Brown SubBranches Calling.

                                for (var ii = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //King Brown
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {


                            //King Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, KingOnTable[i].KingThinking[0].TableListKing[j][KingOnTable[i].KingThinking[0].RowColumnKing[j][0], KingOnTable[i].KingThinking[0].RowColumnKing[j][1]]
                            , KingOnTable[i].KingThinking[0].TableListKing[j]
                            , Order
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][0]
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][1]);
                            //When King Brown Rules CheckMate Occcured.
                            if (AA.CheckMate(KingOnTable[i].KingThinking[0].TableListKing[j], Order))
                                //Self CheckMate.
                                if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Superposition.
                                    KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty SubBranches.
                                    MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranches.
                                        MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                }


                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //King Brown Subbranches Calling.

                                for (var ii = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }

                }
                ChessRules.CurrentOrder = CDummy;
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsPenaltyRegardCheckMateAtBranch:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //A Mechanisam for penalty all subbranches of chiled of root at contained of same childes  of making penalty by target 
        public void MakePenaltyAllCheckMateBranches(AllDraw A, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                int COrder = Order;
                int CDummy = ChessRules.CurrentOrder;
                if (Order == 1)
                {
                    //For Solider Gray
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //make penalty
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                            //For deeper chiled.
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //For Elephant Gray 
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            //make penalty
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();

                            //For Depper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //For Hourse Gray
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //make penalty
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();


                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for Castle gray
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //make penalty
                            A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for minister gray
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //make penalty
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for gray king
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //make penalty  
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
                else//brown
                {
                    //for soldier brown
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //make penalty
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for elephant brown
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //make penalty
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for hourse brown
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //make penalty
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();


                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for casytle brown
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //make penalty
                            A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for minsiter brown
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //make penalty
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();

                            //fopfor weeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for king brown
                    for (var i = KingMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //make penalty
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("MakePenaltyAllCheckMateBranches:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //remove penalty from root current node.
        public AllDraw RemovePenalltyFromFirstBranches(int Order)

        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //gray
                if (Order == 1)
                {
                    //for gray solder
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate();
                            for (int k = 0; k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; k++)
                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);

                        }
                    //for gray elephant
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;


                            ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate();
                            for (int k = 0; k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; k++)
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    //for gray hourse
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate();
                            for (int k = 0; k < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; k++)
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);



                        }
                    //for Castle gray
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;


                            CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].Initiate();
                            for (int k = 0; k < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; k++)
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    //for gray minsiter
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;


                            MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate();
                            for (int k = 0; k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; k++)
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    //for gray minster
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;


                            KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate();
                            for (int k = 0; k < KingOnTable[i].KingThinking[0].AStarGreedy.Count; k++)
                                KingOnTable[i].KingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                }
                else
                {
                    //for brown soldeir
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;


                            SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate();
                            for (int k = 0; k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; k++)
                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);

                        }
                    //for brown elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;


                            ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate();
                            for (int k = 0; k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; k++)
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    //for brown hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;


                            HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate();
                            for (int k = 0; k < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; k++)
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);



                        }
                    //for brown Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;


                            CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].Initiate();
                            for (int k = 0; k < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; k++)
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    //for brown ,minster
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;


                            MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate();
                            for (int k = 0; k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; k++)
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    //for brown king
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null
                            && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate();
                            for (int k = 0; k < KingOnTable[i].KingThinking[0].AStarGreedy.Count; k++)
                                KingOnTable[i].KingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("RemovePenalltyFromFirstBranches:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return this;
            }

        }
        //when index is out of boundry return false when is valid return true
        bool BondryObjectNumber(int i, int Kind, int Order)
        {
            bool Is = true;
            if (Order == 1)
            {
                if (Kind == 1)
                {
                    if (i >= SodierMidle)
                        Is = false;
                }
                else
                    if (Kind == 2)
                {
                    if (i >= ElefantMidle)
                        Is = false;
                }
                else
                    if (Kind == 3)
                {
                    if (i >= HourseMidle)
                        Is = false;
                }
                else
                    if (Kind == 4)
                {
                    if (i >= CastleMidle)
                        Is = false;
                }
                else
                    if (Kind == 5)
                {
                    if (i >= MinisterMidle)
                        Is = false;
                }
                else
                    if (Kind == 6)
                {
                    if (i >= KingMidle)
                        Is = false;
                }
            }
            else
            {
                if (Kind == 1)
                {
                    if (i < SodierMidle || i >= SodierHigh)
                        Is = false;
                }
                else
                   if (Kind == 2)
                {
                    if (i < ElefantMidle || i >= ElefantHigh)
                        Is = false;
                }
                else
                   if (Kind == 3)
                {
                    if (i < HourseMidle || i >= HourseHight)
                        Is = false;
                }
                else
                   if (Kind == 4)
                {
                    if (i < CastleMidle || i >= CastleHigh)
                        Is = false;
                }
                else
                   if (Kind == 5)
                {
                    if (i < MinisterMidle || i >= MinisterHigh)
                        Is = false;
                }
                else
                   if (Kind == 6)
                {
                    if (i < KingMidle || i >= KingHigh)
                        Is = false;
                }
            }
            return Is;
        }
        //All valid call of current alldraw deeper of founding get node.
        public AllDraw FoundOfCurrentTableNodeAstardGreedy(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //soldier
            if (BondryObjectNumber(i, 1, Order) && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                {
                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref THIS, ref Found);
                }
            }
            //elephant
            if (BondryObjectNumber(i, 2, Order) && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                {
                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref THIS, ref Found);
                }
            }
            //hourse
            if (BondryObjectNumber(i, 3, Order) && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                {
                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref THIS, ref Found);
                }
            }
            //Castle
            if (BondryObjectNumber(i, 4, Order) && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                {
                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref THIS, ref Found);
                }
            }
            //minster
            if (BondryObjectNumber(i, 5, Order) && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                {
                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref THIS, ref Found);
                }
            }
            //king
            if (BondryObjectNumber(i, 6, Order) && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j && KingOnTable[i].KingThinking[0].AStarGreedy != null)

                if (KingOnTable[i].KingThinking[0].AStarGreedy.Count > j && KingOnTable[i].KingThinking[0].AStarGreedy != null)
                {

                    //for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                    {
                        KingOnTable[i].KingThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref THIS, ref Found);
                    }
                }
            return THIS;
        }

        //when current alldraw is equal of table state return node and set true
        public AllDraw FoundOfCurrentTableNode(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //when current stisgied
                if ((TableList.Count > 0 && ThinkingChess.TableEqual(TableList[0], Tab)) || FoundOfCurrentTableNodeFirstLevel(Tab, Order, ref THIS, ref Found))
                {
                    if (!Found)
                    {
                        THIS = this;
                        Found = true;
                    }
                    //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfCurrentTableNode:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return THIS;
                }

                else//else gray
                if (Order == 1)
                {
                    //soldier
                    for (var i = 0; i < SodierMidle; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            if (IsSupHuTrue(i, j, 0, 1))
                                continue;

                            if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                            {
                                FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                //for (int k = 0; SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; k++)
                                //SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;


                            }
                        }
                    }
                    //elephant
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            if (IsSupHuTrue(i, j, 0, 2))
                                continue;

                            if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                            {
                                FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {


                                //for (int k = 0; ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; k++)
                                //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //hourse
                    for (var i = 0; i < HourseMidle; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            if (IsSupHuTrue(i, j, 0, 3))
                                continue;

                            if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                            {
                                FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {

                                //for (int k = 0; HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && k < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; k++)
                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //Castle
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            if (IsSupHuTrue(i, j, 0, 4))
                                continue;


                            if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                            {
                                FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //for (int k = 0; CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && k < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; k++)
                                // CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //minster
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            if (IsSupHuTrue(i, j, 0, 5))
                                continue;
                            if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                            {
                                FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //for (int k = 0; MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; k++)
                                //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //king
                    for (var i = 0; i < KingMidle; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            if (IsSupHuTrue(i, j, 0, 6))
                                continue;

                            if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                            {
                                FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //for (int k = 0; KingOnTable[i].KingThinking[0].AStarGreedy != null && k < KingOnTable[i].KingThinking[0].AStarGreedy.Count; k++)
                                //KingOnTable[i].KingThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                }//brown
                else
                {
                    //soldier
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            if (IsSupHuTrue(i, j, 0, 1))
                                continue;

                            if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                            {
                                FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                //for (int k = 0; SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; k++)
                                //SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            if (IsSupHuTrue(i, j, 0, 2))
                                continue;


                            if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                            {
                                FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                //for (int k = 0; ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; k++)
                                //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            if (IsSupHuTrue(i, j, 0, 3))
                                continue;


                            if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                            {
                                FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                //for (int k = 0; HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && k < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; k++)
                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            if (IsSupHuTrue(i, j, 0, 4))
                                continue;

                            if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                            {
                                FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {
                                //for (int k = 0; CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && k < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; k++)
                                ///CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //minister 
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            if (IsSupHuTrue(i, j, 0, 5))
                                continue;


                            if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                            {
                                FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {
                                //for (int k = 0; MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; k++)
                                //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //king
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            if (IsSupHuTrue(i, j, 0, 6))
                                continue;

                            if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                            {
                                FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {
                                //for (int k = 0; KingOnTable[i].KingThinking[0].AStarGreedy != null && k < KingOnTable[i].KingThinking[0].AStarGreedy.Count; k++)
                                //KingOnTable[i].KingThinking[0].AStarGreedy[k].
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                }
                return THIS;
            }
        }
        public AllDraw FoundOfCurrentTableNodeCreateAStarGreedy(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {


                //else gray
                if (Order == 1)
                {
                    //soldier
                    for (var i = 0; i < SodierMidle; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                            {
                                FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;


                            }
                        }
                    }
                    //elephant
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                            {
                                FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {


                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //hourse
                    for (var i = 0; i < HourseMidle; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                            {
                                FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {


                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //Castle
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                            {
                                FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //minster
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                            {
                                FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //king
                    for (var i = 0; i < KingMidle; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                            {
                                FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                }//brown
                else
                {
                    //soldier
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                            {
                                FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                            {
                                FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                            {
                                FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                            {
                                FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    //minister 
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                            {
                                FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //king
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                            {
                                FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                }
                return THIS;
            }
        }
        //when current level founf of node
        public bool FoundOfCurrentTableNodeFirstLevel(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (!Found)
                FoundOfCurrentTableNodeSoldeir(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeElephant(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeHourse(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeCastle(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeMinister(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeKing(Tab, Order, ref THIS, ref Found);

            return Found;
        }
        //when deeper have some calclulated nodes
        bool IsAstargreedyHaveNode(int Kind, int Order)
        {

            bool Is = false;
            if (Order == 1)
            {
                if (Kind == 1)
                {
                    for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                    {
                        if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 2)
                {
                    for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                    {
                        if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                        }
                    }

                }
                else if (Kind == 3)
                {
                    for (int i = 0; HoursesOnTable != null && i < HourseMidle; i++)
                    {
                        if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 4)
                {
                    for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                    {
                        if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 5)
                {
                    for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                    {
                        if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else
                    if (Kind == 6)
                {
                    for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                    {
                        if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }

            }
            else
            {
                if (Kind == 1)
                {
                    for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                    {
                        if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 2)
                {
                    for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                    {
                        if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 3)
                {
                    for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                    {
                        if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else
                    if (Kind == 4)
                {
                    for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                    {
                        if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else
                    if (Kind == 5)
                {
                    for (int i = MinisterHigh; MinisterOnTable != null && i < MinisterHigh; i++)
                    {
                        if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 6)
                {
                    for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                    {
                        if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
            }

            return Is;


        }
        public void ClearAllTablesHeuristicsAndMoreGray(int Order)
        {
            Object O = new Object();
            lock (O)
            {      //soldier
                for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                {
                    if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreSoldier(Order, i, j);
                        }
                    }
                }
                //elephant
                for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                {
                    if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                    {
                        for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreElephant(Order, i, j);
                        }
                    }
                }
                //hourse
                for (int i = 0; HoursesOnTable != null && i < HourseMidle; i++)
                {
                    if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                    {
                        for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreHourse(Order, i, j);
                        }
                    }
                }
                //Castle
                for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                {
                    if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                    {
                        for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreCastle(Order, i, j);
                        }
                    }
                }
                //minster
                for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                {
                    if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                    {
                        for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreMinister(Order, i, j);
                        }
                    }
                }
                //king
                for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                {
                    if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                    {
                        for (int j = 0; j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreKing(Order, i, j);
                        }
                    }
                }
            }
        }
        public void ClearAllTablesHeuristicsAndMoreBrown(int Order)
        {
            Object O = new Object();
            lock (O)
            {          //soldier
                for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                {
                    if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreSoldier(Order, i, j);
                        }
                    }
                }
                //elephant
                for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                {
                    if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                    {
                        for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreElephant(Order, i, j);
                        }
                    }
                }
                //hourse
                for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                {
                    if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                    {
                        for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreHourse(Order, i, j);
                        }
                    }
                }
                //Castle
                for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                {
                    if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                    {
                        for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreCastle(Order, i, j);
                        }
                    }
                }
                //minster
                for (int i = MinisterMidle; MinisterOnTable != null && i < MinisterHigh; i++)
                {
                    if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                    {
                        for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreMinister(Order, i, j);
                        }
                    }
                }
                //king
                for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                {
                    if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                    {
                        for (int j = 0; j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //when is not validity
                            ClearAllTablesHeuristicsAndMoreKing(Order, i, j);
                        }
                    }
                }
            }
        }
        //clear all non nessaraly nodes of current
        public void ClearAllTablesHeuristicsAndMore(int Order)
        {
            Object O = new Object();
            lock (O)
            {
                //gray
                if (Order == 1)
                {
                    ClearAllTablesHeuristicsAndMoreGray(Order);
                }
                else//brown
                {
                    ClearAllTablesHeuristicsAndMoreBrown(Order);


                }
            }
        }
        public void ClearAllTablesHeuristicsAndMoreSoldier(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                if (IsNonValidityAllTablesHeuristicsAndMore(1, Order, i, j))
                {
                    //clear all lists
                    SolderesOnTable[i].SoldierThinking[0].TableListSolder.Clear();
                    SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Clear();
                    SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier.Clear();
                    SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Clear();
                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        public void ClearAllTablesHeuristicsAndMoreElephant(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                if (IsNonValidityAllTablesHeuristicsAndMore(2, Order, i, j))
                {
                    //clear all lists
                    ElephantOnTable[i].ElefantThinking[0].TableListElefant.Clear();
                    ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Clear();
                    ElephantOnTable[i].ElefantThinking[0].RowColumnElefant.Clear();
                    ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Clear();
                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy = new List<AllDraw>();

                }
            }
        }
        public void ClearAllTablesHeuristicsAndMoreHourse(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                if (IsNonValidityAllTablesHeuristicsAndMore(3, Order, i, j))
                {
                    //clear all lists
                    HoursesOnTable[i].HourseThinking[0].TableListHourse.Clear();
                    HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Clear();
                    HoursesOnTable[i].HourseThinking[0].RowColumnHourse.Clear();
                    HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Clear();
                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        public void ClearAllTablesHeuristicsAndMoreCastle(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                if (IsNonValidityAllTablesHeuristicsAndMore(4, Order, i, j))
                {
                    //clear all lists
                    CastlesOnTable[i].CastleThinking[0].TableListCastle.Clear();
                    CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Clear();
                    CastlesOnTable[i].CastleThinking[0].RowColumnCastle.Clear();
                    CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Clear();
                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        public void ClearAllTablesHeuristicsAndMoreMinister(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                if (IsNonValidityAllTablesHeuristicsAndMore(5, Order, i, j))
                {
                    //clear all lists
                    MinisterOnTable[i].MinisterThinking[0].TableListMinister.Clear();
                    MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Clear();
                    MinisterOnTable[i].MinisterThinking[0].RowColumnMinister.Clear();
                    MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Clear();
                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        public void ClearAllTablesHeuristicsAndMoreKing(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                if (IsNonValidityAllTablesHeuristicsAndMore(6, Order, i, j))
                {
                    //clear all lists
                    KingOnTable[i].KingThinking[0].TableListKing.Clear();
                    KingOnTable[i].KingThinking[0].HeuristicListKing.Clear();
                    KingOnTable[i].KingThinking[0].RowColumnKing.Clear();
                    KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Clear();
                    if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                        KingOnTable[i].KingThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        KingOnTable[i].KingThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        //when there is a colision in lists of current return true and remove extra lists
        bool A_B_C_D_E_ISNonEqual(int a, int b, int c, int d, int e, int i, int j, int Kind)
        {
            bool Is = false;
            //when deeper is grater and is not empty
            if (e > a && e != -1)
            {
                //soldier
                if (Kind == 1)
                {
                    //remove extra
                    for (int h = a; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; h++)
                    {
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//elephant
                    if (Kind == 2)
                {
                    //remove extra
                    for (int h = a; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; h++)
                    {
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//hourse
                    if (Kind == 3)
                {
                    //remove extra
                    for (int h = a; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; h++)
                    {
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//Castle
                    if (Kind == 4)
                {
                    //remove extra
                    for (int h = a; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; h++)
                    {
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//minster
                    if (Kind == 5)
                {
                    //remove extra
                    for (int h = a; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; h++)
                    {
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//king
                    if (Kind == 6)
                {
                    //remove extra
                    for (int h = a; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count; h++)
                    {
                        KingOnTable[i].KingThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
            }
            //when therse is collision in lists number return true
            if ((!(a == b && b == c && c == d)) || j > e || a == 0 || e == 0 || e == -1)
                Is = true;
            //when there is not
            if (!Is)
            {
                //soldier
                if (Kind == 1)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList[0], SolderesOnTable[i].SoldierThinking[0].TableListSolder[j])))
                        Is = true;
                }
                else//elephant
                                    if (Kind == 2)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList[0], ElephantOnTable[i].ElefantThinking[0].TableListElefant[j])))
                        Is = true;

                }
                else//hourse
                                    if (Kind == 3)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList[0], HoursesOnTable[i].HourseThinking[0].TableListHourse[j])))
                        Is = true;
                }
                else//Castle
                                    if (Kind == 4)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList[0], CastlesOnTable[i].CastleThinking[0].TableListCastle[j])))
                        Is = true;
                }
                else//minster
                                    if (Kind == 5)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList[0], MinisterOnTable[i].MinisterThinking[0].TableListMinister[j])))
                        Is = true;
                }
                else//king
                                    if (Kind == 6)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList[0], KingOnTable[i].KingThinking[0].TableListKing[j])))
                        Is = true;
                }
            }
            return Is;
        }
        //calculation of lists count and call collision methods determinstics
        public bool IsNonValidityAllTablesHeuristicsAndMore(int Kind, int Order, int i, int j)
        {
            bool Is = true;
            //soldier
            if (Kind == 1)
            {
                //when there is
                if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count;
                    int b = SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Count;
                    int c = SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier.Count;
                    int d = SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Count;
                    int e = 0;
                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count;


                    Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 1);
                }

            }

            else if (Kind == 2)
            {

                //when there is
                if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count;
                    int b = ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Count;
                    int c = ElephantOnTable[i].ElefantThinking[0].RowColumnElefant.Count;
                    int d = ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Count;
                    int e = 0;
                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count;

                    Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 2);
                }

            }
            else if (Kind == 3)
            {

                //when there is
                if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = HoursesOnTable[i].HourseThinking[0].TableListHourse.Count;
                    int b = HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Count;
                    int c = HoursesOnTable[i].HourseThinking[0].RowColumnHourse.Count;
                    int d = HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Count;
                    int e = 0;
                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count;

                    Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 3);
                }

            }
            else if (Kind == 4)
            {

                //when there is
                if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = CastlesOnTable[i].CastleThinking[0].TableListCastle.Count;
                    int b = CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Count;
                    int c = CastlesOnTable[i].CastleThinking[0].RowColumnCastle.Count;
                    int d = CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Count;
                    int e = 0;
                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count;
                    //if (a == b && b == c && d == c && a > 0)
                    Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 4);
                }

            }
            else if (Kind == 5)
            {

                //when there is
                if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count;
                    int b = MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Count;
                    int c = MinisterOnTable[i].MinisterThinking[0].RowColumnMinister.Count;
                    int d = MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Count;
                    int e = 0;
                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count;

                    Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 5);
                }

            }
            else if (Kind == 6)
            {

                //when there is
                if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = KingOnTable[i].KingThinking[0].TableListKing.Count;
                    int b = KingOnTable[i].KingThinking[0].HeuristicListKing.Count;
                    int c = KingOnTable[i].KingThinking[0].RowColumnKing.Count;
                    int d = KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Count;
                    int e = 0;
                    if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = KingOnTable[i].KingThinking[0].AStarGreedy.Count;

                    Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 6);
                }

            }

            return (Is);

        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeSolderIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (IsSupHuTrue(i, j, 0, 1))
                return false;
            //when is null creation enough but empty and create deeper node 
            if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 1);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Add(CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]));
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count < j)
            {
                for (int h = SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 1);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Add(CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]));
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                {
                    /*if (!SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(1, Order))
                    {
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Add(CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]));
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = this;
                    }*/
                    THIS = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeSoldeir(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                {
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 1))
                            continue;
                        if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                        {
                            FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            else
            {
                for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                {
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 1))
                            continue;
                        if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                        {
                            FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }

            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeElephantIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (IsSupHuTrue(i, j, 0, 2))
                return false;
            //when is null creation enough but empty and create deeper node 
            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 2);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Add(CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]));
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count < j)
            {
                for (int h = ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 2);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Add(CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]));
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                {
                    /*if (!ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(2, Order))
                    {
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Add(CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]));
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = this;
                    }*/
                    THIS = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeElephant(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                {
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 2))
                            continue;

                        if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                        {

                            FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;
                        }

                    }
                }
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
            {
                for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                {
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 2))
                            continue;
                        if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                        {
                            FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);

                            if (Found)
                                return Found;
                        }

                    }
                }

            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeHourseIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (IsSupHuTrue(i, j, 0, 3))
                return false;
            //when is null creation enough but empty and create deeper node 
            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 3);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Add(CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]));
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                   if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count < j)
            {
                for (int h = HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 3);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Add(CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]));
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                {
                    /* if (!HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(3, Order))
                     {
                         HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                         HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Add(CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]));
                         HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                         HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].AStarGreedyString = this;
                     }*/

                    THIS = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeHourse(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; HoursesOnTable != null && i < ElefantMidle; i++)
                {
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 3))
                            continue;
                        if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                        {
                            FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }
            }
            else
            {
                for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                {
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 3))
                            continue;
                        if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                        {
                            FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }

            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeCastleIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (IsSupHuTrue(i, j, 0, 4))
                return false;
            //when is null creation enough but empty and create deeper node 
            if (CastlesOnTable[i].CastleThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 4);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]));
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                      if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count < j)
            {
                for (int h = CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 4);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]));
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                {
                    /*if (!CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(4, Order))
                    {
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]));
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].AStarGreedyString = this;
                    }*/
                    THIS = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];

                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeCastle(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                {
                    for (int j = 0; CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 4))
                            continue;
                        if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                        {

                            FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;
                        }

                    }
                }
            }
            else
            {
                for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                {
                    for (int j = 0; CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 4))
                            continue;
                        if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                        {
                            FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }

            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeMinisterIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (IsSupHuTrue(i, j, 0, 5))
                return false;
            //when is null creation enough but empty and create deeper node 
            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 5);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Add(CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]));
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count < j)
            {
                for (int h = MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 5);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Add(CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]));
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                {
                    /*if (!MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(5, Order))
                    {
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Add(CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]));
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = this;
                    }*/
                    THIS = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeMinister(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                {
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 5))
                            continue;
                        if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                        {
                            FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }
            }
            else
            {
                for (int i = MinisterMidle; MinisterOnTable != null && i < MinisterHigh; i++)
                {
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 5))
                            continue;
                        if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                        {
                            FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);

                        }

                    }
                }

            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeKingIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (IsSupHuTrue(i, j, 0, 6))
                return false;
            //when is null creation enough but empty and create deeper node 
            if (KingOnTable[i].KingThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 6);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Clear();
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]));
                KingOnTable[i].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count < j)
            {
                for (int h = KingOnTable[i].KingThinking[0].AStarGreedy.Count; h <= j; h++)
                    //satisfied of created deeper three
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 6);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Clear();
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]));
                KingOnTable[i].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                {
                    /*if (!KingOnTable[i].KingThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(6, Order))
                    {
                        KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Clear();
                        KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]));
                        KingOnTable[i].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                        KingOnTable[i].KingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                    }*/
                    THIS = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeKing(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                {
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 6))
                            continue;
                        if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                        {
                            FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }
            }
            else
            {
                for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                {
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > j; j++)
                    {
                        if (IsSupHuTrue(i, j, 0, 6))
                            continue;
                        if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                        {
                            FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }

            }
            return Found;
        }
        public AllDraw FoundOfLeafDepenOfKindSoldier(int i, ref AllDraw Leaf, ref bool Found, int Order, ref int OrderLeaf, int ik, int jk, int iii, int jjj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;


                for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                {

                    if (IsSupHuTrue(i, j, 0, 1))
                        continue;
                    //when leaf found set refer bool and alldraw refer objects
                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count <= SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count// && Kind == 1
                    )
                    {
                        Found = true;
                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                        //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        Color aa = Color.Gray;
                        if (Order * -1 == -1)
                            aa = Color.Brown;
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(MaxAStarGreedy, 0, 0, aa, CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]), Order * -1, false, false, 0);
                        Leaf = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1];
                        return Leaf;
                    }
                    else//deeper
                        for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1; ii++)
                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, ref OrderLeaf, ik, jk, iii, jjj);


                }

                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindElephant(int i, ref AllDraw Leaf, ref bool Found, int Order, ref int OrderLeaf, int ik, int jk, int iii, int jjj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;



                for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 2))
                        continue;

                    //when leaf found set refer bool and alldraw refer objects
                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count <= ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count //&& Kind == 2
                    )
                    {
                        Found = true;
                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                        //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        Color aa = Color.Gray;
                        if (Order * -1 == -1)
                            aa = Color.Brown;
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(MaxAStarGreedy, 0, 0, aa, CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]), Order * -1, false, false, 0);
                        Leaf = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1];
                        return Leaf;
                    }
                    else//deeper
                        for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ii++)
                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, ref OrderLeaf, ik, jk, iii, jjj);



                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindHourse(int i, ref AllDraw Leaf, ref bool Found, int Order, ref int OrderLeaf, int ik, int jk, int iii, int jjj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;

                for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 3))
                        continue;

                    //when leaf found set refer bool and alldraw refer objects
                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count <= HoursesOnTable[i].HourseThinking[0].TableListHourse.Count //&& Kind == 3
                    )
                    {
                        Found = true;
                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                        //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        Color aa = Color.Gray;
                        if (Order * -1 == -1)
                            aa = Color.Brown;
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(MaxAStarGreedy, 0, 0, aa, CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]), Order * -1, false, false, 0);
                        Leaf = HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1];
                        return Leaf;
                    }
                    else//deeper
                        for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1; ii++)
                            HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, ref OrderLeaf, ik, jk, iii, jjj);


                }



                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindCastle(int i, ref AllDraw Leaf, ref bool Found, int Order, ref int OrderLeaf, int ik, int jk, int iii, int jjj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;

                for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 4))
                        continue;


                    //when leaf found set refer bool and alldraw refer objects
                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count <= CastlesOnTable[i].CastleThinking[0].TableListCastle.Count //&& Kind == 4
                    )
                    {
                        Found = true;
                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                        //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        Color aa = Color.Gray;
                        if (Order * -1 == -1)
                            aa = Color.Brown;
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(MaxAStarGreedy, 0, 0, aa, CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]), Order * -1, false, false, 0);
                        Leaf = CastlesOnTable[i].CastleThinking[0].AStarGreedy[CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count - 1];
                        return Leaf;
                    }
                    else//deeper
                        for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count - 1; ii++)
                            CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, ref OrderLeaf, ik, jk, iii, jjj);

                }

                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindMinister(int i, ref AllDraw Leaf, ref bool Found, int Order, ref int OrderLeaf, int ik, int jk, int iii, int jjj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;

                for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 5))
                        continue;

                    //when leaf found set refer bool and alldraw refer objects
                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count <= MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count //&& Kind == 5
                    )
                    {
                        Found = true;
                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                        //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        Color aa = Color.Gray;
                        if (Order * -1 == -1)
                            aa = Color.Brown;
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(MaxAStarGreedy, 0, 0, aa, CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]), Order * -1, false, false, 0);
                        Leaf = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1];
                        return Leaf;
                    }
                    else//deeper
                        for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1; ii++)
                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, ref OrderLeaf, ik, jk, iii, jjj);



                }


                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindKing(int i, ref AllDraw Leaf, ref bool Found, int Order, ref int OrderLeaf, int ik, int jk, int iii, int jjj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;

                for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 6))
                        continue;
                    //when leaf found set refer bool and alldraw refer objects
                    if (KingOnTable[i].KingThinking[0].AStarGreedy.Count <= KingOnTable[i].KingThinking[0].TableListKing.Count //&& Kind == 6
                    )
                    {
                        Found = true;
                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                        //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        Color aa = Color.Gray;
                        if (Order * -1 == -1)
                            aa = Color.Brown;
                        KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(MaxAStarGreedy, 0, 0, aa, CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]), Order * -1, false, false, 0);
                        Leaf = KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1];
                        return Leaf;
                    }
                    else//deeper
                        for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1; ii++)
                            KingOnTable[i].KingThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, ref OrderLeaf, ik, jk, iii, jjj);



                }

                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Leaf;
            }
        }
        //found of leadfs of created tree depend of orderic 
        public AllDraw FoundOfLeafDepenOfKind(ref AllDraw Leaf, ref bool Found, int Order, ref int OrderLeaf, int ik, int jk, int iii, int jjj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;
                //gray
                if (Order == 1)
                {

                    for (var i = 0; i < SodierMidle; i++)
                    {
                        FoundOfLeafDepenOfKindSoldier(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                    if (Found)
                        return Leaf;
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        FoundOfLeafDepenOfKindElephant(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                    if (Found)
                        return Leaf;
                    for (var i = 0; i < HourseMidle; i++)
                    {
                        FoundOfLeafDepenOfKindHourse(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);

                    }

                    if (Found)
                        return Leaf;
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        FoundOfLeafDepenOfKindCastle(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                    if (Found)
                        return Leaf;
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        FoundOfLeafDepenOfKindMinister(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                    if (Found)
                        return Leaf;
                    for (var i = 0; i < KingMidle; i++)
                    {
                        FoundOfLeafDepenOfKindKing(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                }
                else
                {
                    if (Found)
                        return Leaf;
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        FoundOfLeafDepenOfKindSoldier(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                    if (Found)
                        return Leaf;
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        FoundOfLeafDepenOfKindElephant(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                    if (Found)
                        return Leaf;
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        FoundOfLeafDepenOfKindHourse(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                    if (Found)
                        return Leaf;
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        FoundOfLeafDepenOfKindCastle(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                    if (Found)
                        return Leaf;
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        FoundOfLeafDepenOfKindMinister(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }

                    if (Found)
                        return Leaf;
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        FoundOfLeafDepenOfKindKing(i, ref Leaf, ref Found, Order, ref OrderLeaf, ik, jk, iii, jjj);
                    }
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Leaf;
            }
        }
        //when leafs is vivtory target nodes return true found and set refrence
        public bool IsFoundOfLeafDepenOfKindhaveVictory(int Kind, ref bool Found, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                //when found return recurve
                if (Found)
                    return true;
                //gray
                if (Order == 1)
                {
                    //soldier
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            //when is victory
                            if (SolderesOnTable[i].SoldierThinking[0].IsThereMateOfEnemy// && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 
                                && Kind == 1)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);


                        }
                    //elephant
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //when is victory
                            if (ElephantOnTable[i].ElefantThinking[0].IsThereMateOfEnemy //&& ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 
                        && Kind == 2)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);



                        }
                    //hourse
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //when is victory
                            if (HoursesOnTable[i].HourseThinking[0].IsThereMateOfEnemy //&& HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 
&& Kind == 3)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);




                        }
                    //Castle
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //when is victory
                            if (CastlesOnTable[i].CastleThinking[0].IsThereMateOfEnemy //&& CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0 
                                && Kind == 4)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);


                        }
                    //minister
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //when is victory
                            if (MinisterOnTable[i].MinisterThinking[0].IsThereMateOfEnemy //&& MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0 
                                && Kind == 5)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);



                        }
                    //king
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //when is victory
                            if (KingOnTable[i].KingThinking[0].IsThereMateOfEnemy //&& KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 
                                && Kind == 6)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);



                        }
                }
                else//brown
                {
                    //soldier
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            //when is victory
                            if (SolderesOnTable[i].SoldierThinking[0].IsThereMateOfEnemy //&& SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 
                                && Kind == 1)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);

                        }
                    //elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            //when is victory
                            if (ElephantOnTable[i].ElefantThinking[0].IsThereMateOfEnemy //&& ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 
                                && Kind == 2)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);

                        }
                    //hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            //when is victory
                            if (HoursesOnTable[i].HourseThinking[0].IsThereMateOfEnemy //&& HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 
                                && Kind == 3)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);

                        }
                    //Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            //when is victory
                            if (CastlesOnTable[i].CastleThinking[0].IsThereMateOfEnemy //&& CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0 
                                && Kind == 4)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);


                        }
                    //minister
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //when is victory
                            if (MinisterOnTable[i].MinisterThinking[0].IsThereMateOfEnemy //&& MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0
                                && Kind == 5)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);


                        }
                    //king
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //when is victory
                            if (KingOnTable[i].KingThinking[0].IsThereMateOfEnemy //&& KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 
                                && Kind == 6)
                            {
                                Found = true;
                                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;

                            }
                            else//deeper
                                for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);



                        }
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Found;
            }
        }
        //Retrun determined consideration of lists of Thinking chess class list collisions.
        //1 for Astar non empty and not contained computation; 2 for AstasrEmpty and not contaied computations;
        //3 for empty and contained compuatations
        //4 a star is not emplty and contaied computation
        int IsSuitableForInitiation(int i, int j, int Kind)
        {
            int Is = 0;
            //determine deeper have right contained
            bool a = IsNotAStarGreedyConanaied(i, j, Kind);
            //determined deeper contained have computatinal list correctly.
            bool b = IsNotComputationsConanaiedAStarGreedy(i, j, Kind);
            //when true
            if (a)
            {
                //when true
                if (b) Is = 2;

                else//when false
                    Is = 3;

            }
            else//when false
            {
                //when true
                if (b)
                    Is = 1;

                else//when false
                    Is = 4;

            }
            //when is 2 consider determinstic results about contanied
            if (Is == 2)
                IsThereCalculatedAStarGreedyNode(i, Kind);
            return Is;
        }
        //when current side of alldraw is not contained and semi computated 
        bool IsNotAStarGreedyConanaied(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            int d = 0;
            //Soldier
            if (Kind == 1)
            {
                //determine nodes is coorectly existence
                if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                {
                    //deeper count
                    e = SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList[0], SolderesOnTable[i].SoldierThinking[0].TableListSolder[j])))
                        Is = true;

                }
            }
            else if (Kind == 2)
            {

                //determine nodes is coorectly existence
                if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                {
                    //deeper count
                    e = ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList[0], ElephantOnTable[i].ElefantThinking[0].TableListElefant[j])))
                        Is = true;
                }
            }
            else if (Kind == 3)
            {

                //determine nodes is coorectly existence
                if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                {
                    //deeper count
                    e = HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList[0], HoursesOnTable[i].HourseThinking[0].TableListHourse[j])))
                        Is = true;
                }
            }
            else if (Kind == 4)
            {

                //determine nodes is coorectly existence
                if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                {
                    //deeper count
                    e = CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList[0], CastlesOnTable[i].CastleThinking[0].TableListCastle[j])))
                        Is = true;
                }
            }
            else if (Kind == 5)
            {
                //determine nodes is coorectly existence
                if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                {
                    //deeper count
                    e = MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList[0], MinisterOnTable[i].MinisterThinking[0].TableListMinister[j])))
                        Is = true;
                }
            }
            else if (Kind == 6)
            {
                //determine nodes is coorectly existence
                if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                {
                    //deeper count
                    e = KingOnTable[i].KingThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList[0], KingOnTable[i].KingThinking[0].TableListKing[j])))
                        Is = true;
                }
            }
            //when deeper not exist return true
            if (e == 0)
                Is = true;
            //when current alldraw tablelist not exist return true
            if (d == 0)
                Is = true;
            return Is;


        }
        public bool IsAtLeastAllObjectIsNull()
        {
            bool Is = false;
            //Soldier

            if (SolderesOnTable == null)
                Is = true;
            if (ElephantOnTable == null)
                Is = true;
            if (HoursesOnTable == null)
                Is = true;
            if (CastlesOnTable == null)
                Is = true;
            if (MinisterOnTable == null)
                Is = true;
            if (KingOnTable == null)
                Is = true;

            return Is;


        }
        //When there is computatinoal deeper and there is colosion in lists return true otherwise return false
        bool IsNotComputationsConanaiedAStarGreedy(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            //soldier
            if (Kind == 1)
            {
                if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                {
                    //lists count
                    int a = SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count;
                    e = SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        if (!ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList[0], SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]))
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; h++)
                            {
                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy.RemoveAt(h);
                                //e--;
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 2)//elephant
            {
                if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                {
                    //lists count
                    int a = ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count;
                    e = ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        if (!ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList[0], ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]))
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; h++)
                            {
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy.RemoveAt(h);

                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 3)//hourse
            {
                if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                {
                    //lists count
                    int a = HoursesOnTable[i].HourseThinking[0].TableListHourse.Count;
                    e = HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        if (!ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList[0], HoursesOnTable[i].HourseThinking[0].TableListHourse[j]))
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; h++)
                            {
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy.RemoveAt(h);
                            }

                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 4)//Castle
            {

                if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                {
                    //lists count
                    int a = CastlesOnTable[i].CastleThinking[0].TableListCastle.Count;
                    e = CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        if (!ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList[0], CastlesOnTable[i].CastleThinking[0].TableListCastle[j]))
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; h++)
                            {
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy.RemoveAt(h);

                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 5)//minister
            {

                if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                {
                    //lists count
                    int a = MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count;
                    e = MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        if (!ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList[0], MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]))
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; h++)
                            {
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy.RemoveAt(h);

                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 6)//king
            {
                if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                {
                    //lists count
                    int a = KingOnTable[i].KingThinking[0].TableListKing.Count;
                    e = KingOnTable[i].KingThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList != null && KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        if (!ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList[0], KingOnTable[i].KingThinking[0].TableListKing[j]))
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count; h++)
                            {
                                KingOnTable[i].KingThinking[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            //when deeper count is less than index deeper return true
            if (e < j)
                Is = true;

            return Is;


        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameSoldeir(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null //&& SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null
                         ; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(i, j, 0, 1))
                            continue;
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return;

                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = IsNonValidityAllTablesHeuristicsAndMore(1, Order, i, j);

                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = IsSuitableForInitiation(i, j, 1);

                    if (!IA)
                        Is = 4;
                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {
                            //when search finished stop and return
                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                return;

                        }
                        FullGameFound = true;
                        ////OutPut.Append("\r\nLeaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());
                        //ClearAllTablesHeuristicsAndMore(Order);

                        InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess
                        for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                        {
                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order);
                        }

                        for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                            SolderesOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order);

                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].TableList != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;


                                    //when search finished stop and return
                                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                        return;

                                }
                                ////OutPut.Append("\r\nAStarGreedy traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                                //ThinkingChess.NumbersOfAllNode++;
                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].TableList[0], Order * -1, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }
                            for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                                SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order);
                            for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                                SolderesOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order);

                        }
                        else if (Is == 3)//when deeper is suitable and  computational not
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            ////OutPut.Append("\r\nFull Game traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                            Object O1 = new Object();
                            lock (O1)
                            {
                                int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;

                                //ClearAllTablesHeuristicsAndMore(Order);

                                InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess

                                for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                                {
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order);
                                }
                                for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                                    SolderesOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order);
                            }

                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                FullGameFound = true;

                                //iAStarGreedy++;
                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;


                                Object OOO = new Object();
                                lock (OOO)
                                {
                                    FirstTraversalTree = false;

                                    //SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Clear();
                                    //when search finished stop and return
                                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                        return;

                                }
                                ////OutPut.Append("\r\nAStarGreedy traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                                //ThinkingChess.NumbersOfAllNode++;
                                this.FullGameThinkingTree(Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);

                                //Initiate(ii, jj, a, CloneATable(Table), Order, false, false,LeafAStarGreedy);
                            }

                        }
                    }
                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameElepahnt(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null //&& ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null
            ; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        if (IsSupHuTrue(i, j, 0, 2))
                            continue;
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return;


                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = IsNonValidityAllTablesHeuristicsAndMore(2, Order, i, j);

                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = IsSuitableForInitiation(i, j, 2);

                    if (!IA)
                        Is = 4;


                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {

                            //when search finished stop and return
                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                return;

                        }
                        FullGameFound = true;
                        ////OutPut.Append("\r\nLeaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());
                        //ClearAllTablesHeuristicsAndMore(Order);

                        InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess
                        for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                        {
                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order);
                        }
                        for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                            ElephantOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].TableList != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;

                                    //when search finished stop and return
                                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                        return;

                                }
                                ////OutPut.Append("\r\nAStarGreedy traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                                //ThinkingChess.NumbersOfAllNode++;
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].TableList[0], Order * -1, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }

                            for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                                ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order);
                            for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                                ElephantOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order);

                        }
                        else if (Is == 3)//when is suitable for deeper
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            ////OutPut.Append("\r\nFull Game traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                            Object O1 = new Object();
                            lock (O1)
                            {
                                int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                //ClearAllTablesHeuristicsAndMore(Order);

                                InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess

                                for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                                {
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order);
                                }

                                for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                                    ElephantOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order);
                            }

                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                //iAStarGreedy++;
                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;
                                //ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Clear();
                                this.FullGameThinkingTree(Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                //Initiate(ii, jj, a, CloneATable(Table), Order, false, false,LeafAStarGreedy);
                            }

                        }
                    }

                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameHourse(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count && HoursesOnTable[i].HourseThinking[0].TableListHourse != null //&& HoursesOnTable[i].HourseThinking[0].AStarGreedy != null
           ; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(i, j, 0, 3))
                            continue;

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return;

                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = IsNonValidityAllTablesHeuristicsAndMore(3, Order, i, j);

                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = IsSuitableForInitiation(i, j, 3);

                    if (!IA)
                        Is = 4;


                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {

                            //when search finished stop and return
                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                return;

                        }
                        FullGameFound = true;
                        ////OutPut.Append("\r\nLeaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());
                        //ClearAllTablesHeuristicsAndMore(Order);

                        InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess
                        for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                        {
                            HoursesOnTable[i].HourseThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order);
                        }

                        for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                            HoursesOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].TableList != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;

                                    //when search finished stop and return
                                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                        return;

                                }
                                ////OutPut.Append("\r\nAStarGreedy traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                                //ThinkingChess.NumbersOfAllNode++;
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].TableList[0], Order * -1, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }

                            for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                                HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order);
                            for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                                HoursesOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order);

                        }
                        else if (Is == 3)//when is suitable for deeper
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            ////OutPut.Append("\r\nFull Game traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                            Object O1 = new Object();
                            lock (O1)
                            {

                                //ClearAllTablesHeuristicsAndMore(Order);

                                InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess

                                for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                                {
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order);
                                }
                                for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                                    HoursesOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order);
                            }

                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }

                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                int Ord = Order, iAStarGreedy1 = 0, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;
                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy.Clear();
                                this.FullGameThinkingTree(Ord, iAStarGreedy1, ii1, jj1, i1, j1, false, LeafAStarGreedy);
                                //Initiate(ii, jj, a, CloneATable(Table), Order, false, false,LeafAStarGreedy);
                            }

                        }
                    }




                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameCastle(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count //&& CastlesOnTable[i].CastleThinking[0].TableListCastle != null
                                  ; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 4))
                        continue;
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return;

                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = IsNonValidityAllTablesHeuristicsAndMore(4, Order, i, j);


                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = IsSuitableForInitiation(i, j, 4);

                    if (!IA)
                        Is = 4;

                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {

                            //when search finished stop and return
                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                return;

                        }
                        FullGameFound = true;
                        ////OutPut.Append("\r\nLeaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());
                        //ClearAllTablesHeuristicsAndMore(Order);

                        InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess
                        for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                        {
                            CastlesOnTable[i].CastleThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order);
                        }

                        for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                            CastlesOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order);
                    }
                    else
                    {
                        //when is suitable for deeper

                        if (Is == 2)
                        {
                            for (var iii = 0; iii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].TableList != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;

                                    //when search finished stop and return
                                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                        return;

                                }
                                ////OutPut.Append("\r\nAStarGreedy traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                                //ThinkingChess.NumbersOfAllNode++;
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].TableList[0], Order * -1, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].AStarGreedyString = this;

                            }

                            for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                                CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order);
                            for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                                CastlesOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order);

                        }
                        else if (Is == 3)  //when is suitable for leafer 
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            ////OutPut.Append("\r\nFull Game traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                            Object O1 = new Object();
                            lock (O1)
                            {
                                //ClearAllTablesHeuristicsAndMore(Order);

                                InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess

                                for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                                {
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order);
                                }
                                for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                                    CastlesOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order);
                            }

                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                FullGameFound = true;

                                //iAStarGreedy++;
                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;
                                int Ord = Order, iAStarGreedy1 = 0, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                //CastlesOnTable[i].CastleThinking[0].AStarGreedy.Clear();

                                this.FullGameThinkingTree(Ord, iAStarGreedy1, ii1, jj1, i1, j1, false, LeafAStarGreedy);
                                //Initiate(ii, jj, a, CloneATable(Table), Order, false, false,LeafAStarGreedy);
                            }

                        }
                    }


                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameMinister(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null //&& MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null
                  ; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 5))
                        continue;
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return;

                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = IsNonValidityAllTablesHeuristicsAndMore(5, Order, i, j);


                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = IsSuitableForInitiation(i, j, 5);

                    if (!IA)
                        Is = 4;

                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {

                            //when search finished stop and return
                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                return;

                        }
                        FullGameFound = true;
                        ////OutPut.Append("\r\nLeaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());
                        //ClearAllTablesHeuristicsAndMore(Order);

                        InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess
                        for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                        {
                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order);
                        }
                        for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                            MinisterOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].TableList != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;

                                    //when search finished stop and return
                                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                        return;

                                }
                                ////OutPut.Append("\r\nAStarGreedy traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                                //ThinkingChess.NumbersOfAllNode++;
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].TableList[0], Order * -1, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].AStarGreedyString = this;

                            }

                            for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                                MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order);
                            for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                                MinisterOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order);

                        }
                        else if (Is == 3)//when is suitable for deeper
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            ////OutPut.Append("\r\nFull Game traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                            //ClearAllTablesHeuristicsAndMore(Order);

                            InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess

                            for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                            {
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order);
                            }

                            for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                                MinisterOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order);


                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                FullGameFound = true;

                                //iAStarGreedy++;
                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;
                                //MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Clear();
                                this.FullGameThinkingTree(Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                //Initiate(ii, jj, a, CloneATable(Table), Order, false, false,LeafAStarGreedy);
                            }

                        }
                    }
                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameKing(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count && KingOnTable[i].KingThinking[0].TableListKing != null //&& KingOnTable[i].KingThinking[0].AStarGreedy != null
           ; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        if (IsSupHuTrue(i, j, 0, 6))
                            continue;
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return;

                    }

                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = IsNonValidityAllTablesHeuristicsAndMore(6, Order, i, j);


                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = IsSuitableForInitiation(i, j, 6);


                    if (!IA)
                        Is = 4;

                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {

                            //when search finished stop and return
                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                return;

                        }
                        FullGameFound = true;
                        ////OutPut.Append("\r\nLeaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());
                        //ClearAllTablesHeuristicsAndMore(Order);

                        InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess
                        for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                        {
                            KingOnTable[i].KingThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order);
                        }
                        for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                            KingOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy[iii].TableList != null && KingOnTable[i].KingThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;


                                    //when search finished stop and return
                                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                        return;

                                }
                                ////OutPut.Append("\r\nAStarGreedy traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                                //ThinkingChess.NumbersOfAllNode++;
                                KingOnTable[i].KingThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(KingOnTable[i].KingThinking[0].AStarGreedy[iii].TableList[0], Order * -1, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                KingOnTable[i].KingThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }

                            for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                                KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order);
                            for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                                KingOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order);


                        }
                        else if (Is == 3)//when is suitable for deeper
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }
                            ////OutPut.Append("\r\nFull Game traversal to Leaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());

                            Object O1 = new Object();
                            lock (O1)
                            {
                                int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;

                                //ClearAllTablesHeuristicsAndMore(Order);

                                InitiateAStarGreedyt(AllDraw.MaxAStarGreedy - LeafAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess

                                for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                                {
                                    KingOnTable[i].KingThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order);
                                }
                                for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                                    KingOnTable[i].LoseOcuuredatChiled += SumMinusOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order);
                            }

                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {

                                //when search finished stop and return
                                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                    return;

                            }

                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                //iAStarGreedy++;
                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;
                                //KingOnTable[i].KingThinking[0].AStarGreedy.Clear();
                                this.FullGameThinkingTree(Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                //Initiate(ii, jj, a, CloneATable(Table), Order, false, false,LeafAStarGreedy);
                            }

                        }
                    }

                }
            }
        }
        public void FoundOfLeafDepenOfKindFullGame(int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {
                Object Omm = new Object();
                lock (Omm)
                {
                    if (LeafAStarGreedy >= MaxAStarGreedy)
                        return;
                    Object OOOO = new Object();
                    lock (OOOO)
                    {

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return;

                    }
                }
                bool FullGameFound = false;
                Object O = new Object();
                lock (O)
                {
                    //gray
                    if (Order == 1)
                    {
                        //parallel full game all deeper foundation
                        Color a = Color.Gray;
                        var output = Task.Factory.StartNew(() =>
                        {
                            //if (!feedCancellationTokenSource.IsCancellationRequested)
                            {
                                Parallel.Invoke(() =>
                                {
                                    //soldier
                                    for (var i = 0; i < SodierMidle; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {
                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameSoldeir(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //elephant
                                    for (var i = 0; i < ElefantMidle; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameElepahnt(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //hourse
                                    for (var i = 0; i < HourseMidle; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameHourse(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //Castle
                                    for (var i = 0; i < CastleMidle; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameCastle(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //minister
                                    for (var i = 0; i < MinisterMidle; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameMinister(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //king
                                    for (var i = 0; i < KingMidle; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameKing(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                });
                            }
                        });
                        output.Wait(); output.Dispose();


                    }
                    else//brown
                    {
                        Color a = Color.Brown;
                        var output = Task.Factory.StartNew(() =>
                        {
                            //if (!feedCancellationTokenSource.IsCancellationRequested)
                            {
                                Parallel.Invoke(() =>
                                {
                                    //soldier
                                    for (var i = SodierMidle; i < SodierHigh; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameSoldeir(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //elephant
                                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameElepahnt(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //hourse
                                    for (var i = HourseMidle; i < HourseHight; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameHourse(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //Castle
                                    for (var i = CastleMidle; i < CastleHigh; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameCastle(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //minister
                                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameMinister(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                }, () =>
                                {
                                    //king
                                    for (var i = KingMidle; i < KingHigh; i++)
                                    {
                                        Object OOOO = new Object();
                                        lock (OOOO)
                                        {

                                            //when search finished stop and return
                                            if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                                return;

                                        }
                                        Object P = new Object();
                                        lock (P)
                                        {
                                            FoundOfLeafDepenOfKindFullGameKing(a, ref FullGameFound, Table, Order, iAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                        }
                                    }
                                });
                            }
                        });
                        output.Wait(); output.Dispose();
                    }
                }
                //when not occured untile now computational op
                if (!FullGameFound)
                {
                    Object O1 = new Object();
                    lock (O1)
                    {
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return;

                        //iAStarGreedy++;
                        Color a = Color.Gray;
                        if (Order == -1)
                            a = Color.Brown;
                        InitiateAStarGreedyt(AllDraw.MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref double LessLess
                                                                                                                                          //Initiate(ii, jj, a, CloneATable(Table), Order, false, false,LeafAStarGreedy);
                    }
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfLeafDepenOfKindFullGame:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return;
            }
        }
        //for regard all branches of leaf victory node
        public void MakeRegardAllCheckMateBranches(AllDraw A, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                int COrder = Order;
                int CDummy = ChessRules.CurrentOrder;

                //gray
                if (Order == 1)
                {
                    //soldier
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            //make regard
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);


                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //elephant
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            //make regard
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard();


                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //hourse
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            //make regard
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard();


                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //Castle
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            //make regard
                            A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard();

                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //minister
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            //make regard
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard();


                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //king
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            //make regard
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();

                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
                else//brown
                {
                    //soldier
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            //make regard
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard();

                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            //make regard
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard();


                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            //make regard
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard();


                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            //make regard
                            A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard();

                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //minister
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            //make regard
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard();

                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //king
                    for (var i = KingMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            //make regard
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();

                            Order *= -1; ChessRules.CurrentOrder *= -1;

                            //deeper call
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("MakeRegardAllCheckMateBranches:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //when all branches of root is lose and close ignore of learning autamata option  
        int[,] HeuristicAStarGreadySearchPenalties(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                ChessRules AB = null;

                int ToCheckMate = -1, ForCheckMate = -1, j, i;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                int[,] TableHeuristic = new int[8, 8];
                //For Every Soldeir
                for (i = 0; i < SodierMidle; i++)
                {


                    //For Every Soldier Movments AStarGreedy.
                    for (int k = 0; k < AllDraw.SodierMovments; k++)
                        //When There is an Movment in such situation.

                        for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[k] != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                        {
                            {

                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;

                                ChessRules.CurrentOrder *= -1;
                                Order *= -1;
                                Do = 0;
                                if (UsePenaltyRegardMechnisamT)
                                {
                                    for (int ij = 0; ij < SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count - 1; ij++)
                                        SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]);
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;

                                    ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                        continue;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;

                                if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3)
                                {
                                    //Set Table and Heuristic Value and Syntax.
                                    Act = true;
                                    Object On = new Object();
                                    lock (On)
                                    {

                                        AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                        AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                        AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                        AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];


                                        Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;
                                    }


                                    TableHeuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];


                                    Object O = new Object();
                                    lock (O)
                                    {
                                        ThingsConverter.ActOfClickEqualTow = true;
                                    }
                                    SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                    int Sign = 1;
                                    if (a == Color.Brown)
                                        Sign = -1;


                                    //If there is Soldier Convert.
                                    if (SolderesOnTable[i].Convert)
                                    {

                                        if (SolderesOnTable[i].ConvertedToMinister)
                                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                        else if (SolderesOnTable[i].ConvertedToCastle)
                                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                        else if (SolderesOnTable[i].ConvertedToHourse)
                                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                        else if (SolderesOnTable[i].ConvertedToElefant)
                                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;




                                    }
                                    RegardOccurred = true;
                                    continue;
                                }

                                //When There is No Movments in Such Order Enemy continue.
                                Object ol = new Object();
                                lock (ol)
                                {
                                    if (Order != AllDraw.OrderPlate)
                                        if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                            continue;

                                    //When There is greater Heuristic Movments.
                                    if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                    {


                                        //retrive table of current Heuristic.
                                        int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                        int[,] TableSS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                        {

                                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                continue;


                                        }
                                        //When there is not Penalty regard mechanism.

                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        //Sodleirs Initiate.
                                        RW1 = i;
                                        CL1 = k;
                                        Ki1 = j;
                                        RW2 = -1;
                                        CL2 = -1;
                                        Ki2 = -1;
                                        RW3 = -1;
                                        CL3 = -1;
                                        Ki3 = -1;
                                        RW4 = -1;
                                        CL4 = -1;
                                        Ki4 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        RW6 = -1;
                                        CL6 = -1;
                                        Ki6 = -1;
                                        //Set Max of Soldier.
                                        MaxLess1 = (SolderesOnTable[RW1].SoldierThinking[CL1].NumberOfPenalties
                                            );
                                        //When Soldeirs is Greater than Others these Set Max.
                                        if (MaxLess1 > MaxLess2)
                                            MaxLess2 = -1;
                                        if (MaxLess1 > MaxLess3)
                                            MaxLess3 = -1;
                                        if (MaxLess1 > MaxLess4)
                                            MaxLess4 = -1;
                                        if (MaxLess1 > MaxLess5)
                                            MaxLess5 = -1;
                                        if (MaxLess1 > MaxLess6)
                                            MaxLess6 = -1;

                                        if (AStarGreedyi == 1)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                                }
                                            }
                                            //Set Table and Heuristic Value and Syntax.
                                            Act = true;
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                                AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                                AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                            }

                                            Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;


                                            TableHeuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];


                                            Object O1 = new Object();
                                            lock (O1)
                                            {
                                                ThingsConverter.ActOfClickEqualTow = true;
                                            }
                                            SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                            int Sign = 1;
                                            if (a == Color.Brown)
                                                Sign = -1;
                                            //If there is Soldier Convert.
                                            if (SolderesOnTable[i].Convert)
                                            {

                                                if (SolderesOnTable[i].ConvertedToMinister)
                                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToCastle)
                                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToHourse)
                                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToElefant)
                                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;





                                            }
                                        }


                                    }
                                    else
                                    {
                                        //Set Table and Heuristic Value and Syntax.

                                        if (AStarGreedyi == 1)
                                        {

                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            int LessB = Int32.MinValue;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxSoldeirFounded)
                                                continue;
                                            Act = true;
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = SolderesOnTable[RW1].SoldierThinking[CL1].Row;
                                                AllDraw.LastColumn = SolderesOnTable[RW1].SoldierThinking[CL1].Column;
                                                AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                            }
                                            Less = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHeuristic(RW1, Ki1, Order, false, ref HaveKilled);


                                            TableHeuristic = SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1];


                                            Object O1 = new Object();
                                            lock (O1)
                                            {
                                                ThingsConverter.ActOfClickEqualTow = true;
                                            }
                                            SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1], Order, false, i);
                                            int Sign = 1;
                                            if (a == Color.Brown)
                                                Sign = -1;
                                            //If there is Soldier Convert.
                                            if (SolderesOnTable[RW1].Convert)
                                            {

                                                if (SolderesOnTable[RW1].ConvertedToMinister)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToCastle)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;





                                            }
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                                }
                                            }
                                        }

                                    }
                                }


                            }
                        }



                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                }
                //Do For Remaining Objects same as Soldeir Documentation.
                for (i = 0; i < ElefantMidle; i++)
                {
                    for (int k = 0; k < AllDraw.ElefantMovments; k++)

                        for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[k] != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                        {
                            {

                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;

                                ChessRules.CurrentOrder *= -1;
                                Order *= -1;
                                Do = 0;
                                if (UsePenaltyRegardMechnisamT)
                                {
                                    for (int ij = 0; ij < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ij++)
                                        ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij]);
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                        continue;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3)
                                {

                                    Object On = new Object();
                                    lock (On)
                                    {
                                        AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                        AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                        AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                        AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];


                                        Act = true;
                                        Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                    }
                                    TableHeuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                    RegardOccurred = true;
                                    continue;

                                }

                                Object ol = new Object();
                                lock (ol)
                                {
                                    //When There is No Movments in Such Order Enemy continue.
                                    if (Order != AllDraw.OrderPlate)
                                        if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                            continue;
                                    //When There is greater Heuristic Movments.

                                    if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                    {


                                        //retrive table of current Heuristic.
                                        int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                        int[,] TableSS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                        {

                                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                continue;



                                        }
                                        //When there is not Penalty regard mechanism.

                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 2, CloneATable(TableS), Order, -1, -1);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        RW2 = i;
                                        CL2 = k;
                                        Ki2 = j;
                                        RW1 = -1;
                                        CL1 = -1;
                                        Ki1 = -1;
                                        RW3 = -1;
                                        CL3 = -1;
                                        Ki3 = -1;
                                        RW4 = -1;
                                        CL4 = -1;
                                        Ki4 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        RW6 = -1;
                                        CL6 = -1;
                                        Ki6 = -1;
                                        MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].NumberOfPenalties);
                                        if (MaxLess2 > MaxLess1)
                                            MaxLess1 = -1;
                                        if (MaxLess2 > MaxLess3)
                                            MaxLess3 = -1;
                                        if (MaxLess2 > MaxLess4)
                                            MaxLess4 = -1;
                                        if (MaxLess2 > MaxLess5)
                                            MaxLess5 = -1;
                                        if (MaxLess2 > MaxLess6)
                                            MaxLess6 = -1;

                                        if (AStarGreedyi == 1)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Elephant By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Elephant By Alice!");

                                                }
                                            }

                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                                AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                                AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                                AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                            }
                                            Act = true;
                                            Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                            TableHeuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                        }
                                    }
                                    else
                                    {


                                        if (AStarGreedyi == 1)
                                        {
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            int LessB = Int32.MinValue;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxElephntFounded)
                                                continue;

                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = ElephantOnTable[RW2].ElefantThinking[CL2].Row;
                                                AllDraw.LastColumn = ElephantOnTable[RW2].ElefantThinking[CL2].Column;
                                                AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                                AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                            }
                                            Act = true;
                                            Less = ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHeuristic(RW2, Ki2, Order, false, ref HaveKilled);
                                            TableHeuristic = ElephantOnTable[RW2].ElefantThinking[CL2].TableListElefant[Ki2];
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                                }
                                            }
                                        }

                                    }
                                }

                            }

                        }


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //hourse
                for (i = 0; i < HourseMidle; i++)
                {
                    for (int k = 0; k < AllDraw.HourseMovments; k++)

                        for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[k] != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                        {
                            {

                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;

                                ChessRules.CurrentOrder *= -1;
                                Order *= -1;
                                Do = 0;
                                if (UsePenaltyRegardMechnisamT)
                                {
                                    for (int ij = 0; ij < HoursesOnTable[i].HourseThinking[k].AStarGreedy.Count - 1; ij++)
                                        HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij]);
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                        continue;
                                }


                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3)
                                {
                                    Object On = new Object();
                                    lock (On)
                                    {
                                        AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                        AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                        AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                        AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];

                                        Act = true;
                                        Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                    }
                                    TableHeuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                    RegardOccurred = true;
                                    continue;

                                }
                                Object ol = new Object();
                                lock (ol)
                                {
                                    //When There is No Movments in Such Order Enemy continue.
                                    if (Order != AllDraw.OrderPlate)
                                        if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                            continue;
                                    //When There is greater Heuristic Movments.
                                    if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                    {

                                        //retrive table of current Heuristic.
                                        int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                        int[,] TableSS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                        {
                                            //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                            if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                            {

                                                if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                    continue;


                                            }
                                            //When there is not Penalty regard mechanism.

                                            AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 3, CloneATable(TableS), Order, HoursesOnTable[i].HourseThinking[k].Row, HoursesOnTable[i].HourseThinking[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(TableS, Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }

                                            }
                                        }
                                        RW3 = i;
                                        CL3 = k;
                                        Ki3 = j;
                                        RW1 = -1;
                                        CL1 = -1;
                                        Ki1 = -1;
                                        RW2 = -1;
                                        CL2 = -1;
                                        Ki2 = -1;
                                        RW4 = -1;
                                        CL4 = -1;
                                        Ki4 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        RW6 = -1;
                                        CL6 = -1;
                                        Ki6 = -1;
                                        MaxLess3 = (HoursesOnTable[RW3].HourseThinking[CL3].NumberOfPenalties);
                                        if (MaxLess3 > MaxLess1)
                                            MaxLess1 = -1;
                                        if (MaxLess3 > MaxLess2)
                                            MaxLess2 = -1;
                                        if (MaxLess3 > MaxLess4)
                                            MaxLess4 = -1;
                                        if (MaxLess3 > MaxLess5)
                                            MaxLess5 = -1;
                                        if (MaxLess3 > MaxLess6)
                                            MaxLess6 = -1;

                                        if (AStarGreedyi == 1)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Hourse By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Hourse By Alice!");

                                                }
                                            }
                                            //Set Table and Heuristic Value and Syntax.

                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                                AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                                AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                                AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                            }
                                            Act = true;
                                            Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                            TableHeuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];

                                        }

                                    }
                                    else
                                    //Set Table and Heuristic Value and Syntax.
                                    if (AStarGreedyi == 1)
                                    {
                                        //TakeRoot.Pointer = this;
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxHourseFounded)
                                            continue;

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = HoursesOnTable[RW3].HourseThinking[CL3].Row;
                                            AllDraw.LastColumn = HoursesOnTable[RW3].HourseThinking[CL3].Column;
                                            AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                            AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                        }
                                        Act = true;
                                        Less = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHeuristic(RW3, Ki3, Order, false, ref HaveKilled);
                                        TableHeuristic = HoursesOnTable[RW3].HourseThinking[CL3].TableListHourse[Ki3];
                                        Object O = new Object();
                                        lock (O)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                            }
                                        }
                                    }
                                }
                            }
                        }




                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                }
                //Castle
                for (i = 0; i < CastleMidle; i++)
                {
                    for (int k = 0; k < AllDraw.CastleMovments; k++)

                        for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[k] != null && CastlesOnTable[i].CastleThinking[k] != null && j < CastlesOnTable[i].CastleThinking[k].TableListCastle.Count; j++)
                        {
                            {

                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;

                                ChessRules.CurrentOrder *= -1;
                                Order *= -1;
                                Do = 0;
                                if (UsePenaltyRegardMechnisamT)
                                {
                                    for (int ij = 0; ij < CastlesOnTable[i].CastleThinking[k].AStarGreedy.Count - 1; ij++)
                                        CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij]);
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                        continue;
                                }


                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;

                                if ((CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                                {

                                    Object On = new Object();
                                    lock (On)
                                    {
                                        AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                        AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                        AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                        AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];

                                        Act = true;
                                        Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                    }
                                    TableHeuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                    RegardOccurred = true;

                                    continue;
                                }
                                Object ol = new Object();
                                lock (ol)
                                {
                                    //When There is No Movments in Such Order Enemy continue.
                                    if (Order != AllDraw.OrderPlate)
                                        if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less) continue;
                                    //When There is greater Heuristic Movments.
                                    if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less)
                                    {

                                        //retrive table of current Heuristic.
                                        int[,] TableS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                        int[,] TableSS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                        {

                                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                continue;



                                        }
                                        //When there is not Penalty regard mechanism.

                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 4, CloneATable(TableS), Order, CastlesOnTable[i].CastleThinking[k].Row, CastlesOnTable[i].CastleThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        RW4 = i;
                                        CL4 = k;
                                        Ki4 = j;
                                        RW1 = -1;
                                        CL1 = -1;
                                        Ki1 = -1;
                                        RW2 = -1;
                                        CL2 = -1;
                                        Ki2 = -1;
                                        RW3 = -1;
                                        CL3 = -1;
                                        Ki3 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        RW6 = -1;
                                        CL6 = -1;
                                        Ki6 = -1;
                                        MaxLess4 = (CastlesOnTable[RW4].CastleThinking[CL4].NumberOfPenalties);
                                        if (MaxLess4 > MaxLess1)
                                            MaxLess1 = -1;
                                        if (MaxLess4 > MaxLess2)
                                            MaxLess2 = -1;
                                        if (MaxLess4 > MaxLess3)
                                            MaxLess3 = -1;
                                        if (MaxLess4 > MaxLess5)
                                            MaxLess5 = -1;
                                        if (MaxLess4 > MaxLess6)
                                            MaxLess6 = -1;


                                        if (AStarGreedyi == 1)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Castles By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Castles By Alice!");

                                                }
                                            }
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                                AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                                AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                                AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                            }
                                            Act = true;
                                            Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                            TableHeuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];

                                        }
                                    }
                                    else//Set Table and Heuristic Value and Syntax.
                                    {

                                        if (AStarGreedyi == 1)
                                        {
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            int LessB = Int32.MinValue;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxCastlesFounded)
                                                continue;

                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = CastlesOnTable[RW4].CastleThinking[CL4].Row;
                                                AllDraw.LastColumn = CastlesOnTable[RW4].CastleThinking[CL4].Column;
                                                AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                                AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                            }
                                            Act = true;
                                            Less = CastlesOnTable[RW4].CastleThinking[CL4].ReturnHeuristic(RW4, Ki4, Order, false, ref HaveKilled);
                                            TableHeuristic = CastlesOnTable[RW4].CastleThinking[CL4].TableListCastle[Ki4];
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                                }
                                            }
                                        }

                                    }
                                }

                            }
                        }


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                //minister
                for (i = 0; i < MinisterMidle; i++)
                {
                    for (int k = 0; k < AllDraw.MinisterMovments; k++)

                        for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[k] != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                        {
                            {
                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.

                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;

                                ChessRules.CurrentOrder *= -1;
                                Order *= -1;
                                Do = 0;
                                if (UsePenaltyRegardMechnisamT)
                                {
                                    for (int ij = 0; ij < MinisterOnTable[i].MinisterThinking[k].AStarGreedy.Count - 1; ij++)
                                        MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij]);
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                        continue;
                                }


                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;

                                if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3)
                                {

                                    Object On = new Object();
                                    lock (On)
                                    {
                                        AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                        AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                        AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                        AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];

                                        Act = true;
                                        Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                    }
                                    TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                    RegardOccurred = true;

                                    continue;
                                }
                                Object ol = new Object();
                                lock (ol)
                                {
                                    if (Order != AllDraw.OrderPlate)
                                        if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                            continue;
                                    if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                    {

                                        //retrive table of current Heuristic.

                                        //retrive table of current Heuristic.
                                        int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                        int[,] TableSS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                        {

                                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                continue;


                                        }

                                        //When there is not Penalty regard mechanism.

                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 5, CloneATable(TableS), Order, MinisterOnTable[i].MinisterThinking[k].Row, MinisterOnTable[i].MinisterThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }


                                        RW5 = i;
                                        CL5 = k;
                                        Ki5 = j;
                                        RW1 = -1;
                                        CL1 = -1;
                                        Ki1 = -1;
                                        RW2 = -1;
                                        CL2 = -1;
                                        Ki2 = -1;
                                        RW3 = -1;
                                        CL3 = -1;
                                        Ki3 = -1;
                                        RW4 = -1;
                                        CL4 = -1;
                                        Ki4 = -1;
                                        RW6 = -1;
                                        CL6 = -1;
                                        Ki6 = -1;
                                        MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].NumberOfPenalties);
                                        if (MaxLess5 > MaxLess1)
                                            MaxLess1 = -1;
                                        if (MaxLess5 > MaxLess2)
                                            MaxLess2 = -1;
                                        if (MaxLess5 > MaxLess3)
                                            MaxLess3 = -1;
                                        if (MaxLess5 > MaxLess4)
                                            MaxLess4 = -1;
                                        if (MaxLess5 > MaxLess6)
                                            MaxLess6 = -1;


                                        if (AStarGreedyi == 1)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Minister By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Minister By Alice!");

                                                }   //Set Table and Heuristic Value and Syntax.
                                            }
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                                AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                                AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                                AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                            }
                                            Act = true;
                                            Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                            TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];

                                        }
                                    }
                                    else//Set Table and Heuristic Value and Syntax.
                                    {

                                        if (AStarGreedyi == 1)
                                        {
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            int LessB = Int32.MinValue;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxMinisterFounded)
                                                continue;

                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = MinisterOnTable[RW5].MinisterThinking[CL5].Row;
                                                AllDraw.LastColumn = MinisterOnTable[RW5].MinisterThinking[CL5].Column;
                                                AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                                AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                            }
                                            Act = true;
                                            Less = MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHeuristic(RW5, Ki5, Order, false, ref HaveKilled);
                                            TableHeuristic = MinisterOnTable[RW5].MinisterThinking[CL5].TableListMinister[Ki5];
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                                }
                                            }
                                        }

                                    }
                                }
                            }
                        }


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //king
                for (i = 0; i < KingMidle; i++)
                {
                    for (int k = 0; k < AllDraw.KingMovments; k++)

                        for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking[k] != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                        {
                            {

                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.

                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;

                                ChessRules.CurrentOrder *= -1;
                                Order *= -1;
                                Do = 0;
                                if (UsePenaltyRegardMechnisamT)
                                {
                                    for (int ij = 0; ij < KingOnTable[i].KingThinking[k].AStarGreedy.Count - 1; ij++)
                                        KingOnTable[i].KingThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, KingOnTable[i].KingThinking[k].AStarGreedy[ij]);
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                        continue;
                                }


                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                //)

                                if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                                {
                                    Object On = new Object();
                                    lock (On)
                                    {
                                        AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                        AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                        AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                        AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];

                                        Act = true;
                                        Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                    }
                                    TableHeuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                    RegardOccurred = true;
                                    continue;
                                }
                                Object ol = new Object();
                                lock (ol)
                                {

                                    //When There is No Movments in Such Order Enemy continue.
                                    if (Order != AllDraw.OrderPlate)
                                        if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                            continue;
                                    //When There is greater Heuristic Movments.
                                    if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                    {

                                        //retrive table of current Heuristic.
                                        int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                        int[,] TableSS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                        {

                                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                continue;

                                        }
                                        //When there is not Penalty regard mechanism.

                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 6, CloneATable(TableS), Order, KingOnTable[i].KingThinking[k].Row, KingOnTable[i].KingThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }


                                        RW6 = i;
                                        CL6 = k;
                                        Ki6 = j;
                                        RW1 = -1;
                                        CL1 = -1;
                                        Ki1 = -1;
                                        RW2 = -1;
                                        CL2 = -1;
                                        Ki2 = -1;
                                        RW3 = -1;
                                        CL3 = -1;
                                        Ki3 = -1;
                                        RW4 = -1;
                                        CL4 = -1;
                                        Ki4 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].NumberOfPenalties);
                                        if (MaxLess6 > MaxLess1)
                                            MaxLess1 = -1;
                                        if (MaxLess6 > MaxLess2)
                                            MaxLess2 = -1;
                                        if (MaxLess6 > MaxLess3)
                                            MaxLess3 = -1;
                                        if (MaxLess6 > MaxLess4)
                                            MaxLess4 = -1;
                                        if (MaxLess6 > MaxLess5)
                                            MaxLess5 = -1;


                                        if (AStarGreedyi == 1)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic King By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic King By Alice!");

                                                }
                                            }
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                                AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                                AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                                AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                            }
                                            Act = true;
                                            Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                            TableHeuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                        }


                                    }
                                    else//Set Table and Heuristic Value and Syntax.
                                    {

                                        if (AStarGreedyi == 1)
                                        {
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            int LessB = Int32.MinValue;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxKingFounded)
                                                continue;

                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = KingOnTable[RW6].KingThinking[CL6].Row;
                                                AllDraw.LastColumn = KingOnTable[RW6].KingThinking[CL6].Column;
                                                AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                                AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                            }

                                            Act = true;
                                            Less = KingOnTable[RW6].KingThinking[CL6].ReturnHeuristic(RW6, Ki6, Order, false, ref HaveKilled);
                                            TableHeuristic = KingOnTable[RW6].KingThinking[CL6].TableListKing[Ki6];
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                                }
                                            }
                                        }

                                    }
                                }

                            }

                        }


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchPenalties:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //method for monitor of main Heuristic found best movment (action string)
        void StringHeuristics(int Obj, int Sec, bool AA, int Do, int WinOcuuredatChiled, int LoseOcuuredatChiled)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            String SOut = "";
            if (Obj == 1)
            {
                SOut = "Soldier ";
            }
            else
                if (Obj == 2)
            {
                SOut = "Elephant ";
            }
            else
                if (Obj == 3)
            {
                SOut = "Hourse ";
            }
            else
                if (Obj == 4)
            {
                SOut = "Castle ";
            }
            else
                if (Obj == 5)
            {
                SOut = "Minister ";
            }
            else
                    if (Obj == 6)
            {
                SOut = "King ";
            }
            SOut += "AStar Heuristics ";
            if (Sec == 1)
                SOut += " -Initiatetion- ";
            if (Sec == 2)
                SOut += " -Regard- ";
            if (Sec == 3)
                SOut += " -Foundation Greatest- ";
            if (WinOcuuredatChiled >= 1)
                SOut += " At -WinKing Checked Mate- is active For Eneter Regard- ";
            if (LoseOcuuredatChiled <= -1)
                SOut += " At -LoseKing Checked Mate- is active For Eneter Penelty- ";
            if (AA)
                SOut += " '-AA-' is Active due to Regard Enter- ";
            if (Do == 1)
                SOut += " '-Do-' is Active due to Regard Enter- ";
            SOut += " With Heuristic Count " + AllDraw.Less;
            Object O = new Object();
            lock (O)
            {
                //OutPut.Append("\r\n" + SOut);
            }

            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("StringHeuristics:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        bool IsSupHuTrue(int i, int j, int k, int Kind)
        {
            bool Is = false;
            if (Kind == 1)
                Is = SolderesOnTable[i].SoldierThinking[0].IsSupHu[j];
            else
   if (Kind == 2)
                Is = ElephantOnTable[i].ElefantThinking[0].IsSupHu[j];
            else
   if (Kind == 3)
                Is = HoursesOnTable[i].HourseThinking[0].IsSupHu[j];
            else
   if (Kind == 4)
                Is = CastlesOnTable[i].CastleThinking[0].IsSupHu[j];
            else
   if (Kind == 5)
                Is = MinisterOnTable[i].MinisterThinking[0].IsSupHu[j];
            else
   if (Kind == 6)
                Is = KingOnTable[i].KingThinking[0].IsSupHu[j];
            return Is;
        }
        //method for return index base calculated Heuristic specified and clear
        void SaveLess(int i, int j, int k, int Kind, ref int Less, bool AA, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //soldier
            if (Kind == 1)
            {
                Less = SolderesOnTable[i].SoldierThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//elephant
        if (Kind == 2)
            {
                Less = ElephantOnTable[i].ElefantThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//hourse
        if (Kind == 3)
            {
                Less = HoursesOnTable[i].HourseThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//Castle
        if (Kind == 4)
            {
                Less = CastlesOnTable[i].CastleThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//minister
        if (Kind == 5)
            {
                Less = MinisterOnTable[i].MinisterThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//king
        if (Kind == 6)
            {
                Less = KingOnTable[i].KingThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("SaveLess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //index of tables that verified existence havbeen saved into refer var
        void SaveTableHeuristic(int i, int j, int k, int Kind, ref int[,] TableHeuristic)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //soldier
            if (Kind == 1)
            {
                TableHeuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
            }
            else//elephant
                if (Kind == 2)
            {
                TableHeuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
            }
            else//hourse
                if (Kind == 3)
            {
                TableHeuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
            }
            else//Castle
                if (Kind == 4)
            {
                TableHeuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
            }
            else//minister
                if (Kind == 5)
            {
                TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
            }
            else//king
                if (Kind == 6)
            {
                TableHeuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("SaveTableHeuristic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //same of befor verified existence of begin move and end move location saved in unique results of Last best movments
        void SaveBeginEndLocation(int i, int j, int k, int Kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //soldier
            if (Kind == 1)
            {
                AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
            }
            else//elephant
                 if (Kind == 2)
            {
                AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
            }
            else//hourse
                 if (Kind == 3)
            {
                AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
            }
            else//Castle
                 if (Kind == 4)
            {
                AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
            }
            else//minister
                 if (Kind == 5)
            {
                AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
            }
            else//king
                 if (Kind == 6)
            {
                AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("SaveBeginEndLocation:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //regard section of main Heuristic in learning autamata section
        bool HeuristicRegardSection(int i, int j, int k, ref bool Act, ref int[,] TableHeuristic, ref bool AA, Color a, int Kind, ref int Do, int AStarGreedyi, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool continued = false;
            if (IsSupHuTrue(i, j, k, Kind))
                return true;

            //soldier
            if (Kind == 1)
            {
                if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((((Do == 1 || AA) && UsePenaltyRegardMechnisamT)) && UsePenaltyRegardMechnisamT) || SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    //Set Table and Heuristic Value and Syntax.
                    Act = true;
                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 1);

                        SaveTableHeuristic(i, j, k, 1, ref TableHeuristic);

                        SaveLess(i, j, k, 1, ref Less, AA, Order);
                    }

                    Object O = new Object();
                    lock (O)
                    {
                        ThingsConverter.ActOfClickEqualTow = true;
                    }

                    SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);

                    int Sign = 1;
                    if (a == Color.Brown)
                        Sign = -1;


                    //If there is Soldier Convert.
                    if (SolderesOnTable[i].Convert)
                    {

                        if (SolderesOnTable[i].ConvertedToMinister)
                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                        else if (SolderesOnTable[i].ConvertedToCastle)
                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                        else if (SolderesOnTable[i].ConvertedToHourse)
                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                        else if (SolderesOnTable[i].ConvertedToElefant)
                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;

                    }

                    RegardOccurred = true;

                    StringHeuristics(1, 2, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);

                    continued = true;
                }

            }
            else//elephant
            if (Kind == 2)
            {
                if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3)
                {

                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 2);

                        SaveTableHeuristic(i, j, k, 2, ref TableHeuristic);

                        SaveLess(i, j, k, 2, ref Less, AA, Order);
                    }

                    StringHeuristics(2, 2, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);

                    RegardOccurred = true;

                    continued = true;

                }
            }
            else//hourse
            if (Kind == 3)
            {
                if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 3);

                        SaveTableHeuristic(i, j, k, 3, ref TableHeuristic);

                        SaveLess(i, j, k, 3, ref Less, AA, Order);
                    }

                    RegardOccurred = true;

                    StringHeuristics(3, 2, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);

                    continued = true;

                }

            }
            else//Castle
            if (Kind == 4)
            {
                if ((CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                {

                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 4);

                        SaveTableHeuristic(i, j, k, 4, ref TableHeuristic);

                        SaveLess(i, j, k, 4, ref Less, AA, Order);
                    }

                    RegardOccurred = true;
                    StringHeuristics(4, 2, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);

                    continued = true;
                }
            }
            else//minister
                if (Kind == 5)
            {
                if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3)
                {

                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 5);

                        SaveTableHeuristic(i, j, k, 5, ref TableHeuristic);

                        SaveLess(i, j, k, 5, ref Less, AA, Order);
                    }

                    TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                    RegardOccurred = true;
                    StringHeuristics(5, 2, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);

                    continued = true;
                }
            }
            else//king
            if (Kind == 6)
            {
                if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 6);

                        SaveTableHeuristic(i, j, k, 6, ref TableHeuristic);

                        SaveLess(i, j, k, 6, ref Less, AA, Order);
                    }

                    RegardOccurred = true;
                    StringHeuristics(6, 2, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);

                    //if (KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                    // Less = Int32.MaxValue;



                    //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                    //return TableHeuristic;
                    continued = true;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicRegardSection:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return continued;
        }
        //initiate deterministic vars of orderic Heuristic value
        void InitiateVars(int i, int j, int k, int Kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            RW1 = -1;
            CL1 = -1;
            Ki1 = -1;
            RW2 = -1;
            CL2 = -1;
            Ki2 = -1;
            RW3 = -1;
            CL3 = -1;
            Ki3 = -1;
            RW4 = -1;
            CL4 = -1;
            Ki4 = -1;
            RW5 = -1;
            CL5 = -1;
            Ki5 = -1;
            RW6 = -1;
            CL6 = -1;
            Ki6 = -1;
            //Sodleirs 
            if (Kind == 1)
            {
                RW1 = i;
                CL1 = k;
                Ki1 = j;
            }
            else//elephant
                if (Kind == 2)
            {
                RW2 = i;
                CL2 = k;
                Ki2 = j;
            }
            else//hourse
                if (Kind == 3)
            {
                RW3 = i;
                CL3 = k;
                Ki3 = j;
            }
            else//Castle
                if (Kind == 4)
            {
                RW4 = i;
                CL4 = k;
                Ki4 = j;
            }
            else//minister
                if (Kind == 5)
            {
                RW5 = i;
                CL5 = k;
                Ki5 = j;
            }
            else//king
                if (Kind == 6)
            {
                RW6 = i;
                CL6 = k;
                Ki6 = j;
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateVars:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //deterministic of checke of movments occured for ignore
        bool CheckeHuristci(int[,] TableS, int Order, int i, int j, int k)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool continued = false;
            ChessRules AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
            //If there is kish or kshachamaz Order.
            if (AB.Check(TableS, Order))
            {
                //When Order is Gray.
                if (Order == 1)
                {
                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                    if (AB.CheckGray)
                        continued = true;
                }
                else
                {
                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                    if (AB.CheckBrown)
                        continued = true;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CheckeHuristci:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return continued;
        }
        //minitoring of Heuristic output
        void OutputHeuristic(int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                if (Order == 1)
                {
                    //OutPut.Append("\r\nChess Heuristic Elephant By Bob!");

                }
                else//If Order is Brown.
                {
                    //OutPut.Append("\r\nChess Heuristic Elephant By Alice!");

                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("OutputHeuristic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //main method of Heuristic
        bool HeuristicMainBody(int i, int j, int k, ref bool Act, ref int[,] TableHeuristic, ref bool CurrentTableHeuristic, ref bool AA, Color a, int Kind, ref int Do, int AStarGreedyi, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool continued = false;
            if (IsSupHuTrue(i, j, k, Kind))
                return true;

            if (Kind == 1)
            {
                if (SolderesOnTable[i].SoldierThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {


                    Object O11 = new Object();
                    lock (O11)
                    {
                        int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                        {

                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                            {
                                //if (Order == 1)
                                //AllDraw.OutPut.Append("\r\nHeuristic Soldier By Bob was not Valid Movment!");
                                //else
                                //AllDraw.OutPut.Append("\r\nHeuristic Soldier By Alice was not Valid Movment!");

                                return true;
                            }


                        }
                        //When there is not Penalty regard mechanism.
                        if (CheckeHuristci(TableS, Order, i, j, k))
                            return true;


                        InitiateVars(i, j, k, 1);

                        //Set Max of Soldier.
                        MaxLess1 = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
                        if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                        {
                            if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                                return true;
                        }
                        if (!KillerForce(HaveKilled))
                            return true;

                        //When Soldeirs is Greater than Others these Set Max.
                        if (MaxLess1 > MaxLess2)
                            MaxLess2 = -1;
                        if (MaxLess1 > MaxLess3)
                            MaxLess3 = -1;
                        if (MaxLess1 > MaxLess4)
                            MaxLess4 = -1;
                        if (MaxLess1 > MaxLess5)
                            MaxLess5 = -1;
                        if (MaxLess1 > MaxLess6)
                            MaxLess6 = -1;

                        if (AStarGreedyi == 1)
                        {
                            OutputHeuristic(Order);

                            //Set Table and Heuristic Value and Syntax.
                            Act = true;
                            Object On = new Object();
                            lock (On)
                            {
                                SaveBeginEndLocation(i, j, k, 1);

                                SaveTableHeuristic(i, j, k, 1, ref TableHeuristic);

                                SaveLess(i, j, k, 1, ref Less, AA, Order);
                            }

                            StringHeuristics(1, 3, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);



                            Object O1 = new Object();
                            lock (O1)
                            {
                                ThingsConverter.ActOfClickEqualTow = true;
                            }
                            SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                            int Sign = 1;
                            if (a == Color.Brown)
                                Sign = -1;
                            //If there is Soldier Convert.
                            if (SolderesOnTable[i].Convert)
                            {

                                if (SolderesOnTable[i].ConvertedToMinister)
                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                else if (SolderesOnTable[i].ConvertedToCastle)
                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                else if (SolderesOnTable[i].ConvertedToHourse)
                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                else if (SolderesOnTable[i].ConvertedToElefant)
                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;

                            }
                        }
                    }
                }
            }
            else if (Kind == 2)
            {
                if (ElephantOnTable[i].ElefantThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {

                    Object O = new Object();
                    lock (O)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current Heuristic.
                    int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {

                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)
                            //AllDraw.OutPut.Append("\r\nHeuristic Elephant By Bob was not Valid Movment!");
                            //else
                            //AllDraw.OutPut.Append("\r\nHeuristic Elephant By Alice was not Valid Movment!");

                            return true;
                        }



                    }
                    //When there is not Penalty regard mechanism.
                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;


                    InitiateVars(i, j, k, 2);

                    MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHeuristic(RW2, Ki2, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;

                    if (MaxLess2 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess2 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess2 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess2 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess2 > MaxLess6)
                        MaxLess6 = -1;

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);

                        //Set Table and Heuristic Value and Syntax.

                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 2);

                            SaveTableHeuristic(i, j, k, 2, ref TableHeuristic);

                            SaveLess(i, j, k, 2, ref Less, AA, Order);
                        }
                        Act = true;

                        StringHeuristics(2, 3, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);


                    }
                }
            }
            else if (Kind == 3)
            {
                if (HoursesOnTable[i].HourseThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current Heuristic.
                    int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];

                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {

                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            if (Order == 1)
                            {
                                //AllDraw.OutPut.Append("\r\nHeuristic Hourse By Bob was not Valid Movment!");
                            }
                            else
                            {
                                //AllDraw.OutPut.Append("\r\nHeuristic Hourse By Alice was not Valid Movment!");

                                return true;
                            }
                        }

                    }
                    //When there is not Penalty regard mechanism.
                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;

                    InitiateVars(i, j, k, 3);


                    MaxLess3 = (HoursesOnTable[RW3].HourseThinking[CL3].ReturnHeuristic(RW3, Ki3, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;

                    if (MaxLess3 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess3 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess3 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess3 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess3 > MaxLess6)
                        MaxLess6 = -1;

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);

                        //Set Table and Heuristic Value and Syntax.
                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 3);

                            SaveTableHeuristic(i, j, k, 3, ref TableHeuristic);

                            SaveLess(i, j, k, 3, ref Less, AA, Order);
                        }

                        Act = true;

                        StringHeuristics(3, 3, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);
                    }

                }

            }
            else if (Kind == 4)
            {
                if (CastlesOnTable[i].CastleThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current Heuristic.

                    //retrive table of current Heuristic.
                    int[,] TableS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {

                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)
                            //AllDraw.OutPut.Append("\r\nHeuristic Castle By Bob was not Valid Movment!");
                            //else
                            //AllDraw.OutPut.Append("\r\nHeuristic Castle By Alice was not Valid Movment!");

                            return true;
                        }



                    }
                    //When there is not Penalty regard mechanism.
                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;


                    InitiateVars(i, j, k, 4);

                    MaxLess4 = (CastlesOnTable[RW4].CastleThinking[CL4].ReturnHeuristic(RW4, Ki4, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;

                    if (MaxLess4 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess4 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess4 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess4 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess4 > MaxLess6)
                        MaxLess6 = -1;


                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);

                        //Set Table and Heuristic Value and Syntax.

                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 4);

                            SaveTableHeuristic(i, j, k, 4, ref TableHeuristic);

                            SaveLess(i, j, k, 4, ref Less, AA, Order);
                        }

                        Act = true;
                        StringHeuristics(4, 3, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);
                    }
                }
                else//Set Table and Heuristic Value and Syntax.
                {
                }
            }
            else if (Kind == 5)
            {
                if (MinisterOnTable[i].MinisterThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current Heuristic.

                    //retrive table of current Heuristic.
                    int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {

                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)
                            //AllDraw.OutPut.Append("\r\nHeuristic Minister By Bob was not Valid Movment!");
                            //else 
                            //AllDraw.OutPut.Append("\r\nHeuristic Minister By Alice was not Valid Movment!");

                            return true;
                        }

                    }

                    //When there is not Penalty regard mechanism.
                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;



                    InitiateVars(i, j, k, 5);


                    MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHeuristic(RW5, Ki5, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;


                    if (MaxLess5 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess5 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess5 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess5 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess5 > MaxLess6)
                        MaxLess6 = -1;


                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);

                        //Set Table and Heuristic Value and Syntax.

                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 5);

                            SaveTableHeuristic(i, j, k, 5, ref TableHeuristic);

                            SaveLess(i, j, k, 5, ref Less, AA, Order);
                        }

                        Act = true;

                        StringHeuristics(5, 3, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);
                    }
                }

            }
            else if (Kind == 6)
            {
                if (KingOnTable[i].KingThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {
                    Object OO = new Object();
                    lock (OO)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current Heuristic.

                    //retrive table of current Heuristic.
                    int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];

                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {

                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)
                            //AllDraw.OutPut.Append("\r\nHeuristic King By Bob was not Valid Movment!");
                            //else
                            //AllDraw.OutPut.Append("\r\nHeuristic King By Alice was not Valid Movment!");

                            return true;
                        }

                    }
                    //When there is not Penalty regard mechanism.

                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;

                    InitiateVars(i, j, k, 6);


                    MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].ReturnHeuristic(RW6, Ki6, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;

                    if (MaxLess6 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess6 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess6 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess6 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess6 > MaxLess5)
                        MaxLess5 = -1;


                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);

                        //Set Table and Heuristic Value and Syntax.

                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 6);

                            SaveTableHeuristic(i, j, k, 6, ref TableHeuristic);

                            SaveLess(i, j, k, 6, ref Less, AA, Order);
                        }

                        Act = true;

                        StringHeuristics(6, 3, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);
                    }


                }
                else//Set Table and Heuristic Value and Syntax.
                {
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicMainBody:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return continued;
        }
        //determined verified victom occured
        bool KiilledForce(int HaveKiller)
        {
            if (ThinkingChess.IsAtLeastOneKillerAtDraw)
            {
                if (System.Math.Abs(HaveKilled) > 0)
                    return true;

            }

            return false;
        }
        //detrmined verfied ingured occured
        bool KillerForce(int HaveKiller)
        {
            return ((ThinkingChess.IsAtLeastOneKillerAtDraw) || (!(HaveKiller > 0)));
        }
        //soldier Heuristic
        int[,] HeuristicAStarGreadySearchSoldier(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;


            Object a1 = new Object();
            lock (a1)
            {
                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;



                //For Every Soldier Movments AStarGreedy.
                for (int k = 0; k < AllDraw.SodierMovments; k++)
                //When There is an Movment in such situation.
                {
                    for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                    {

                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count > j && SolderesOnTable[i].SoldierThinking[k].AStarGreedy[j] != null)
                                SolderesOnTable[i].SoldierThinking[k].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;


                            StringHeuristics(1, 1, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);

                            if (SolderesOnTable[i].LoseOcuuredatChiled <= -1 || SolderesOnTable[i].LoseOcuuredatChiled <= -2 || SolderesOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HeuristicRegardSection(i, j, k, ref Act, ref TableHeuristic, ref AA, a, 1, ref Do, AStarGreedyi, Order))
                                continue;
                            //When There is No Movments in Such Order Enemy continue.
                            Object ol = new Object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlate)
                                    if (SolderesOnTable[i].SoldierThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.

                                if (HeuristicMainBody(i, j, k, ref Act, ref TableHeuristic, ref CurrentTableHeuristic, ref AA, a, 1, ref Do, AStarGreedyi, Order))
                                    continue;

                            }

                        }
                    }

                }


                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchSoldier:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //gray section of soldier Heuristic
        int[,] HeuristicAStarGreadySearchSoldierGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object a1 = new Object();
            lock (a1)
            {

                if (SodierMidle != 0)
                {
                    for (var i = 0; i < SodierMidle; i++)
                        TableHeuristic = HeuristicAStarGreadySearchSoldier(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchSoldierGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //brown section of soldier Heuristic
        int[,] HeuristicAStarGreadySearchSoldierBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {
                if (SodierMidle != SodierHigh)
                {

                    for (var i = SodierMidle; i < SodierHigh; i++)
                        TableHeuristic = HeuristicAStarGreadySearchSoldier(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchSoldierBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //gray section of elephant Heuristic
        int[,] HeuristicAStarGreadySearchElephantGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object a1 = new Object();
            lock (a1)
            {
                if (0 != ElefantMidle)
                {
                    //Do For Remaining Objects same as Soldeir Documentation.
                    for (var i = 0; i < ElefantMidle; i++)
                        TableHeuristic = HeuristicAStarGreadySearchElephant(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchElephantGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //brown section of elephant Heuristic
        int[,] HeuristicAStarGreadySearchElephantBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                if (ElefantHigh != ElefantMidle)
                {
                    //Do For Remaining Objects same as Soldeir Documentation.
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        TableHeuristic = HeuristicAStarGreadySearchElephant(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchElephantBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main section of elephant Heuristic
        int[,] HeuristicAStarGreadySearchElephant(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.ElefantMovments; k++)

                {
                    for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                    {

                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j] != null)
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(2, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;


                            StringHeuristics(2, 1, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);
                            if (ElephantOnTable[i].LoseOcuuredatChiled <= -1 || ElephantOnTable[i].LoseOcuuredatChiled <= -2 || ElephantOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HeuristicRegardSection(i, j, k, ref Act, ref TableHeuristic, ref AA, a, 2, ref Do, AStarGreedyi, Order))
                                continue;


                            Object ol = new Object();
                            lock (ol)
                            {

                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (ElephantOnTable[i].ElefantThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (HeuristicMainBody(i, j, k, ref Act, ref TableHeuristic, ref CurrentTableHeuristic, ref AA, a, 2, ref Do, AStarGreedyi, Order))
                                    continue;



                            }


                        }

                    }
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchElephant:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }


        }
        //gray section of hourse Heuristic
        int[,] HeuristicAStarGreadySearchHourseGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object a1 = new Object();
            lock (a1)
            {
                if (0 != HourseMidle)
                {
                    //For Every Soldeir
                    for (var i = 0; i < HourseMidle; i++)
                        TableHeuristic = HeuristicAStarGreadySearchHourse(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                //else
                   // CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchHourseGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //brown section of hourse Heuristic
        int[,] HeuristicAStarGreadySearchHourseBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                if (HourseHight != HourseMidle)
                {
                    //For Every Soldeir
                    for (var i = HourseMidle; i < HourseHight; i++)
                        TableHeuristic = HeuristicAStarGreadySearchHourse(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchHourseBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main section of hourse Heuristic
        int[,] HeuristicAStarGreadySearchHourse(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;


                for (int k = 0; k < AllDraw.HourseMovments; k++)
                {
                    for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                    {

                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j && HoursesOnTable[i].HourseThinking[0].AStarGreedy[j] != null)
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(3, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            StringHeuristics(3, 1, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);

                            if (HoursesOnTable[i].LoseOcuuredatChiled <= -1 || HoursesOnTable[i].LoseOcuuredatChiled <= -2 || HoursesOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;


                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            if (HeuristicRegardSection(i, j, k, ref Act, ref TableHeuristic, ref AA, a, 3, ref Do, AStarGreedyi, Order))
                                continue;

                            Object ol = new Object();
                            lock (ol)
                            {

                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (HoursesOnTable[i].HourseThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (HeuristicMainBody(i, j, k, ref Act, ref TableHeuristic, ref CurrentTableHeuristic, ref AA, a, 3, ref Do, AStarGreedyi, Order))
                                    continue;


                            }

                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchHourse:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //gray section of Castle Heuristic
        int[,] HeuristicAStarGreadySearchCastleGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                if (0 != HourseMidle)
                {
                    for (var i = 0; i < CastleMidle; i++)
                        TableHeuristic = HeuristicAStarGreadySearchCastle(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main brown section of Castle Heuristic
        int[,] HeuristicAStarGreadySearchCastleBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {


                if (CastleMidle != CastleHigh)
                {
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        TableHeuristic = HeuristicAStarGreadySearchCastle(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);

                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchCastleBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main section of Castle Heuristic
        int[,] HeuristicAStarGreadySearchCastle(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {


                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.CastleMovments; k++)
                {
                    for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[k] != null && j < CastlesOnTable[i].CastleThinking[k].TableListCastle.Count; j++)
                    {

                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j && CastlesOnTable[i].CastleThinking[0].AStarGreedy[j] != null)
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(4, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;

                            Order = COrder;
                            StringHeuristics(4, 1, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);

                            if (CastlesOnTable[i].LoseOcuuredatChiled <= -1 || CastlesOnTable[i].LoseOcuuredatChiled <= -2 || CastlesOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HeuristicRegardSection(i, j, k, ref Act, ref TableHeuristic, ref AA, a, 4, ref Do, AStarGreedyi, Order))
                                continue;


                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (CastlesOnTable[i].CastleThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (HeuristicMainBody(i, j, k, ref Act, ref TableHeuristic, ref CurrentTableHeuristic, ref AA, a, 4, ref Do, AStarGreedyi, Order))
                                    continue;

                            }

                        }
                    }


                }


                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchCastle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main section of minister Heuristic
        int[,] HeuristicAStarGreadySearchMinsisterGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (0 != MinisterMidle)
                {
                    for (var i = 0; i < MinisterMidle; i++)
                        TableHeuristic = HeuristicAStarGreadySearchMinsister(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);

                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchMinsisterGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }

        }
        //brown main section of minister Heuristic
        int[,] HeuristicAStarGreadySearchMinsisterBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (MinisterHigh != MinisterMidle)
                {
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        TableHeuristic = HeuristicAStarGreadySearchMinsister(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);

                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchMinsisterBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main section of minister Heuristic
        int[,] HeuristicAStarGreadySearchMinsister(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O3 = new Object();
            lock (O3)
            {

                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.MinisterMovments; k++)
                {
                    for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                    {

                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j] != null)
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(5, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            StringHeuristics(5, 1, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);

                            if (MinisterOnTable[i].LoseOcuuredatChiled <= -1 || MinisterOnTable[i].LoseOcuuredatChiled <= -2 || MinisterOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HeuristicRegardSection(i, j, k, ref Act, ref TableHeuristic, ref AA, a, 5, ref Do, AStarGreedyi, Order))
                                continue;

                            Object ol = new Object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlate)
                                    if (MinisterOnTable[i].MinisterThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                if (HeuristicMainBody(i, j, k, ref Act, ref TableHeuristic, ref CurrentTableHeuristic, ref AA, a, 5, ref Do, AStarGreedyi, Order))
                                    continue;

                            }
                        }
                    }


                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchMinsister:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main gray section of king Heuristic
        int[,] HeuristicAStarGreadySearchKingGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (0 != KingMidle)
                {
                    for (var i = 0; i < KingMidle; i++)
                        TableHeuristic = HeuristicAStarGreadySearchKing(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchKingGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main brown section of king Heuristic
        int[,] HeuristicAStarGreadySearchKingBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                if (KingHigh != KingMidle)
                {
                    for (var i = KingMidle; i < KingHigh; i++)
                        TableHeuristic = HeuristicAStarGreadySearchKing(ref TableHeuristic, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                //else
                    //CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchKingBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main section of king Heuristic
        int[,] HeuristicAStarGreadySearchKing(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.KingMovments; k++)
                {
                    for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                    {

                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count > j && KingOnTable[i].KingThinking[0].AStarGreedy[j] != null)
                                KingOnTable[i].KingThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(6, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            StringHeuristics(6, 1, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);

                            if (KingOnTable[i].LoseOcuuredatChiled <= -1 || KingOnTable[i].LoseOcuuredatChiled <= -2 || KingOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HeuristicRegardSection(i, j, k, ref Act, ref TableHeuristic, ref AA, a, 6, ref Do, AStarGreedyi, Order))
                                continue;

                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (KingOnTable[i].KingThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (HeuristicMainBody(i, j, k, ref Act, ref TableHeuristic, ref CurrentTableHeuristic, ref AA, a, 6, ref Do, AStarGreedyi, Order))
                                    continue;

                            }

                        }
                    }
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchKing:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main gray section of  Heuristic
        int[,] HeuristicAStarGreadySearchGray(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int[,] TableHeuristic = new int[8, 8];

                HeuristicAStarGreadySearchSoldierGray(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);

                HeuristicAStarGreadySearchElephantGray(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);


                HeuristicAStarGreadySearchHourseGray(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);


                HeuristicAStarGreadySearchCastleGray(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);

                HeuristicAStarGreadySearchMinsisterGray(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);

                HeuristicAStarGreadySearchKingGray(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //main brown section of Heuristic
        int[,] HeuristicAStarGreadySearchBrown(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] TableHeuristic = new int[8, 8];

                HeuristicAStarGreadySearchSoldierBrown(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);

                HeuristicAStarGreadySearchElephantBrown(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);


                HeuristicAStarGreadySearchHourseBrown(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);


                HeuristicAStarGreadySearchCastleBrown(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);

                HeuristicAStarGreadySearchMinsisterBrown(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);

                HeuristicAStarGreadySearchKingBrown(ref TableHeuristic, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreadySearchBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //brown section of penalty Heuristic
        int[,] BrownHeuristicAStarGreaedySearchPenalites(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                ChessRules AB = null;

                int ToCheckMate = -1, ForCheckMate = -1, j, i;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                int[,] TableHeuristic = new int[8, 8];
                //For Every Soldeir
                for (i = SodierMidle; i < SodierHigh; i++)
                {

                    //For Every Soldier Movments AStarGreedy.
                    for (int k = 0; k < AllDraw.SodierMovments; k++)
                        //When There is an Movment in such situation.

                        for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[k] != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count - 1; ij++)
                                    SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }


                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;

                            if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                //Set Table and Heuristic Value and Syntax.
                                Act = true;
                                Object o1l = new Object();
                                lock (o1l)
                                {

                                    AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                    AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                    AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                    AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];

                                    Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;
                                }


                                TableHeuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];


                                Object OO = new Object();
                                lock (OO)
                                {
                                    ThingsConverter.ActOfClickEqualTow = true;
                                }
                                SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                int Sign = 1;
                                if (a == Color.Brown)
                                    Sign = -1;
                                //If there is Soldier Convert.
                                if (SolderesOnTable[i].Convert)
                                {

                                    if (SolderesOnTable[i].ConvertedToMinister)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                    else if (SolderesOnTable[i].ConvertedToCastle)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                    else if (SolderesOnTable[i].ConvertedToHourse)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                    else if (SolderesOnTable[i].ConvertedToElefant)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;




                                    RegardOccurred = true;
                                    continue;
                                }

                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                {

                                    //retrive table of current Heuristic.
                                    int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {

                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;

                                    }
                                    //When there is not Penalty regard mechanism.

                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
                                    //If there is kish or kshachamaz Order.
                                    if (AB.Check(TableS, Order))
                                    {
                                        //When Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                            if (AB.CheckGray)
                                                continue;
                                        }
                                        else
                                        {
                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                            if (AB.CheckBrown)
                                                continue;
                                        }
                                    }

                                    RW1 = i;
                                    CL1 = k;
                                    Ki1 = j;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess1 = SolderesOnTable[RW1].SoldierThinking[CL1].NumberOfPenalties;
                                    if (MaxLess1 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess1 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess1 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess1 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess1 > MaxLess6)
                                        MaxLess6 = -1;

                                    //Set Table and Heuristic Value and Syntax.
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                            }
                                        }
                                        //Set Table and Heuristic Value and Syntax.
                                        Act = true;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                            AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                            AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                            AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                        }

                                        Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;


                                        TableHeuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];


                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            ThingsConverter.ActOfClickEqualTow = true;
                                        }
                                        SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                        int Sign = 1;
                                        if (a == Color.Brown)
                                            Sign = -1;
                                        //If there is Soldier Convert.
                                        if (SolderesOnTable[i].Convert)
                                        {

                                            if (SolderesOnTable[i].ConvertedToMinister)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToCastle)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToHourse)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToElefant)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;





                                        }

                                    }
                                    else
                                    {  //Set Table and Heuristic Value and Syntax.

                                        if (AStarGreedyi == 1)
                                        {
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            int LessB = Int32.MinValue;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxSoldeirFounded)
                                                continue;
                                            Act = true;
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = SolderesOnTable[RW1].SoldierThinking[CL1].Row;
                                                AllDraw.LastColumn = SolderesOnTable[RW1].SoldierThinking[CL1].Column;
                                                AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                            }
                                            Less = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHeuristic(RW1, Ki1, Order, false, ref HaveKilled);


                                            TableHeuristic = SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1];


                                            Object O1 = new Object();
                                            lock (O1)
                                            {
                                                ThingsConverter.ActOfClickEqualTow = true;
                                            }
                                            SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1], Order, false, i);
                                            int Sign = 1;
                                            if (a == Color.Brown)
                                                Sign = -1;
                                            //If there is Soldier Convert.
                                            if (SolderesOnTable[RW1].Convert)
                                            {

                                                if (SolderesOnTable[RW1].ConvertedToMinister)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToCastle)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;




                                            }
                                            Object OO = new Object();
                                            lock (OO)
                                            {
                                                if (Order == 1)
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                                }
                                                else//If Order is Brown.
                                                {
                                                    //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                                }
                                            }
                                        }


                                    }
                                }
                            }

                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //Do For Remaining Objects same as Soldeir Documentation.
                for (i = ElefantMidle; i < ElefantHigh; i++)
                {
                    for (int k = 0; k < AllDraw.ElefantMovments; k++)

                        for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[k] != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                            //   if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                            //       continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < ElephantOnTable[i].ElefantThinking[k].AStarGreedy.Count - 1; ij++)
                                    ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }


                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                    AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                    AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                    AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];


                                    Act = true;
                                    Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                RegardOccurred = true;
                                //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                //return TableHeuristic;
                                continue;
                            }
                            //When There is No Movments in Such Order Enemy continue.
                            if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                continue;
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                {

                                    //retrive table of current Heuristic.

                                    //if (CheckG || CheckB)
                                    //{
                                    //retrive table of current Heuristic.
                                    int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {

                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;

                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 2, CloneATable(TableS), Order, ElephantOnTable[i].ElefantThinking[k].Row, ElephantOnTable[i].ElefantThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        else
                                        {

                                        }


                                    }
                                    RW2 = i;
                                    CL2 = k;
                                    Ki2 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].NumberOfPenalties);
                                    MaxLess1 = -1;
                                    if (MaxLess2 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess2 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess2 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess2 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Elephant By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Elephant By Alice!");

                                            }
                                        }
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                            AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                            AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                            AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                        }

                                        Act = true;
                                        Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                        TableHeuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];

                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {

                                    if (AStarGreedyi == 1)
                                    {
                                        //TakeRoot.Pointer = this;
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxElephntFounded)
                                            continue;

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = ElephantOnTable[RW2].ElefantThinking[CL2].Row;
                                            AllDraw.LastColumn = ElephantOnTable[RW2].ElefantThinking[CL2].Column;
                                            AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                            AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                        }

                                        Act = true;
                                        Less = ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHeuristic(RW2, Ki2, Order, false, ref HaveKilled);
                                        TableHeuristic = ElephantOnTable[RW2].ElefantThinking[CL2].TableListElefant[Ki2];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                            }
                                        }
                                    }


                                }
                            }

                        }


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                for (i = HourseMidle; i < HourseHight; i++)
                {
                    for (int k = 0; k < AllDraw.HourseMovments; k++)

                        for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[k] != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                            //    if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                            //        continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < HoursesOnTable[i].HourseThinking[k].AStarGreedy.Count - 1; ij++)
                                    HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }


                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                    AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                    AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                    AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];


                                    Act = true;
                                    Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                RegardOccurred = true;
                                //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                //return TableHeuristic;
                                continue;
                            }

                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)

                                        continue;
                                //When There is greater Heuristic Movments.
                                if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                {

                                    //retrive table of current Heuristic.

                                    //retrive table of current Heuristic.
                                    int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                    {
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                        {

                                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                continue;


                                        }
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 3, CloneATable(TableS), Order, HoursesOnTable[i].HourseThinking[k].Row, HoursesOnTable[i].HourseThinking[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(TableS, Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            else
                                            {

                                            }
                                        }


                                    }
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = i;
                                    CL3 = k;
                                    Ki3 = j;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess3 = HoursesOnTable[RW3].HourseThinking[CL3].NumberOfPenalties;
                                    if (MaxLess3 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess3 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess3 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess3 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess3 > MaxLess6)
                                        MaxLess6 = -1;

                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Hourse By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Hourse By Alice!");

                                            }
                                        }
                                        //Set Table and Heuristic Value and Syntax.

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                            AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                            AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                            AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                        }

                                        Act = true;
                                        Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                        TableHeuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];

                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {

                                    if (AStarGreedyi == 1)
                                    {
                                        //TakeRoot.Pointer = this;
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxHourseFounded)
                                            continue;

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = HoursesOnTable[RW3].HourseThinking[CL3].Row;
                                            AllDraw.LastColumn = HoursesOnTable[RW3].HourseThinking[CL3].Column;
                                            AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                            AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                        }

                                        Act = true;
                                        Less = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHeuristic(RW3, Ki3, Order, false, ref HaveKilled);
                                        TableHeuristic = HoursesOnTable[RW3].HourseThinking[CL3].TableListHourse[Ki3];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                            }
                                        }
                                    }



                                }
                            }

                        }


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                for (i = CastleMidle; i < CastleHigh; i++)
                {
                    for (int k = 0; k < AllDraw.CastleMovments; k++)

                        for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[k] != null && CastlesOnTable[i].CastleThinking[k] != null && j < CastlesOnTable[i].CastleThinking[k].TableListCastle.Count; j++)
                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                            ///   if (CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() == 0)
                            //       continue;

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < CastlesOnTable[i].CastleThinking[k].AStarGreedy.Count - 1; ij++)
                                    CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }


                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if ((CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {

                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                    AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                    AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                    AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                    Act = true;
                                    Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                RegardOccurred = true;
                                //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                //return TableHeuristic;
                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlate)
                                    if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less)
                                {

                                    //retrive table of current Heuristic.
                                    //retrive table of current Heuristic.
                                    int[,] TableS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {

                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;


                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 4, CloneATable(TableS), Order, CastlesOnTable[i].CastleThinking[k].Row, CastlesOnTable[i].CastleThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        else
                                        {

                                        }

                                    }
                                    RW4 = i;
                                    CL4 = k;
                                    Ki4 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess4 = (CastlesOnTable[RW4].CastleThinking[CL4].NumberOfPenalties);
                                    if (MaxLess4 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess4 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess4 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess4 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess4 > MaxLess6)
                                        MaxLess6 = -1;

                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Castles By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Castles By Alice!");

                                            }
                                        }
                                        //Set Table and Heuristic Value and Syntax.

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                            AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                            AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                            AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                        }

                                        Act = true;
                                        Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                        TableHeuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];

                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {

                                    if (AStarGreedyi == 1)
                                    {
                                        //TakeRoot.Pointer = this;
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxCastlesFounded)
                                            continue;

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = CastlesOnTable[RW4].CastleThinking[CL4].Row;
                                            AllDraw.LastColumn = CastlesOnTable[RW4].CastleThinking[CL4].Column;
                                            AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                            AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                        }

                                        Act = true;
                                        Less = CastlesOnTable[RW4].CastleThinking[CL4].ReturnHeuristic(RW4, Ki4, Order, false, ref HaveKilled);
                                        TableHeuristic = CastlesOnTable[RW4].CastleThinking[CL4].TableListCastle[Ki4];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                            }
                                        }
                                    }


                                }
                            }

                        }


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }


                for (i = MinisterMidle; i < MinisterHigh; i++)
                {
                    for (int k = 0; k < AllDraw.MinisterMovments; k++)

                        for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[k] != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < MinisterOnTable[i].MinisterThinking[k].AStarGreedy.Count - 1; ij++)
                                    MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }


                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;

                            if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {

                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                    AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                    AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                    AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];


                                    Act = true;
                                    Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                RegardOccurred = true;

                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                        continue;


                                //When There is greater Heuristic Movments.
                                if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                //retrive table of current Heuristic.
                                {

                                    //retrive table of current Heuristic.
                                    int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {

                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;

                                    }
                                    //When there is not Penalty regard mechanism.

                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 5, CloneATable(TableS), Order, MinisterOnTable[i].MinisterThinking[k].Row, MinisterOnTable[i].MinisterThinking[k].Column);
                                    //If there is kish or kshachamaz Order.
                                    if (AB.Check(TableS, Order))
                                    {
                                        //When Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                            if (AB.CheckGray)
                                                continue;
                                        }
                                        else
                                        {
                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                            if (AB.CheckBrown)
                                                continue;
                                        }
                                    }

                                    RW5 = i;
                                    CL5 = k;
                                    Ki5 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].NumberOfPenalties);
                                    if (MaxLess5 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess5 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess5 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess5 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess5 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Minister By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Minister By Alice!");

                                            }
                                        }
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                            AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                            AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                            AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                        }

                                        Act = true;
                                        Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                        TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];

                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {

                                    if (AStarGreedyi == 1)
                                    {
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxMinisterFounded)
                                            continue;

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = MinisterOnTable[RW5].MinisterThinking[CL5].Row;
                                            AllDraw.LastColumn = MinisterOnTable[RW5].MinisterThinking[CL5].Column;
                                            AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                            AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                        }
                                        Act = true;
                                        Less = MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHeuristic(RW5, Ki5, Order, false, ref HaveKilled);
                                        TableHeuristic = MinisterOnTable[RW5].MinisterThinking[CL5].TableListMinister[Ki5];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                            }
                                        }
                                    }

                                }
                            }

                        }


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                for (i = KingMidle; i < KingHigh; i++)
                {
                    for (int k = 0; k < AllDraw.KingMovments; k++)

                        for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking[k] != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                        {

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < KingOnTable[i].KingThinking[k].AStarGreedy.Count - 1; ij++)
                                    KingOnTable[i].KingThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, KingOnTable[i].KingThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }


                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;

                            if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {

                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                    AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                    AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                    AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];


                                    Act = true;
                                    Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                RegardOccurred = true;

                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {

                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                        continue;


                                //When There is greater Heuristic Movments.
                                if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                //retrive table of current Heuristic.
                                {


                                    //retrive table of current Heuristic.
                                    int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {

                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;


                                    }
                                    //When there is not Penalty regard mechanism.

                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 6, CloneATable(TableS), Order, KingOnTable[i].KingThinking[k].Row, KingOnTable[i].KingThinking[k].Column);
                                    //If there is kish or kshachamaz Order.
                                    if (AB.Check(TableS, Order))
                                    {
                                        //When Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                            if (AB.CheckGray)
                                                continue;
                                        }
                                        else
                                        {
                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                            if (AB.CheckBrown)
                                                continue;
                                        }
                                    }



                                    RW6 = i;
                                    CL6 = k;
                                    Ki6 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].NumberOfPenalties);
                                    if (MaxLess6 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess6 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess6 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess6 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess6 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic King By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic King By Alice!");

                                            }
                                        }
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                            AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                            AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                            AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                        }

                                        Act = true;
                                        Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                        TableHeuristic = KingOnTable[i].KingThinking[k].TableListKing[j];

                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {

                                    if (AStarGreedyi == 1)
                                    {
                                        //TakeRoot.Pointer = this;
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        if (Founded[0] != 1)
                                            continue;
                                        RW6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxKingFounded)
                                            continue;

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = KingOnTable[RW6].KingThinking[CL6].Row;
                                            AllDraw.LastColumn = KingOnTable[RW6].KingThinking[CL6].Column;
                                            AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                            AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                        }

                                        Act = true;
                                        Less = KingOnTable[RW6].KingThinking[CL6].ReturnHeuristic(RW6, Ki6, Order, false, ref HaveKilled);
                                        TableHeuristic = KingOnTable[RW6].KingThinking[CL6].TableListKing[Ki6];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Bob!");

                                            }
                                            else//If Order is Brown.
                                            {
                                                //OutPut.Append("\r\nChess Heuristic Sodier By Alice!");

                                            }
                                        }
                                    }
                                }
                            }

                        }


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BrownHeuristicAStarGreaedySearchPenalites:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        //AStarGreedy First Heuristic Method.
        public int[,] HeuristicAStarGreedySearch(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] TableHeuristic = new int[8, 8];

                AStarGreedyi++;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //Initiate For Dynamic Backward Current AStarGreedyi Non Minus Founded Max Movments Detection Global Variables.
                List<int> Founded = new List<int>();
                //Initiateing Indicating Heuristic Multiple Same Value Best Found of Movments.
                MaxLess1 = -1;
                MaxLess2 = -1;
                MaxLess3 = -1;
                MaxLess4 = -1;
                MaxLess5 = -1;
                MaxLess6 = -1;
                RW1 = -1;
                CL1 = -1;
                Ki1 = -1;
                RW2 = -1;
                CL2 = -1;
                Ki2 = -1;
                RW3 = -1;
                CL3 = -1;
                Ki3 = -1;
                RW4 = -1;
                CL4 = -1;
                Ki4 = -1;
                RW5 = -1;
                CL5 = -1;
                Ki5 = -1;
                RW6 = -1;
                CL6 = -1;
                Ki6 = -1;

                int[] BacWard = new int[25];
                Object Omm = new Object();
                lock (Omm)
                {

                    if (AStarGreedyi > MaxAStarGreedy)
                        return TableHeuristic;
                }
                bool Act = false;

                if (Order == 1)
                {
                    TableHeuristic = HeuristicAStarGreadySearchGray(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                else
                {
                    TableHeuristic = HeuristicAStarGreadySearchBrown(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Store In Local Variable and Dynamic Purpose Proccessing.
                //Every Non Minuse Non Idept in List Has Gretest Max Order.
                //Is Desired of Idept Oner Best Movments.
                BacWard[0] = AStarGreedyi;

                BacWard[1] = MaxLess1;
                BacWard[2] = RW1;
                BacWard[3] = RW1;
                BacWard[4] = Ki1;


                BacWard[5] = MaxLess2;
                BacWard[6] = RW2;
                BacWard[7] = RW2;
                BacWard[8] = Ki2;

                BacWard[9] = MaxLess3;
                BacWard[10] = RW3;
                BacWard[11] = RW3;
                BacWard[12] = Ki3;

                BacWard[13] = MaxLess4;
                BacWard[14] = RW4;
                BacWard[15] = RW4;
                BacWard[16] = Ki4;

                BacWard[17] = MaxLess5;
                BacWard[18] = RW5;
                BacWard[19] = RW5;
                BacWard[20] = Ki5;

                BacWard[21] = MaxLess6;
                BacWard[22] = RW6;
                BacWard[23] = RW6;
                BacWard[24] = Ki6;

                //We Have Information of Maximum of Heuristic in Each Level and Table.
                MaxHeuristicAStarGreedytBackWard.Add(BacWard);
                MaxHeuristicAStarGreedytBackWardTable.Add(TableHeuristic);

                Founded.Clear();
                //If Found retrun table.
                if (Act)
                    return TableHeuristic;
                //Return what found table.
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreedySearch:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHeuristic;
            }
        }
        public int[,] HeuristicAStarGreedySearchPenalties(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] TableHeuristic = new int[8, 8];

                AStarGreedyi++;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //Initiate For Dynamic Backward Current AStarGreedyi Non Minus Founded Max Movments Detection Global Variables.
                List<int> Founded = new List<int>();
                //Initiateing Indicating Heuristic Multiple Same Value Best Found of Movments.
                MaxLess1 = -1;
                MaxLess2 = -1;
                MaxLess3 = -1;
                MaxLess4 = -1;
                MaxLess5 = -1;
                MaxLess6 = -1;
                RW1 = -1;
                CL1 = -1;
                Ki1 = -1;
                RW2 = -1;
                CL2 = -1;
                Ki2 = -1;
                RW3 = -1;
                CL3 = -1;
                Ki3 = -1;
                RW4 = -1;
                CL4 = -1;
                Ki4 = -1;
                RW5 = -1;
                CL5 = -1;
                Ki5 = -1;
                RW6 = -1;
                CL6 = -1;
                Ki6 = -1;

                int[] BacWard = new int[25];
                Object Omm = new Object();
                lock (Omm)
                {
                    if (AStarGreedyi > MaxAStarGreedy)
                        return TableHeuristic;
                }
                bool Act = false;
                if (Order == 1)
                {
                    TableHeuristic = HeuristicAStarGreadySearchPenalties(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }
                else
                {
                    TableHeuristic = BrownHeuristicAStarGreaedySearchPenalites(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Store In Local Variable and Dynamic Purpose Proccessing.
                //Every Non Minuse Non Idept in List Has Gretest Max Order.
                //Is Desired of Idept Oner Best Movments.
                BacWard[0] = AStarGreedyi;

                BacWard[1] = MaxLess1;
                BacWard[2] = RW1;
                BacWard[3] = RW1;
                BacWard[4] = Ki1;


                BacWard[5] = MaxLess2;
                BacWard[6] = RW2;
                BacWard[7] = RW2;
                BacWard[8] = Ki2;

                BacWard[9] = MaxLess3;
                BacWard[10] = RW3;
                BacWard[11] = RW3;
                BacWard[12] = Ki3;

                BacWard[13] = MaxLess4;
                BacWard[14] = RW4;
                BacWard[15] = RW4;
                BacWard[16] = Ki4;

                BacWard[17] = MaxLess5;
                BacWard[18] = RW5;
                BacWard[19] = RW5;
                BacWard[20] = Ki5;

                BacWard[21] = MaxLess6;
                BacWard[22] = RW6;
                BacWard[23] = RW6;
                BacWard[24] = Ki6;

                //We Have Information of Maximum of Heuristic in Each Level and Table.
                MaxHeuristicAStarGreedytBackWard.Add(BacWard);
                MaxHeuristicAStarGreedytBackWardTable.Add(TableHeuristic);

                Founded.Clear();
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("HeuristicAStarGreedySearchPenalties:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                //If Found retrun table.
                if (Act)
                    return TableHeuristic;
                //Return what found table.
                return TableHeuristic;
            }
        }
        //Genethic Algorithm Game Method.
        public void InitiateGenetic(int ii, int jj, Color a, int[,] Table, int Order, bool TB)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Initiate Local and Global Variables.
                int Current = ChessRules.CurrentOrder;
                int DummyOrder = Order;

                TableList.Add(CloneATable(Table));


                Object OO = new Object();
                lock (OO)
                {
                    ThinkingChess.NotSolvedKingDanger = false;
                }
                LoopHeuristicIndex = 0;
                //For One time.
                for (var i = 0; i < 1; i++)
                {
                    //If Order is Gray.
                    Object O2 = new Object();
                    lock (O2)
                    {
                        if (Order == 1)
                        {
                            //OutPut.Append("\r\nChess Genetic By Bob!");

                        }
                        else//If Order is Brown.
                        {
                            //OutPut.Append("\r\nChess Genetic By Alice!");


                        }
                    }
                    //Initiate Local Variables.
                    int[,] TablInit = new int[8, 8];
                    if (Order == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    int In = 0;
                    //Found Of Random Movments.
                    do
                    {
                        if (Order == 1)
                            In = (new System.Random()).Next(0, 8);
                        else
                            In = (new System.Random()).Next(8, 16);
                    } while (SolderesOnTable[In] == null);


                    //If Order is Gray.
                    Object OOO = new Object();
                    lock (OOO)
                    {
                        if (Order == 1)
                        {
                            //OutPut.Append("\r\nGenetic Algorithm Begin AStarGreedy " + i.ToString() + " By Bob!");

                        }
                        else//If Order is Brown.
                        {
                            //OutPut.Append("\r\nGenetic Algirithm Begin AStarGreedy " + i.ToString() + " By Alice!");


                        }
                    }
                    //Found Of Genetic Algorithm Movments By GeneticAlgorithm Call Objectsand Method.
                    ChessGeneticAlgorithm R = (new ChessGeneticAlgorithm(MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    //Found Table.
                    int[,] Tab = R.GenerateTable(TableListAction, 0, Order);
                    //If Order is Gray.
                    Object OOO1 = new Object();
                    lock (OOO1)
                    {
                        if (Order == 1)
                        {
                            //OutPut.Append("\r\nGenetic Algorithm Finsished AStarGreedy " + i.ToString() + " By Bob!");

                        }
                        else//If Order is Brown.
                        {
                            //OutPut.Append("\r\nGenetic Algirithm Finished AStarGreedy " + i.ToString() + " By Alice!");


                        }
                    }

                    //If Table Found.
                    if (Tab != null)
                    {
                        //Construct a Clone Copy of Table.
                        for (var iii = 0; iii < 8; iii++)
                            for (var jjj = 0; jjj < 8; jjj++)
                            {
                                TablInit[iii, jjj] = Tab[iii, jjj];
                            }
                        //Initiate a Table.
                        Table = new int[8, 8];
                        //Construct a Clone Copy of Table.
                        for (var iii = 0; iii < 8; iii++)
                            for (var jjj = 0; jjj < 8; jjj++)
                            {
                                Table[iii, jjj] = TablInit[iii, jjj];
                            }
                        //Initiate Local and Global Varibales.
                        TableList.Add(CloneATable(TablInit));
                        ClList.Add(CL);
                        RWList.Add(RW);
                        KiList.Add(Ki);
                        // Order = Order * -1;
                        // ChessRules.CurrentOrder = Order;
                        AStarGreedy++;
                        //return;

                    }
                }
            //Determination of CheckMate Consideration.
            (new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(Table), Order, -1, -1)).CheckMate(CloneATable(Table), Order);

                //Reconstruction of Order Global Varibales.
                Order = DummyOrder;
                ChessRules.CurrentOrder = Current;

                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateGenetic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            }
        }
        //AStarGreedy First Initiat Thinking Main Method.
        public AllDraw InitiateAStarGreedytOneNode(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, int iIndex, int KindIndex, int LeafAStarGreedy
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            {
                SetObjectNumbers(Tab);
                //List<Task> tHA = new List<Task>();
                int[,] Table = new int[8, 8];
                for (var iii = 0; iii < 8; iii++)
                    for (var jjj = 0; jjj < 8; jjj++)
                        Table[iii, jjj] = Tab[iii, jjj];

                Object O = new Object();
                lock (O)
                {
                    ThinkingChess.BeginThread = 0;
                    ThinkingChess.EndThread = 0;
                }
                //Initiate of global Variables Byte Local Variables.
                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;

                int[,] TablInit = new int[8, 8];
                if (Order == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                var j = 0;
                Object Omm = new Object();
                lock (Omm)
                {
                    if (iAStarGreedy >= MaxAStarGreedy)
                        return null;
                }

                //iAStarGreedy++;




                //If Order is Gray.
                if (Order == 1)
                {
                    //For Gray Soldeirs Objects. 
                    //                    for (i = 0; i < SodierMidle; i++)
                    if (KindIndex == 1)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //If Solders Not Exist Continue and Traversal Back.
                        //If There is no Thinking Movments on Current Object  


                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {
                            //Thinking of Gray Solder Operation.
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                            SolderesOnTable[iIndex].SoldierThinking[0].Thinking(iAStarGreedy, this, ref SolderesOnTable[iIndex].LoseOcuuredatChiled, ref SolderesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                            SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }*/
                        }
                        else if (ASS)
                        //If There is A Soldeir Movments.                                   
                        {

                            //Thinking of Gray Soldeir Operations.
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                            SolderesOnTable[iIndex].SoldierThinking[0].Thinking(iAStarGreedy, this, ref SolderesOnTable[iIndex].LoseOcuuredatChiled, ref SolderesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                            SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }*/
                        }

                    }
                    //Progressing.
                    //For All Gray Elephant Objects.

                    if (KindIndex == 2)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //Ignore of Non Exist Current Elephant Gray Objects.
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {
                            //Operational Thinking Gray Elephant. 
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                            ElephantOnTable[iIndex].ElefantThinking[0].Thinking(iAStarGreedy, this, ref ElephantOnTable[iIndex].LoseOcuuredatChiled, ref ElephantOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                            ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }*/
                        }//If There is Movment Thinking Gary Elphant Object List.
                        else if (ASS)
                        {
                            //For Every Gray Elephant Thinking Movments.
                            //Gray Elephant Object Thinking Operations.
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                            ElephantOnTable[iIndex].ElefantThinking[0].Thinking(iAStarGreedy, this, ref ElephantOnTable[iIndex].LoseOcuuredatChiled, ref ElephantOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                            ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }*/
                        }

                    }
                    //Progressing.

                    //For All Gray Hourse Objects.
                    if (KindIndex == 3)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {
                            //Thinking of Gray Hourse Oprational.
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                            HoursesOnTable[iIndex].HourseThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                            HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt)
                                                { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }*/
                        }
                        else if (ASS)//If Table List Exist int The Thinking.
                        {

                            //Thinking Operation of Gray Hourse.
                            HoursesOnTable[iIndex].HourseThinking[0].TableT = HoursesOnTable[iIndex].HourseThinking[0].TableListHourse[j];
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                            HoursesOnTable[iIndex].HourseThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                            HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }*/
                        }

                    }
                    //Progressing.


                    if (KindIndex == 4)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {
                            //When There is Possible Thinking Castle of Gray Table
                            //Thinking of Gray Castles Operational.
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                            CastlesOnTable[iIndex].CastleThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[iIndex].LoseOcuuredatChiled, ref CastlesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(CastlesOnTable[iIndex].CastleThinking[0].Thinking));
                                            CastlesOnTable[iIndex].CastleThinking[0].t.Start();
                                            if (CastlesOnTable[iIndex].CastleThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(CastlesOnTable[iIndex].CastleThinking[0].t); } }*/

                        }
                        else if (ASS)
                        {
                            //When There is Possible Thinking Castle of Gray Table
                            //Thinking of Gray Castles  Objective Movments.
                            CastlesOnTable[iIndex].CastleThinking[0].TableT = CastlesOnTable[iIndex].CastleThinking[0].TableListCastle[j];
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                            CastlesOnTable[iIndex].CastleThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[iIndex].LoseOcuuredatChiled, ref CastlesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(CastlesOnTable[iIndex].CastleThinking[0].Thinking));
                                            CastlesOnTable[iIndex].CastleThinking[0].t.Start();
                                            if (CastlesOnTable[iIndex].CastleThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(CastlesOnTable[iIndex].CastleThinking[0].t); } }*/
                        }

                    }
                    if (KindIndex == 5)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Table Gray Minister Count of Thinking.
                         //Thinking of Gray Minister Operational.
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                            MinisterOnTable[iIndex].MinisterThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                            MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }*/
                        }
                        else if (ASS)//When There is Table Gray Minister Count of Thinking.
                        {
                            //Thinking.
                            MinisterOnTable[iIndex].Table = MinisterOnTable[iIndex].MinisterThinking[0].TableListMinister[j];
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                            MinisterOnTable[iIndex].MinisterThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                            MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }*/
                        }

                    }

                    if (KindIndex == 6)
                    {


                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When Thinking Gray King Count of Existing Operations.
                         //Thinking Of Gray King Operatins.
                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                            KingOnTable[iIndex].KingThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                            KingOnTable[iIndex].KingThinking[0].t.Start();
                                            if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }*/
                        }
                        else if (ASS)//When Thinking Gray King Count of Existing Operations.
                        {
                            //Gray King Thinking Operations.                                        
                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                            KingOnTable[iIndex].KingThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                            KingOnTable[iIndex].KingThinking[0].t.Start();
                                            if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }*/
                        }

                    }
                }
                else//Brown Order Considarations.
                {

                    if (KindIndex == -1)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Wheen Brown King Object There is Not Continue Traversal Back.
                            //Thinking Operations of Brown Current Objects.
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                            SolderesOnTable[iIndex].SoldierThinking[0].Thinking(iAStarGreedy, this, ref SolderesOnTable[iIndex].LoseOcuuredatChiled, ref SolderesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                            SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }*/

                        }

                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Thinking of Thinking Brown CurrentTable Objective Operations.
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                            SolderesOnTable[iIndex].SoldierThinking[0].Thinking(iAStarGreedy, this, ref SolderesOnTable[iIndex].LoseOcuuredatChiled, ref SolderesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                            SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }*/

                        }

                    }
                    if (KindIndex == -2)
                    {

                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Current Brown Existing Objective Thinking Movments.
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                            //Thinking Operations of Brown Current Objects.
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                            ElephantOnTable[iIndex].ElefantThinking[0].Thinking(iAStarGreedy, this, ref ElephantOnTable[iIndex].LoseOcuuredatChiled, ref ElephantOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                            ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }*/
                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                            //Thinking of Thinking Brown CurrentTable Objective Operations.                                                   
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                            ElephantOnTable[iIndex].ElefantThinking[0].Thinking(iAStarGreedy, this, ref ElephantOnTable[iIndex].LoseOcuuredatChiled, ref ElephantOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                            ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }*/
                        }

                    }


                    if (KindIndex == -3)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Current Brown Existing Objective Thinking Movments.
                         //Thinking Operations of Brown Current Objects.
                         //HoursesOnTable[iIndex].HourseThinking[0].TableT = HoursesOnTable[iIndex].HourseThinking[0].TableT;
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                            HoursesOnTable[iIndex].HourseThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                            HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }*/

                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Thinking of Thinking Brown CurrentTable Objective Operations.                                          SolderesOnTable[iIndex].SoldierThinking[0].Table = SolderesOnTable[iIndex].SoldierThinking[0].TableListSolder[j];
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                            HoursesOnTable[iIndex].HourseThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                            HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt)
                                                    { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }*/


                        }

                    }
                    //Progressing.




                    if (KindIndex == -4)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Current Brown Existing Objective Thinking Movments.
                         //Thinking Operations of Brown Current Objects.
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                            CastlesOnTable[iIndex].CastleThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[iIndex].LoseOcuuredatChiled, ref CastlesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(CastlesOnTable[iIndex].CastleThinking[0].Thinking));
                                            CastlesOnTable[iIndex].CastleThinking[0].t.Start();
                                            if (CastlesOnTable[iIndex].CastleThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(CastlesOnTable[iIndex].CastleThinking[0].t); } }*/
                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Thinking of Thinking Brown CurrentTable Objective Operations.        
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                            CastlesOnTable[iIndex].CastleThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[iIndex].LoseOcuuredatChiled, ref CastlesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(CastlesOnTable[iIndex].CastleThinking[0].Thinking));
                                            CastlesOnTable[iIndex].CastleThinking[0].t.Start();
                                            if (CastlesOnTable[iIndex].CastleThinking[0].t != null) { Object tttt = new Object(); lock (tttt)
                                                    { tH.Add(CastlesOnTable[iIndex].CastleThinking[0].t); } }*/
                        }

                    }

                    if (KindIndex == -5)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Current Brown Existing Objective Thinking Movments.
                         //Thinking Operations of Brown Current Objects.
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                            MinisterOnTable[iIndex].MinisterThinking[0].Thinking(iAStarGreedy, this, ref MinisterOnTable[iIndex].LoseOcuuredatChiled, ref MinisterOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                            MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt)
                                                { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }*/
                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Thinking of Thinking Brown CurrentTable Objective Operations.                                          SolderesOnTable[iIndex].SoldierThinking[0].Table = SolderesOnTable[iIndex].SoldierThinking[0].TableListSolder[j];
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                            MinisterOnTable[iIndex].MinisterThinking[0].Thinking(iAStarGreedy, this, ref MinisterOnTable[iIndex].LoseOcuuredatChiled, ref MinisterOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                            MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }*/

                        }

                    }
                    //Progressing.

                    if (KindIndex == -6)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Current Brown Existing Objective Thinking Movments.
                         //Thinking Operations of Brown Current Objects.
                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                            KingOnTable[iIndex].KingThinking[0].Thinking(iAStarGreedy, this, ref KingOnTable[iIndex].LoseOcuuredatChiled, ref KingOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                            KingOnTable[iIndex].KingThinking[0].t.Start();
                                            if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }*/

                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Thinking of Thinking Brown CurrentTable Objective Operations.       
                            KingOnTable[iIndex].KingThinking[0].TableT = KingOnTable[iIndex].KingThinking[0].TableListKing[j];
                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                            KingOnTable[iIndex].KingThinking[0].Thinking(iAStarGreedy, this, ref KingOnTable[iIndex].LoseOcuuredatChiled, ref KingOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                            KingOnTable[iIndex].KingThinking[0].t.Start();
                                            if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }*/


                        }


                    }

                    //IncreaseprogressBarRefregitzValue(THIS.progressBarVerify, increasedProgress);
                    //THIS.progressBarVerify.Invalidate();
                    //SetprogressBarUpdate(THIS.progressBarVerify);

                }







                bool FOUND = false;
                if (KindIndex == 1 || KindIndex == -1)
                {
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                    if (KindIndex == 2 || KindIndex == -2)
                {
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                        if (KindIndex == 3 || KindIndex == -3)
                {
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                            if (KindIndex == 4 || KindIndex == -4)
                {
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                                if (KindIndex == 5 || KindIndex == -5)
                {
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                                    if (KindIndex == 6 || KindIndex == -6)
                {
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                //                } 
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytOneNode:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                return this;
            }
        }
        //gray index objects max count
        int MaxGrayMidle()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[] Tab = new int[6];
                Tab[0] = SodierMidle;
                Tab[1] = ElefantMidle;
                Tab[2] = HourseMidle;
                Tab[3] = CastleMidle;
                Tab[4] = MinisterMidle;
                Tab[5] = KingMidle;
                int Max = 0;
                for (var i = 0; i < 6; i++)
                {
                    if (Tab[i] > Max)
                        Max = Tab[i];
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("MaxGrayMidle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Max;
            }
        }
        //brown index objects max count
        int MaxBrownHigh()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object O = new Object();
            lock (O)
            {
                int[] Tab = new int[6];
                Tab[0] = SodierHigh;
                Tab[1] = ElefantHigh;
                Tab[2] = HourseHight;
                Tab[3] = CastleHigh;
                Tab[4] = MinisterHigh;
                Tab[5] = KingHigh;
                int Max = 0;
                for (var i = 0; i < 6; i++)
                {
                    if (Tab[i] > Max)
                        Max = Tab[i];
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("MaxBrownHigh:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Max;
            }
        }
        //gray index objects min count
        int MinBrownMidle()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int[] Tab = new int[6];
                Tab[0] = SodierHigh;
                Tab[1] = ElefantHigh;
                Tab[2] = HourseHight;
                Tab[3] = CastleHigh;
                Tab[4] = MinisterHigh;
                Tab[5] = KingHigh;
                int Min = MaxBrownHigh();
                for (var i = 0; i < 6; i++)
                {
                    if (Tab[i] < Min)
                        Min = Tab[i];
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("MinBrownMidle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Min;
            }
        }
        //gray object initiation second method
        AllDraw InitiateAStarGreedytObjectGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy //, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                for (var i = 0; i < MaxGrayMidle(); i++)
                {
                    //Parallel.Invoke(() =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (SodierMidle > i)
                            {
                                Object O = new Object();
                                lock (O)
                                {

                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //If Solders Not Exist Continue and Traversal Back.
                                    if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                    {
                                        //Initiate of Local Variables By Global Objective Gray Current Solder.
                                        int ik = (int)SolderesOnTable[i].Row;
                                        int jk = (int)SolderesOnTable[i].Column;
                                        //Construction of Thinking Gray Soldier By Local Variables.

                                        //If There is no Thinking Movments on Current Object  

                                        if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                        {
                                            //For All Movable Gray Solders.
                                            for (var j = 0; j < AllDraw.SodierMovments; j++)
                                            ////Parallel.For(0, AllDraw.SodierMovments, j =>
                                            {
                                                //Thinking of Gray Solder Operation.
                                                Object OOO = new Object();
                                                lock (OOO)
                                                {
                                                    SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                                    SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                                    SolderesOnTable[i].SoldierThinking[0].Kind = 1;
                                                    SolderesOnTable[i].SoldierThinking[j].Thinking(iAStarGreedy, this, ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled);


                                                }
                                            }//);
                                        }
                                    }

                                }
                            }
                        }
                    }//,
                    // () =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (MinisterMidle > i)
                            {


                                Object O = new Object();
                                lock (O)
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //For Each Non Exist Gray Minister Objectives.
                                    if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                    {
                                        //Inititate Local Variables By Global Varibales.
                                        int ik = (int)MinisterOnTable[i].Row;
                                        int jk = (int)MinisterOnTable[i].Column;
                                        //Construction of Thinking Objects Gray Minister.

                                        //If There is Not Minister Of Gray In The Thinking Table List.   
                                        if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                        {
                                            //For All Possible Movments.
                                            for (var j = 0; j < AllDraw.MinisterMovments; j++)
                                            ////Parallel.For(0, AllDraw.MinisterMovments, j =>
                                            {
                                                //Thinking of Gray Minister Operational.
                                                Object OOO = new Object();
                                                lock (OOO)
                                                {
                                                    MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                                    MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                                    MinisterOnTable[i].MinisterThinking[0].Kind = 5;
                                                    MinisterOnTable[i].MinisterThinking[0].Thinking(iAStarGreedy, this, ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled);
                                                }
                                            }//);
                                        }
                                    }
                                }

                            }
                        }
                    }//,
                     //() =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {

                            if (KingMidle > i)
                            {


                                Object O = new Object();
                                lock (O)
                                {

                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //If There is Not Current Object Continue Traversal Back.
                                    if (KingOnTable != null && KingOnTable[i] != null)
                                    {
                                        //Initiate Local varibale By Global Objective Varibales.
                                        int ik = (int)(int)KingOnTable[i].Row;
                                        int jk = (int)KingOnTable[i].Column;
                                        //Construction of Gray King Thinking Objects.

                                        //When There is Not Thinking Table Gray King Movments.
                                        if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                        {
                                            //For All Possible Gray King Movments.
                                            ////Parallel.For(0, AllDraw.KingMovments, j =>
                                            for (var j = 0; j < AllDraw.KingMovments; j++)
                                            {
                                                //Thinking Of Gray King Operatins.
                                                Object OOO = new Object();
                                                lock (OOO)
                                                {
                                                    KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                                    KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                                    KingOnTable[i].KingThinking[0].Kind = 6;
                                                    KingOnTable[i].KingThinking[0].Thinking(iAStarGreedy, this, ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled);

                                                }
                                            }//);
                                        }
                                    }

                                }
                            }
                        }
                    }//);
                }//);
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytObjectGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedytObjectBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                ////Parallel.For(MinBrownMidle(), MaxBrownHigh(), i =>
                for (var i = MinBrownMidle(); i < MaxBrownHigh(); i++)
                {

                    //Parallel.Invoke(() =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (SodierMidle <= i && SodierHigh > i)
                            {
                                Object O = new Object();
                                lock (O)
                                {

                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //If Solders Not Exist Continue and Traversal Back.
                                    if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                    {
                                        //Initiate of Local Variables By Global Objective Gray Current Solder.
                                        int ik = (int)SolderesOnTable[i].Row;
                                        int jk = (int)SolderesOnTable[i].Column;
                                        //Construction of Thinking Gray Soldier By Local Variables.

                                        //If There is no Thinking Movments on Current Object  

                                        if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                        {
                                            //For All Movable Gray Solders.
                                            for (var j = 0; j < AllDraw.SodierMovments; j++)
                                            ////Parallel.For(0, AllDraw.SodierMovments, j =>
                                            {
                                                //Thinking of Gray Solder Operation.
                                                Object OOO = new Object();
                                                lock (OOO)
                                                {
                                                    SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                                    SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                                    SolderesOnTable[i].SoldierThinking[0].Kind = 1;
                                                    SolderesOnTable[i].SoldierThinking[0].Thinking(iAStarGreedy, this, ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled);
                                                }
                                            }//);
                                        }
                                    }

                                }
                            }
                        }
                    }//,() =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {

                            if (ElefantMidle <= i && ElefantHigh > i)
                            {

                                Object O = new Object();
                                lock (O)
                                {

                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //Ignore of Non Exist Current Elephant Gray Objects.
                                    if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                    {
                                        //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                                        int ik = (int)ElephantOnTable[i].Row;
                                        int jk = (int)ElephantOnTable[i].Column;
                                        //Construction of Thinking Objects By Local Varibales.

                                        //If There is Not Thinking Objetive List Elephant Gray. 
                                        if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                        {
                                            //For All Possible Movments.
                                            ////Parallel.For(0, AllDraw.ElefantMovments, j =>
                                            for (var j = 0; j < AllDraw.ElefantMovments; j++)
                                            {
                                                //Operational Thinking Gray Elephant. 
                                                Object OOO = new Object();
                                                lock (OOO)
                                                {
                                                    ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                                    ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                                    ElephantOnTable[i].ElefantThinking[0].Kind = 2;
                                                    ElephantOnTable[i].ElefantThinking[0].Thinking(iAStarGreedy, this, ref ElephantOnTable[i].LoseOcuuredatChiled, ref ElephantOnTable[i].WinOcuuredatChiled);
                                                }
                                            }//);
                                        }
                                    }

                                }
                            }
                        }
                    }//,() =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {

                            if (HourseMidle <= i && HourseHight > i)
                            {

                                Object O = new Object();
                                lock (O)
                                {

                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //Ignore of Non Exist Current Gray Hourse Objects.
                                    if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                    {
                                        //Initiate of Local Variables By Global Gray Hourse Objectives.
                                        int ik = (int)HoursesOnTable[i].Row;
                                        int jk = (int)HoursesOnTable[i].Column;
                                        //Construction of Gray Hourse Thinking Objects..

                                        //When There is Not HourseList Count. 
                                        if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                        {
                                            //For All Possible Movments.
                                            for (var j = 0; j < AllDraw.HourseMovments; j++)
                                            ////Parallel.For(0, AllDraw.HourseMovments, j =>
                                            {
                                                //Thinking of Gray Hourse Oprational.
                                                Object OOO = new Object();
                                                lock (OOO)
                                                {
                                                    HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                                    HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                                    HoursesOnTable[i].HourseThinking[0].Kind = 3;
                                                    HoursesOnTable[i].HourseThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[i].LoseOcuuredatChiled, ref HoursesOnTable[i].WinOcuuredatChiled);
                                                }
                                            }//);
                                        }
                                    }

                                }
                            }
                        }

                    }//,() =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {

                            if (CastleMidle <= i && CastleHigh < i)
                            {
                                Object O = new Object();
                                lock (O)
                                {

                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //When Current Castles Gray Not Exist Continue Traversal Back.
                                    if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                    {
                                        //Initaiate of Local Varibales By Global Varoiables.
                                        int ik = (int)CastlesOnTable[i].Row;
                                        int jk = (int)CastlesOnTable[i].Column;
                                        //Construction of Thinking Variables By Local Variables.

                                        //When Count of Table Castles of Thinking Not Exist Do Operational.
                                        if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                                        {
                                            //For All Possible Movments.
                                            ////Parallel.For(0, AllDraw.CastleMovments, j =>
                                            for (var j = 0; j < AllDraw.CastleMovments; j++)
                                            {
                                                Object OOO = new Object();
                                                lock (OOO)
                                                {
                                                    //Thinking of Gray Castles Operational.
                                                    CastlesOnTable[i].CastleThinking[0].ThinkingBegin = true;
                                                    CastlesOnTable[i].CastleThinking[0].ThinkingFinished = false;
                                                    CastlesOnTable[i].CastleThinking[0].Kind = 4;
                                                    CastlesOnTable[i].CastleThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);
                                                }
                                            }//);
                                        }
                                    }

                                }
                            }
                        }
                    }//,() =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {



                            if (MinisterMidle <= i && MinisterHigh > i)
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //For Each Non Exist Gray Minister Objectives.
                                    if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                    {
                                        //Inititate Local Variables By Global Varibales.
                                        int ik = (int)MinisterOnTable[i].Row;
                                        int jk = (int)MinisterOnTable[i].Column;
                                        //Construction of Thinking Objects Gray Minister.

                                        //If There is Not Minister Of Gray In The Thinking Table List.   
                                        if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                        {
                                            //For All Possible Movments.
                                            ////Parallel.For(0, AllDraw.MinisterMovments, j =>
                                            for (var j = 0; j < AllDraw.MinisterMovments; j++)
                                            {
                                                //Thinking of Gray Minister Operational.
                                                Object OOO = new Object();
                                                lock (OOO)
                                                {
                                                    MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                                    MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                                    MinisterOnTable[i].MinisterThinking[0].Kind = 5;
                                                    MinisterOnTable[i].MinisterThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);
                                                }
                                            }//);
                                        }
                                    }
                                }
                            }

                        }

                    }//,
                    // () =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {
                            if (KingMidle <= i && KingHigh > i)
                            {
                                Object O = new Object();
                                lock (O)
                                {

                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //If There is Not Current Object Continue Traversal Back.
                                    if (KingOnTable != null && KingOnTable[i] != null)
                                    {
                                        //Initiate Local varibale By Global Objective Varibales.
                                        int ik = (int)(int)KingOnTable[i].Row;
                                        int jk = (int)KingOnTable[i].Column;
                                        //Construction of Gray King Thinking Objects.

                                        //When There is Not Thinking Table Gray King Movments.
                                        if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                        {
                                            //For All Possible Gray King Movments.
                                            for (var j = 0; j < AllDraw.KingMovments; j++)
                                            {
                                                //Thinking Of Gray King Operatins.
                                                Object OOO = new Object();
                                                lock (OOO)
                                                {
                                                    KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                                    KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                                    KingOnTable[i].KingThinking[0].Kind = 6;
                                                    KingOnTable[i].KingThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);
                                                }
                                            }//);
                                        }
                                    }

                                }
                            }
                        }
                    }//);

                }//);
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytObjectBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //return index of table state index at list
        int FoundTableIndex(List<int[,]> T, int[,] TAab)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int C = -1;
            for (var i = 0; i < T.Count; i++)
            {
                if (TableEqual(T[i], TAab))
                    C = i;
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundTableIndex:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return C;
        }
        //when tatow table is not equal
        bool TableEqual(int[,] t1, int[,] t2)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Is = true;
            for (var i = 0; i < 8; i++)
                for (var j = 0; j < 8; j++)
                {
                    if (t1[i, j] != t2[i, j])
                        Is = false;
                }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("TableEqual:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Is;
        }
        //support of objects by self object regard by values named served
        void Serve(int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //gray
            if (Order == 1)
            {
                //sodier
                for (var i = 0; i < SodierMidle; i++)
                {
                    if (SolderesOnTable == null || SolderesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 1, i);
                }
                //elephant
                for (var i = 0; i < ElefantMidle; i++)
                {
                    if (ElephantOnTable == null || ElephantOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 2, i);
                }
                //hourse
                for (var i = 0; i < HourseMidle; i++)
                {
                    if (HoursesOnTable == null || HoursesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 3, i);
                }
                //Castle
                for (var i = 0; i < CastleMidle; i++)
                {
                    if (CastlesOnTable == null || CastlesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 4, i);
                }
                //minister
                for (var i = 0; i < MinisterMidle; i++)
                {
                    if (MinisterOnTable == null || MinisterOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 5, i);
                }
                //king
                for (var i = 0; i < KingMidle; i++)
                {
                    if (KingOnTable == null || KingOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 6, i);
                }

            }//brown
            else
            {   //soldier
                for (var i = SodierMidle; i < SodierHigh; i++)
                {
                    if (SolderesOnTable == null || SolderesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 1, i);
                }
                //elephant
                for (var i = ElefantMidle; i < ElefantHigh; i++)
                {
                    if (ElephantOnTable == null || ElephantOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 2, i);
                }
                ///hourse
                for (var i = HourseMidle; i < HourseHight; i++)
                {
                    if (HoursesOnTable == null || HoursesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 3, i);
                }
                //Castle
                for (var i = CastleMidle; i < CastleHigh; i++)
                {
                    if (CastlesOnTable == null || CastlesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 4, i);
                }
                //minister
                for (var i = MinisterMidle; i < MinisterHigh; i++)
                {
                    if (MinisterOnTable == null || MinisterOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 5, i);
                }
                //king
                for (var i = KingMidle; i < KingHigh; i++)
                {
                    if (KingOnTable == null || KingOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 6, i);
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("Serve:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        //served mechaisam core
        void ServeISSup(int Order, int Kind,
                int ii
               )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //soldoer
            if (Kind == 1)
            {
                //gray
                if (Order == 1)
                {
                    //soldier
                    for (var i = 0; i < SodierMidle; i++)
                    {
                        if (SolderesOnTable == null || SolderesOnTable[i] == null)
                            continue;

                        for (var j = 0; j < SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Count; j++)
                        {
                            if (!(SolderesOnTable[i].SoldierThinking[0].IsSup[j]))
                                continue;


                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][0] += SolderesOnTable[ii].SoldierThinking[0].HeuristicAttackValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][1] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][2] += SolderesOnTable[ii].SoldierThinking[0].HeuristicSelfSupportedValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][3] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][4] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedSupportSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][5] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedAttackValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][6] += SolderesOnTable[ii].SoldierThinking[0].HeuristicDistributionValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][7] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][8] += SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][9] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup;
                            SolderesOnTable[i].SoldierThinking[0].IsSup[j] = false;

                            //AllDraw.OutPut.Append("\r\nServed Soldeir!");
                        }
                    }
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicAttackValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicSelfSupportedValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedSupportSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedAttackValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicDistributionValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup = 0;

                }
                else//brown
                {


                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        if (SolderesOnTable == null || SolderesOnTable[i] == null)
                            continue;

                        for (var j = 0; j < SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Count; j++)
                        {
                            if (!(SolderesOnTable[i].SoldierThinking[0].IsSup[j]))
                                continue;


                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][0] += SolderesOnTable[ii].SoldierThinking[0].HeuristicAttackValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][1] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][2] += SolderesOnTable[ii].SoldierThinking[0].HeuristicSelfSupportedValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][3] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][4] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedSupportSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][5] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedAttackValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][6] += SolderesOnTable[ii].SoldierThinking[0].HeuristicDistributionValueSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][7] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][8] += SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup;
                            this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][9] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup;
                            SolderesOnTable[i].SoldierThinking[0].IsSup[j] = false;

                            //AllDraw.OutPut.Append("\r\nServed Soldeir!");
                        }
                    }
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicAttackValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicSelfSupportedValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedSupportSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedAttackValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicDistributionValueSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup = 0;
                    SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup = 0;
                }

            }
            else if (Kind == 2)//elephant
            {
                if (Order == 1)//gray
                {
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        if (ElephantOnTable == null || ElephantOnTable[i] == null)
                            continue;


                        for (var j = 0; j < ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Count; j++)
                        {
                            if (!(ElephantOnTable[i].ElefantThinking[0].IsSup[j]))
                                continue;

                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][0] += ElephantOnTable[ii].ElefantThinking[0].HeuristicAttackValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][1] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][2] += ElephantOnTable[ii].ElefantThinking[0].HeuristicSelfSupportedValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][3] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][4] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedSupportSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][5] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedAttackValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][6] += ElephantOnTable[ii].ElefantThinking[0].HeuristicDistributionValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][7] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][8] += ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][9] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup;
                            ElephantOnTable[i].ElefantThinking[0].IsSup[j] = false;

                            //AllDraw.OutPut.Append("\r\nServed Elephant!");
                        }

                    }
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicAttackValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicSelfSupportedValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedSupportSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedAttackValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicDistributionValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup = 0;

                }
                else//brown
                {

                    //elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        if (ElephantOnTable == null || ElephantOnTable[i] == null)
                            continue;

                        for (var j = 0; j < ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Count; j++)
                        {
                            if (!(ElephantOnTable[i].ElefantThinking[0].IsSup[j]))
                                continue;


                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][0] += ElephantOnTable[ii].ElefantThinking[0].HeuristicAttackValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][1] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][2] += ElephantOnTable[ii].ElefantThinking[0].HeuristicSelfSupportedValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][3] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][4] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedSupportSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][5] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedAttackValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][6] += ElephantOnTable[ii].ElefantThinking[0].HeuristicDistributionValueSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][7] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][8] += ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup;
                            this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][9] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup;
                            ElephantOnTable[i].ElefantThinking[0].IsSup[j] = false;

                            //AllDraw.OutPut.Append("\r\nServed Elephant!");
                        }

                    }
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicAttackValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicSelfSupportedValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedSupportSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedAttackValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicDistributionValueSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup = 0;
                    ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup = 0;
                }

            }
            else if (Kind == 3)//hourse
            {
                if (Order == 1)//gray
                {

                    for (var i = 0; i < HourseMidle; i++)
                    {
                        if (HoursesOnTable == null || HoursesOnTable[i] == null)
                            continue;
                        //var j = FoundTableIndex(this.HoursesOnTable[i].HourseThinking[0].TableListHourse, HoursesOnTable[ii].HourseThinking[0].TableConst);
                        for (var j = 0; j < HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Count; j++)
                        {
                            if (!(HoursesOnTable[i].HourseThinking[0].IsSup[j]))
                                continue;

                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][0] += HoursesOnTable[ii].HourseThinking[0].HeuristicAttackValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][1] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][2] += HoursesOnTable[ii].HourseThinking[0].HeuristicSelfSupportedValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][3] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][4] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedSupportSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][5] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedAttackValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][6] += HoursesOnTable[ii].HourseThinking[0].HeuristicDistributionValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][7] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][8] += HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][9] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup;
                            HoursesOnTable[i].HourseThinking[0].IsSup[j] = false;

                            //AllDraw.OutPut.Append("\r\nServed Hourse!");
                        }
                    }
                    HoursesOnTable[ii].HourseThinking[0].HeuristicAttackValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicSelfSupportedValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicReducedSupportSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicReducedAttackValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicDistributionValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup = 0;


                }
                else//brown
                {

                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        if (HoursesOnTable == null || HoursesOnTable[i] == null)
                            continue;

                        for (var j = 0; j < HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Count; j++)
                        {
                            if (!(HoursesOnTable[i].HourseThinking[0].IsSup[j]))
                                continue;

                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][0] += HoursesOnTable[ii].HourseThinking[0].HeuristicAttackValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][1] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][2] += HoursesOnTable[ii].HourseThinking[0].HeuristicSelfSupportedValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][3] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][4] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedSupportSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][5] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedAttackValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][6] += HoursesOnTable[ii].HourseThinking[0].HeuristicDistributionValueSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][7] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][8] += HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup;
                            this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][9] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup;
                            HoursesOnTable[i].HourseThinking[0].IsSup[j] = false;

                            //AllDraw.OutPut.Append("\r\nServed Hourse!");
                        }
                    }
                    HoursesOnTable[ii].HourseThinking[0].HeuristicAttackValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicSelfSupportedValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicReducedSupportSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicReducedAttackValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicDistributionValueSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup = 0;
                    HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup = 0;
                }

            }
            else if (Kind == 4)//Castle
            {
                if (Order == 1)//gray
                {

                    for (var i = 0; i < CastleMidle; i++)
                    {
                        if (CastlesOnTable == null || CastlesOnTable[i] == null)
                            continue;

                        for (var j = 0; j < CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Count; j++)
                        {
                            if (!(CastlesOnTable[i].CastleThinking[0].IsSup[j]))
                                continue;

                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][0] += CastlesOnTable[ii].CastleThinking[0].HeuristicAttackValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][1] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][2] += CastlesOnTable[ii].CastleThinking[0].HeuristicSelfSupportedValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][3] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][4] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedSupportSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][5] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedAttackValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][6] += CastlesOnTable[ii].CastleThinking[0].HeuristicDistributionValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][7] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][8] += CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][9] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup;
                            CastlesOnTable[i].CastleThinking[0].IsSup[j] = false;

                            //AllDraw.OutPut.Append("\r\nServed Castle!");
                        }
                    }
                    CastlesOnTable[ii].CastleThinking[0].HeuristicAttackValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicSelfSupportedValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicReducedSupportSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicReducedAttackValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicDistributionValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup = 0;

                }
                else//brown
                {

                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        if (CastlesOnTable == null || CastlesOnTable[i] == null)
                            continue;

                        for (var j = 0; j < CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Count; j++)
                        {
                            if (!(CastlesOnTable[i].CastleThinking[0].IsSup[j]))
                                continue;


                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][0] += CastlesOnTable[ii].CastleThinking[0].HeuristicAttackValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][1] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][2] += CastlesOnTable[ii].CastleThinking[0].HeuristicSelfSupportedValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][3] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][4] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedSupportSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][5] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedAttackValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][6] += CastlesOnTable[ii].CastleThinking[0].HeuristicDistributionValueSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][7] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][8] += CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup;
                            this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][9] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup;
                            CastlesOnTable[i].CastleThinking[0].IsSup[j] = false;

                            //AllDraw.OutPut.Append("\r\nServed Castle!");
                        }
                    }
                    CastlesOnTable[ii].CastleThinking[0].HeuristicAttackValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicSelfSupportedValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicReducedSupportSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicReducedAttackValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicDistributionValueSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup = 0;
                    CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup = 0;
                }
            }
            else//minister
            if (Kind == 5)
            {
                if (Order == 1)//gray
                {

                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        if (MinisterOnTable == null || MinisterOnTable[i] == null)
                            continue;

                        for (var j = 0; j < MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Count; j++)
                        {
                            if (!(MinisterOnTable[i].MinisterThinking[0].IsSup[j]))
                                continue;

                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][0] += MinisterOnTable[ii].MinisterThinking[0].HeuristicAttackValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][1] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][2] += MinisterOnTable[ii].MinisterThinking[0].HeuristicSelfSupportedValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][3] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][4] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedSupportSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][5] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedAttackValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][6] += MinisterOnTable[ii].MinisterThinking[0].HeuristicDistributionValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][7] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][8] += MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][9] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup;
                            MinisterOnTable[i].MinisterThinking[0].IsSup[j] = false;


                            //AllDraw.OutPut.Append("\r\nServed Minister!");
                        }
                    }
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicAttackValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicSelfSupportedValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedSupportSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedAttackValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicDistributionValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup = 0;

                }
                else
                {

                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        if (MinisterOnTable == null || MinisterOnTable[i] == null)
                            continue;

                        for (var j = 0; j < MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Count; j++)
                        {
                            if (!(MinisterOnTable[i].MinisterThinking[0].IsSup[j]))
                                continue;


                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][0] += MinisterOnTable[ii].MinisterThinking[0].HeuristicAttackValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][1] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][2] += MinisterOnTable[ii].MinisterThinking[0].HeuristicSelfSupportedValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][3] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][4] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedSupportSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][5] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedAttackValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][6] += MinisterOnTable[ii].MinisterThinking[0].HeuristicDistributionValueSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][7] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][8] += MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup;
                            this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][9] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup;
                            MinisterOnTable[i].MinisterThinking[0].IsSup[j] = false;

                            //AllDraw.OutPut.Append("\r\nServed Minister!");
                        }
                    }
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicAttackValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicSelfSupportedValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedSupportSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedAttackValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicDistributionValueSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup = 0;
                    MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup = 0;
                }
            }
            else
            if (Kind == 6)//king
            {
                if (Order == 1)//gray
                {

                    for (var i = 0; i < KingMidle; i++)
                    {
                        if (KingOnTable == null || KingOnTable[i] == null)
                            continue;

                        for (var j = 0; j < KingOnTable[i].KingThinking[0].HeuristicListKing.Count; j++)
                        {
                            if (!(KingOnTable[i].KingThinking[0].IsSup[j]))
                                continue;

                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][0] += KingOnTable[ii].KingThinking[0].HeuristicAttackValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][1] += KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][2] += KingOnTable[ii].KingThinking[0].HeuristicSelfSupportedValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][3] += KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][4] += KingOnTable[ii].KingThinking[0].HeuristicReducedSupportSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][5] += KingOnTable[ii].KingThinking[0].HeuristicReducedAttackValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][6] += KingOnTable[ii].KingThinking[0].HeuristicDistributionValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][7] += KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][8] += KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][9] += KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup;
                            KingOnTable[i].KingThinking[0].IsSup[j] = false;


                            //AllDraw.OutPut.Append("\r\nServed King!");
                        }
                    }
                    KingOnTable[ii].KingThinking[0].HeuristicAttackValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicSelfSupportedValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicReducedSupportSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicReducedAttackValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicDistributionValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup = 0;


                }
                else//brown
                {

                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        if (KingOnTable == null || KingOnTable[i] == null)
                            continue;

                        for (var j = 0; j < KingOnTable[i].KingThinking[0].HeuristicListKing.Count; j++)
                        {
                            if (!(KingOnTable[i].KingThinking[0].IsSup[j]))
                                continue;


                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][0] += KingOnTable[ii].KingThinking[0].HeuristicAttackValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][1] += KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][2] += KingOnTable[ii].KingThinking[0].HeuristicSelfSupportedValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][3] += KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][4] += KingOnTable[ii].KingThinking[0].HeuristicReducedSupportSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][5] += KingOnTable[ii].KingThinking[0].HeuristicReducedAttackValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][6] += KingOnTable[ii].KingThinking[0].HeuristicDistributionValueSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][7] += KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][8] += KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup;
                            this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][9] += KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup;
                            KingOnTable[i].KingThinking[0].IsSup[j] = false;


                            //AllDraw.OutPut.Append("\r\nServed King!");
                        }
                    }
                    KingOnTable[ii].KingThinking[0].HeuristicAttackValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicSelfSupportedValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicReducedSupportSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicReducedAttackValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicDistributionValueSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup = 0;
                    KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup = 0;


                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("ServeISSup:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void ThinkingAllowedSemaphore(int i)
        {
            if (ThinkingAllowed == null)
                ThinkingAllowed = new bool[12];
            do { } while (!ThinkingAllowed[i - 1]);


        }
        //main initiation of soldier gray
        AllDraw InitiateAStarGreedytSodlerGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(1));
                //arr.Wait();

                //For Gray Soldeirs Objects. 
                Parallel.For(0, SodierMidle, i =>
                //for (var i = 0; i < SodierMidle; i++)
                {
                    InitiateAStarGreedytSodler(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });


            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytSodlerGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedytSodler(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(1));
                //arr.Wait();

                //For Gray Soldeirs Objects. 

                Object O = new Object();
                lock (O)
                {

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //If Solders Not Exist Continue and Traversal Back.
                    if (SolderesOnTable != null && SolderesOnTable[i] != null)
                    {
                        //Initiate of Local Variables By Global Objective Gray Current Solder.
                        int ik = (int)SolderesOnTable[i].Row;
                        int jk = (int)SolderesOnTable[i].Column;
                        //Construction of Thinking Gray Soldier By Local Variables.
                        //if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                            //SolderesOnTable[i] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ik, jk, a, CloneATable(Table), Order, false, i);
                        //If There is no Thinking Movments on Current Object  

                        if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                        {
                            //For All Movable Gray Solders.
                            ////Parallel.For(0, AllDraw.SodierMovments, j =>
                            {
                                //Thinking of Gray Solder Operation.
                                Object OOO = new Object();
                                lock (OOO)
                                {
                                    SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                    SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                    var array = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].Thinking(iAStarGreedy, this, ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled));
                                    array.Wait(); array.Dispose();
                                    //ServeISSup(Order,1, i);
                                }

                            }//);
                        }
                        else
                        {
                            SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = false;
                            SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = true;
                        }
                    }

                }



            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytSodlerGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //main initiation of elephant gray
        AllDraw InitiateAStarGreedytElephantGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(2));
                //arr.Wait();

                Parallel.For(0, ElefantMidle, i =>
                //for (var i = 0; i < ElefantMidle; i++)
                {
                    InitiateAStarGreedytElephant(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytElephantGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

            return this;
        }
        AllDraw InitiateAStarGreedytElephant(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(2));
                //arr.Wait();


                Object O = new Object();
                lock (O)
                {

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //Ignore of Non Exist Current Elephant Gray Objects.
                    if (ElephantOnTable != null && ElephantOnTable[i] != null)
                    {
                        //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                        int ik = (int)ElephantOnTable[i].Row;
                        int jk = (int)ElephantOnTable[i].Column;
                        //Construction of Thinking Objects By Local Varibales.
                        //if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                            //ElephantOnTable[i] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ik, jk, a, CloneATable(Table), Order, false, i);
                        //If There is Not Thinking Objetive List Elephant Gray. 
                        if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                        {
                            //For All Possible Movments.
                            ////Parallel.For(0, AllDraw.ElefantMovments, j =>
                            {
                                //Operational Thinking Gray Elephant. 
                                Object OOO = new Object();
                                lock (OOO)
                                {
                                    ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                    ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;

                                    var array = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].Thinking(iAStarGreedy, this, ref ElephantOnTable[i].LoseOcuuredatChiled, ref ElephantOnTable[i].WinOcuuredatChiled));
                                    array.Wait(); array.Dispose();
                                    //ServeISSup(Order,2, i);

                                }
                            }//);
                        }
                        else
                        {
                            ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = false;
                            ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = true;
                        }
                    }

                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytElephantGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

            return this;
        }
        //main initiation of hourse gray
        AllDraw InitiateAStarGreedythHourseGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(3));
                //arr.Wait();

                //For All Gray Hourse Objects.
                Parallel.For(0, HourseMidle, i =>
                //for (var i = 0; i < HourseMidle; i++)
                {
                    InitiateAStarGreedythHourse(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });


            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythHourseGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythHourse(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(3));
                //arr.Wait();

                //For All Gray Hourse Objects.

                Object O = new Object();
                lock (O)
                {

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //Ignore of Non Exist Current Gray Hourse Objects.
                    if (HoursesOnTable != null && HoursesOnTable[i] != null)
                    {
                        //Initiate of Local Variables By Global Gray Hourse Objectives.
                        int ik = (int)HoursesOnTable[i].Row;
                        int jk = (int)HoursesOnTable[i].Column;
                        //Construction of Gray Hourse Thinking Objects..
                        //if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                            //HoursesOnTable[i] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ik, jk, a, CloneATable(Table), Order, false, i);
                        //When There is Not HourseList Count. 
                        if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                        {
                            //For All Possible Movments.
                            ////Parallel.For(0, AllDraw.HourseMovments, j =>
                            {
                                //Thinking of Gray Hourse Oprational.
                                Object OOO = new Object();
                                lock (OOO)
                                {
                                    HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                    HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                    var array = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[i].LoseOcuuredatChiled, ref HoursesOnTable[i].WinOcuuredatChiled));
                                    array.Wait(); array.Dispose();

                                    //ServeISSup(Order,3, i);



                                }
                            }//);
                        }
                        else
                        {
                            HoursesOnTable[i].HourseThinking[0].ThinkingBegin = false;
                            HoursesOnTable[i].HourseThinking[0].ThinkingFinished = true;
                        }
                    }

                }


            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythHourseGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //main initiation of Castle gray

        AllDraw InitiateAStarGreedythCastleGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
       )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(4));
                //arr.Wait();

                //For All Possible Gray Castles Objects.
                Parallel.For(0, CastleMidle, i =>
                //for (var i = 0; i < CastleMidle; i++)
                {
                    InitiateAStarGreedythCastle(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });


            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythCastle(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
       )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(4));
                //arr.Wait();

                //For All Possible Gray Castles Objects.

                Object O = new Object();
                lock (O)
                {

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //When Current Castles Gray Not Exist Continue Traversal Back.
                    if (CastlesOnTable != null && CastlesOnTable[i] != null)
                    {
                        //Initaiate of Local Varibales By Global Varoiables.
                        int ik = (int)CastlesOnTable[i].Row;
                        int jk = (int)CastlesOnTable[i].Column;
                        //Construction of Thinking Variables By Local Variables.
                        //if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                            //CastlesOnTable[i] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ik, jk, a, CloneATable(Table), Order, false, i);
                        //When Count of Table Castles of Thinking Not Exist Do Operational.
                        if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                        {
                            //For All Possible Movments.
                            ////Parallel.For(0, AllDraw.CastleMovments, j =>
                            {
                                Object OOO = new Object();
                                lock (OOO)
                                {
                                    //Thinking of Gray Castles Operational.
                                    CastlesOnTable[i].CastleThinking[0].ThinkingBegin = true;
                                    CastlesOnTable[i].CastleThinking[0].ThinkingFinished = false;

                                    var array = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled));
                                    array.Wait(); array.Dispose();
                                    //ServeISSup(Order,4, i);

                                }
                            }//);

                        }
                        else
                        {
                            CastlesOnTable[i].CastleThinking[0].ThinkingBegin = false;
                            CastlesOnTable[i].CastleThinking[0].ThinkingFinished = true;
                        }
                    }

                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //main initiation of minister gray
        AllDraw InitiateAStarGreedythMinisterGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(5));
                //arr.Wait();

                //For All Possible Gray Minister Movments.
                Parallel.For(0, MinisterMidle, i =>
                //for (var i = 0; i < MinisterMidle; i++)
                {

                    InitiateAStarGreedythMinister(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);

                });

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythMinisterGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythMinister(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(5));
                //arr.Wait();

                //For All Possible Gray Minister Movments.


                Object O = new Object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //For Each Non Exist Gray Minister Objectives.
                    if (MinisterOnTable != null && MinisterOnTable[i] != null)
                    {
                        //Inititate Local Variables By Global Varibales.
                        int ik = (int)MinisterOnTable[i].Row;
                        int jk = (int)MinisterOnTable[i].Column;
                        //Construction of Thinking Objects Gray Minister.
                        //if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                            //MinisterOnTable[i] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ik, jk, a, CloneATable(Table), Order, false, i);
                        //If There is Not Minister Of Gray In The Thinking Table List.   
                        if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                        {
                            //For All Possible Movments.
                            // //Parallel.For(0, AllDraw.MinisterMovments, j =>
                            {
                                //Thinking of Gray Minister Operational.
                                Object OOO = new Object();
                                lock (OOO)
                                {
                                    MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                    MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;

                                    var array = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].Thinking(iAStarGreedy, this, ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled));
                                    array.Wait(); array.Dispose();
                                    //ServeISSup(Order,5, i);

                                }
                            }//);

                        }
                        else
                        {
                            MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = false;
                            MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = true;
                        }
                    }
                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythMinisterGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //main initiation of king gray
        AllDraw InitiateAStarGreedythKingGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(6));
                //arr.Wait();

                //For All Possible Gray King Objects.
                Parallel.For(0, KingMidle, i =>
                //for (var i = 0; i < KingMidle; i++)
                {
                    InitiateAStarGreedythKing(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythKingGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythKing(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(6));
                //arr.Wait();

                //For All Possible Gray King Objects.

                Object O = new Object();
                lock (O)
                {

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //If There is Not Current Object Continue Traversal Back.
                    if (KingOnTable != null && KingOnTable[i] != null)
                    {
                        //Initiate Local varibale By Global Objective Varibales.
                        int ik = (int)(int)KingOnTable[i].Row;
                        int jk = (int)KingOnTable[i].Column;
                        //Construction of Gray King Thinking Objects.
                        //if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                            //KingOnTable[i] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ik, jk, a, CloneATable(Table), Order, false, i);
                        //When There is Not Thinking Table Gray King Movments.
                        if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                        {
                            //For All Possible Gray King Movments.
                            ////Parallel.For(0, AllDraw.KingMovments, j =>
                            {
                                //Thinking Of Gray King Operatins.
                                Object OOO = new Object();
                                lock (OOO)
                                {
                                    KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                    KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                    ; var array = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].Thinking(iAStarGreedy, this, ref KingOnTable[i].LoseOcuuredatChiled, ref KingOnTable[i].WinOcuuredatChiled));
                                    array.Wait(); array.Dispose();

                                    //ServeISSup(Order,6, i);
                                }
                            }//);
                        }
                        else
                        {
                            KingOnTable[i].KingThinking[0].ThinkingBegin = false;
                            KingOnTable[i].KingThinking[0].ThinkingFinished = true;
                        }
                    }

                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythKingGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //main initiation of soldier brown 
        AllDraw InitiateAStarGreedythSoldierBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(7));
                //arr.Wait();

                //For Each Objects of Brown Sodiers.
                Parallel.For(SodierMidle, SodierHigh, i =>
                //for (var i = SodierMidle; i < SodierHigh; i++)
                {
                    InitiateAStarGreedytSodler(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });


            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythSoldierBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //main initiation of elephant brown
        AllDraw InitiateAStarGreedythElephantBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(8));
                //arr.Wait();


                Parallel.For(ElefantMidle, ElefantHigh, i =>
                //for (var i = ElefantMidle; i < ElefantHigh; i++)
                {
                    InitiateAStarGreedytElephant(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });


            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythElephantBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //main initiation of hourse brown
        AllDraw InitiateAStarGreedythHourseBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(9));
                //arr.Wait();

                Parallel.For(HourseMidle, HourseHight, i =>
                //for (var i = HourseMidle; i < HourseHight; i++)
                {
                    InitiateAStarGreedythHourse(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });


            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythHourseBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //main initiation of Castle brown
        AllDraw InitiateAStarGreedythCastleBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(10));
                //arr.Wait();

                Parallel.For(CastleMidle, CastleHigh, i =>
                //for (var i = CastleMidle; i < CastleHigh; i++)
                {
                    InitiateAStarGreedythCastle(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });


            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythCastleBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        //main initiatiob of minister brown
        AllDraw InitiateAStarGreedythMinisterBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(11));
                //arr.Wait();


                Parallel.For(MinisterMidle, MinisterHigh, i =>
                //for (var i = MinisterMidle; i < MinisterHigh; i++)
                {
                    InitiateAStarGreedythMinister(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythMinisterBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

            return this;
        }
        //main initiation of king brown
        AllDraw InitiateAStarGreedythKingBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                //var arr = Task.Factory.StartNew(() => ThinkingAllowedSemaphore(12));
                //arr.Wait();


                Parallel.For(KingMidle, KingHigh, i =>
                //for (var i = KingMidle; i < KingHigh; i++)
                {
                    InitiateAStarGreedythKing(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                });

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedythKingBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

            return this;
        }
        //boundry condition determistic method for break
        bool FullBoundryConditions(int Current, int Order, int iAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;


            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                if (iAStarGreedy < 0 //&& iAStarGreedy < MaxDuringLevelThinkingCreation
                )
                {
                    IS = true;
                }
                //gray
                if (Order == 1)
                {
                    //soldier
                    for (int ikk = 0; ikk < SodierMidle; ikk++)
                    {
                        if (SolderesOnTable == null )
                            continue;
                        if (SolderesOnTable[ikk] == null)
                            continue;
                        if (SolderesOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //elephant
                    for (int ikk = 0; ikk < ElefantMidle; ikk++)
                    {
                        if (ElephantOnTable == null)
                            continue;
                        if (ElephantOnTable[ikk] == null)
                            continue;
                        if (ElephantOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //hourse
                    for (int ikk = 0; ikk < HourseMidle; ikk++)
                    {
                        if (HoursesOnTable == null)
                            continue;
                        if (HoursesOnTable[ikk] == null)
                            continue;
                        if (HoursesOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //Castle
                    for (int ikk = 0; ikk < CastleMidle; ikk++)
                    {
                        if (CastlesOnTable == null)
                            continue;
                        if (CastlesOnTable[ikk] == null)
                            continue;
                        if (CastlesOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //minister
                    for (int ikk = 0; ikk < MinisterMidle; ikk++)
                    {
                        if (MinisterOnTable == null)
                            continue;
                        if (MinisterOnTable[ikk] == null)
                            continue;
                        if (MinisterOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //king
                    for (int ikk = 0; ikk < KingMidle; ikk++)
                    {
                        if (KingOnTable == null)
                            continue;
                        if (KingOnTable[ikk] == null)
                            continue;
                        if (KingOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //when vicrory count satisfied
                    if ((ThinkingChess.FoundFirstMating > (MaxAStarGreedy))) //|| (SetDeptIgnore))
                    {
                        //OutPut.Append("\r\nCheckedMate Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstMating.ToString());
                        IS = true;
                    }

                }
                else
                {
                    //soldier
                    for (int ikk = SodierMidle; ikk < SodierHigh; ikk++)
                    {
                        if (SolderesOnTable == null)
                            continue;
                        if (SolderesOnTable[ikk] == null)
                            continue;
                        if (SolderesOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //elephant
                    for (int ikk = ElefantMidle; ikk < ElefantHigh; ikk++)
                    {
                        if (ElephantOnTable == null)
                            continue;
                        if (ElephantOnTable[ikk] == null)
                            continue;
                        if (ElephantOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //hourse
                    for (int ikk = HourseMidle; ikk < HourseHight; ikk++)
                    {
                        if (HoursesOnTable == null || HoursesOnTable[ikk] == null)
                            continue;
                        if (HoursesOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //Castle
                    for (int ikk = CastleMidle; ikk < CastleHigh; ikk++)
                    {
                        if (CastlesOnTable == null)
                            continue;
                        if (CastlesOnTable[ikk] == null)
                            continue;
                        if (CastlesOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //minister
                    for (int ikk = MinisterMidle; ikk < MinisterHigh; ikk++)
                    {
                        if (MinisterOnTable == null)
                            continue;
                        if (MinisterOnTable[ikk] == null)
                            continue;
                        if (MinisterOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //king
                    for (int ikk = KingMidle; ikk < KingHigh; ikk++)
                    {
                        if (KingOnTable == null)
                            continue;
                        if (KingOnTable[ikk] == null)
                            continue;
                        if (KingOnTable[ikk].LoseOcuuredatChiled < -1)
                        {
                            //OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                            IS = true;
                        }
                    }
                    //when victory count satisfied
                    if ((ThinkingChess.FoundFirstMating > (MaxAStarGreedy))) //|| (SetDeptIgnore))
                    {
                        //OutPut.Append("\r\nCheckedMate Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstMating.ToString());
                        IS = true;
                    }

                }
                //when nu,bers of computational leafs satisfied 
                if (((ThinkingChess.NumbersOfAllNode - AllDraw.NumberOfLeafComputation) > 100) && AllDraw.NumberOfLeafComputation != -1)
                    IS = true;

                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullBoundryConditions:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return IS;
            }
        }
        //AStarGreedy First Initiat Thinking Main Method.
        void AstarGreedyThinking(int Order, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int i, int j, int ii, int jj, int[,] Table, Color a, bool TB, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object o = new Object();
            lock (o)
            {

                //If Order is Gray.
                if (Order == 1)
                {
                    int i1 = i, j1 = j;
                    int[,] Tab = CloneATable(Table);
                    int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                    bool TB1 = TB;
                    Color aa = a;

                    var output = Task.Factory.StartNew(() =>
                    {
                        //if (!feedCancellationTokenSource.IsCancellationRequested)
                        {
                            Parallel.Invoke(() =>
                            {
                                //For All Gray Soldier Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedytSodlerGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }, () =>
                            {
                                //For All Gray Elephant Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedytElephantGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }, () =>
                            {
                                //For All Gray Hourse Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythHourseGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }, () =>
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythCastleGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }, () =>
                            {

                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythMinisterGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }

                            }, () =>
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythKingGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            });
                        }
                    });
                }
                else//Brown Order Considarations.
                {
                    int i1 = i, j1 = j;
                    int[,] Tab = CloneATable(Table);
                    int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                    bool TB1 = TB;
                    Color aa = a;
                    //If Order is Gray.

                    var output = Task.Factory.StartNew(() =>
                    {
                        //if (!feedCancellationTokenSource.IsCancellationRequested)
                        {
                            Parallel.Invoke(() =>
                            {
                                //For All Gray Soldier Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythSoldierBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }, () =>
                            {
                                //For All Gray Elephant Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythElephantBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }, () =>
                            {
                                //For All Gray Hourse Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythHourseBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }, () =>
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythCastleBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }, () =>
                            {

                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythMinisterBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }

                            }, () =>
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythKingBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            });
                        }
                    });
                    output.Wait(); output.Dispose();
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("AstarGreedyThinking:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //initiation setdrawfounding tow stage computational method 
        public bool InitiateAStarGreedytCreationThinking(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object o = new Object();
            lock (o)
            {
                if (ThinkingAllowed == null)
                    ThinkingAllowed = new bool[12];
                for (int iii = 0; iii < 12; iii++)
                    ThinkingAllowed[iii] = true;
                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;
#pragma warning disable CS0219 // The variable 'ik' is assigned but its value is never used
                int i = 0, ik = 0;
#pragma warning restore CS0219 // The variable 'ik' is assigned but its value is never used
                var j = 0;

                int[,] Table = new int[8, 8];
                for (var iii = 0; iii < 8; iii++)
                    for (var jjj = 0; jjj < 8; jjj++)
                        Table[iii, jjj] = Tab[iii, jjj];

                //If Order is Gray.
                if (Order == 1)
                {
                    var array1 = Task.Factory.StartNew(() => InitiateAStarGreedytCreationThinkingGray(DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, i, j, a, Tab, Order, TB, FOUND, LeafAStarGreedy));
                    //array1.ConfigureAwait(false);
                    array1.Wait();
                    array1.Dispose();

                }
                else//Brown Order Considarations.
                {
                    var array1 = Task.Factory.StartNew(() => InitiateAStarGreedytCreationThinkingBrown(DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, i, j, a, Tab, Order, TB, FOUND, LeafAStarGreedy));
                    //array1.ConfigureAwait(false);
                    array1.Wait();
                    array1.Dispose();

                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytCreationThinking:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return true;
        }
        public bool InitiateAStarGreedytCreationThinkingGray(int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj,int i,int j, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object o = new Object();
            lock (o)
            {
                int i1 = i, j1 = j;
                int[,] Tabl = CloneATable(Table);
                int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                bool TB1 = TB;
                Color aa = a;


                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        Parallel.Invoke(() =>
                        {
                                //For All Gray Soldier Objects.
                                Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedytSodlerGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        }, () =>
                        {
                                //For All Gray Elephant Objects.
                                Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedytElephantGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        }, () =>
                        {
                                //For All Gray Hourse Objects.
                                Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythHourseGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        }, () =>
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythCastleGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        }, () =>
                        {

                            Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythMinisterGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }

                        }, () =>
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythKingGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        });
                    }
                });
                output.Wait(); output.Dispose();
            }            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytCreationThinking:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return true;
        }
        public bool InitiateAStarGreedytCreationThinkingBrown(int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj,int i,int j, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object o = new Object();
            lock (o)
            {

                int i1 = i, j1 = j;
                int[,] Tabl = CloneATable(Table);
                int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                bool TB1 = TB;
                Color aa = a;
                //If Order is Gray.


                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        Parallel.Invoke(() =>
                        {
                                //For All Gray Soldier Objects.
                                Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythSoldierBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        }, () =>
                        {
                                //For All Gray Elephant Objects.
                                Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythElephantBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        }, () =>
                        {
                                //For All Gray Hourse Objects.
                                Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythHourseBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        }, () =>
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythCastleBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        }, () =>
                        {

                            Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythMinisterBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }

                        }, () =>
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                this.InitiateAStarGreedythKingBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                            }
                        });
                    }
                });
                output.Wait(); output.Dispose();

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytCreationThinking:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return true;
        }
        //computational initiation
        public AllDraw InitiateAStarGreedyt(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
              //long Time = TimeElapced.TimeNow();Spaces++;
            OrderP = Order;
            SetObjectNumbers(Tab);

            int[,] Table = new int[8, 8];
            for (var iii = 0; iii < 8; iii++)
                for (var jjj = 0; jjj < 8; jjj++)
                    Table[iii, jjj] = Tab[iii, jjj];

            Object oo = new Object();
            lock (oo)
            {
                ThinkingChess.BeginThread = 0;
                ThinkingChess.EndThread = 0;
            }
            //Initiate of global Variables Byte Local Variables.
            int DummyOrder = new int();
            DummyOrder = Order;
            int DummyCurrentOrder = new int();
            DummyCurrentOrder = ChessRules.CurrentOrder;
#pragma warning disable CS0219 // The variable 'i' is assigned but its value is never used
            int i = 0, ik = 0;
#pragma warning restore CS0219 // The variable 'i' is assigned but its value is never used
            int[,] TablInit = new int[8, 8];
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            var j = 0;

            //Fairness conditions for perposive astar greedy search.
            Object Omm = new Object();
            lock (Omm)
            {
                Object OOOO = new Object();
                lock (OOOO)
                {



                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return null;

                    if (LeafSemaphoreIndex)
                        LeafAStarGreedy++;
                    iAStarGreedy--;
                }
                CurrentAStarGredyMax = AStarGreedyiLevelMax - iAStarGreedy;
            }
            bool Do = false;
            if (iAStarGreedy >= 0 && iAStarGreedy < MaxDuringLevelThinkingCreation)
            {
                MaxDuringLevelThinkingCreation = iAStarGreedy;
                Object O = new Object();
                DepthIterative++;
                lock (O)
                {
                    //OutPut.Append("\r\nMinimum Level During Thinking Tree Creation is " + MaxDuringLevelThinkingCreation.ToString() + "at Iterative " + DepthIterative.ToString());
                }
            }


            if (tH == null)
                tH = new List<Task>();


            if (!FOUND)
            {
                //Initiate Of Local Variables.
                Object o = new Object();
                lock (o)
                {


                    var array1 = Task.Factory.StartNew(() => InitiateAStarGreedytCreationThinking(iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy));
                    //array1.ConfigureAwait(false);
                    array1.Wait();
                    array1.Dispose();
                    //array1.Wait(); array1.Dispose();//TH.Add(array1);

                }

                /*

                if (!FOUND)
                {
                    //Initiate Of Local Variables.


                    Object o = new Object();
                    lock (o)
                    {

                        //If Order is Gray.
                        if (Order== 1)
                        {
                            int i1 = i, j1 = j;
                            int[,] Tabl = CloneATable(Table);
                            int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                            bool TB1 = TB;
                            Color aa = a;


                            //Parallel.Invoke(() =>
                            {
                                //For All Gray Soldier Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedytSodlerGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                            //,
                           // () =>
                            {
                                //For All Gray Elephant Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedytElephantGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                            //, () =>
                            {
                                //For All Gray Hourse Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythHourseGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                           // ,
                           // () =>
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythCastleGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                           // , () =>
                            {

                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythMinisterGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }

                            }
                            //, () =>
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythKingGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                           // );
                        }
                        else//Brown Order Considarations.
                        {
                            int i1 = i, j1 = j;
                            int[,] Tabl = CloneATable(Table);
                            int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                            bool TB1 = TB;
                            Color aa = a;
                            //If Order is Gray.


                            //Parallel.Invoke(() =>
                            {
                                //For All Gray Soldier Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythSoldierBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                           // ,
                           // () =>
                            {
                                //For All Gray Elephant Objects.
                                Object O = new Object();
                               lock (O)
                                {
                                    this.InitiateAStarGreedythElephantBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                            //, () =>
                            {
                                //For All Gray Hourse Objects.
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythHourseBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                           // ,
                            //() =>
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythCastleBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                            //, () =>
                            {

                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythMinisterBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }

                            }
                            //, () =>
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    this.InitiateAStarGreedythKingBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                }
                            }
                           // );
                        }
                    }
                }
                */

            }
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;

            var array = Task.Factory.StartNew(() => Serve(Order));
            //array.ConfigureAwait(false);
            array.Wait();
            array.Dispose();
            //tH.Add(array);
            // //Parallel.ForEach(TH, items => Task.WaitAll(items));
            //  tH.Clear();

            if (FOUND)
            {
                Object O = new Object();
                lock (O)
                {
                    FOUND = false;
                    RefrigtzDLL.AllDraw Leaf = null;
                    Tabl = CloneATable(Table);
                    int OrderLeaf = Order;
                    var array1 = Task.Factory.StartNew(() => FoundOfLeafDepenOfKind(ref Leaf, ref FOUND, Order, ref OrderLeaf, 0, 0, 0, 0));

                    //array1.ConfigureAwait(false);

                    array1.Wait();
                    array1.Dispose();
                    /*tFoundOfLeafDepenOfKindFullGame = new Task(new Action(() => FoundOfLeafDepenOfKindFullGame(Tabl, Order, iAStarGreedy, ii, jj, ik, j, FOUND, LeafAStarGreedy)));
                tFoundOfLeafDepenOfKindFullGame.Start();
                T.Add(tFoundOfLeafDepenOfKindFullGame);*/
                }
            }
            else
            {
                if (!Deeperthandeeper || ThinkingChess.FullGameAllow)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        int Ord = Order, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;


                        var array1 = Task.Factory.StartNew(() => Do = this.FullGameThinkingTree(Ord, iAStarGreedy1, ii1, jj1, ik1, j1, false, LeafAStarGreedy));
                        //array1.ConfigureAwait(false);
                        //array1.Wait();

                        array1.Wait();
                        array1.Dispose();

                        /*tFullGameThinkingTree = new Task(new Action(() => Do = this.FullGameThinkingTree(Ord, iAStarGreedy1, ii1, jj1, ik1, j1, false, LeafAStarGreedy)));
                    tFullGameThinkingTree.Start();
                    T.Add(tFullGameThinkingTree);*/


                    }
                }
            }

            

            Object Om = new Object();
            lock (Om)
            {
                if (!Do)
                    if (iAStarGreedy < MinThinkingTreeDepth)
                        MinThinkingTreeDepth = iAStarGreedy;
            }

            tH.Clear();

            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedyt:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            //Parallel.ForEach(T, items => Task.WaitAll(items));
            return this;

        }
        //computational second object
        public AllDraw InitiateAStarGreedytObject(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            {

                OrderP = Order;
                SetObjectNumbers(Tab);

                int[,] Table = new int[8, 8];
                for (var iii = 0; iii < 8; iii++)
                    for (var jjj = 0; jjj < 8; jjj++)
                        Table[iii, jjj] = Tab[iii, jjj];
                Object oo = new Object();
                lock (oo)
                {
                    ThinkingChess.BeginThread = 0;
                    ThinkingChess.EndThread = 0;
                }
                //Initiate of global Variables Byte Local Variables.
                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;
                List<Task> ThB = new List<Task>();

                int i = 0, ik = 0;
                int[,] TablInit = new int[8, 8];
                if (Order == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                var j = 0;
                //if (iAStarGreedy>=0)
                //return null;
                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (iAStarGreedy < 0)
                    {
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return null;


                    }

                }

                CurrentAStarGredyMax = AStarGreedyiLevelMax - iAStarGreedy;
                iAStarGreedy--;

                if (iAStarGreedy >= 0 && iAStarGreedy < MaxDuringLevelThinkingCreation)
                {
                    MaxDuringLevelThinkingCreation = iAStarGreedy;
                    Object O = new Object();
                    DepthIterative++;
                    lock (O)
                    {
                        //OutPut.Append("\r\nMinimum Level During Thinking Tree Creation is " + MaxDuringLevelThinkingCreation.ToString() + "at Iterative " + DepthIterative.ToString());
                    }


                }




                if (!FOUND)
                {
                    Object o = new Object();
                    lock (o)
                    {
                        if (Order == 1)
                            this.InitiateAStarGreedytObjectGray(i, j, CloneATable(Table), DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        else
                            this.InitiateAStarGreedytObjectBrown(i, j, CloneATable(Table), DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                    }
                }

                if (FOUND)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        Tabl = CloneATable(Table);
                        FoundOfLeafDepenOfKindFullGame(Tabl, Order, iAStarGreedy, ii, jj, ik, j, FOUND, LeafAStarGreedy);
                    }
                }
                else
                {
                    Object O = new Object();
                    lock (O)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        int Ord = Order, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;
                        //int Ord = Order, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;

                        //Parallel.Invoke(() =>
                        {
                            Do |= this.FullGameThinkingTree(Ord, iAStarGreedy1, ii1, jj1, ik1, j1, false, LeafAStarGreedy);
                        }//);
                    }

                }
                Object Om = new Object();
                lock (Om)
                {
                    if (!Do)
                        if (iAStarGreedy < MinThinkingTreeDepth)
                            MinThinkingTreeDepth = iAStarGreedy;
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("InitiateAStarGreedytObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return this;
            }
        }
        //determistic of checked blitz game
        bool KingDan(int[,] Tab, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool IsDang = false;
            RefrigtzDLL.ChessRules A = new RefrigtzDLL.ChessRules(0, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Order);
            IsDang = A.ObjectDangourKingMove(Order, Tab);
            if (Order == 1 && (IsDang))
            {
                if (A.CheckBrownObjectDangour && ((!A.CheckGrayObjectDangour)))
                    IsDang = false;
            }
            if (Order == -1 && (IsDang))
            {
                if (A.CheckGrayObjectDangour && ((!A.CheckBrownObjectDangour)))
                    IsDang = false;
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("KingDan:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return IsDang;

        }
        //always by calling empty deeper
        void ClearAStarGreadyWhenListsAreEmpy(int Kind, int i)
        {
            //soldier
            if (Kind == 1 && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > 0)
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Clear();
            else//elephant
if (Kind == 2 && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > 0)
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Clear();
            else//hourse
                if (Kind == 3 && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > 0)
                HoursesOnTable[i].HourseThinking[0].AStarGreedy.Clear();
            else//Castle
                if (Kind == 4 && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > 0)
                CastlesOnTable[i].CastleThinking[0].AStarGreedy.Clear();
            else//minister
                if (Kind == 5 && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > 0)
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Clear();

            else//king
                if (Kind == 6 && KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > 0)
                KingOnTable[i].KingThinking[0].AStarGreedy.Clear();

        }
        //deterministic of calculated computational deeper
        bool IsThereCalculatedAStarGreedyNode()
        {
            bool Is = false;
            //soldier
            for (int i = 0; i < SodierHigh; i++)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null)
                {
                    if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        Is = true;
                        break;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(1, i);

                }
            }
            if (!Is)
            {
                //elephant
                for (int i = 0; i < ElefantHigh; i++)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null)
                    {
                        if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(2, i);

                    }
                }
            }
            if (!Is)
            {
                //hourse
                for (int i = 0; i < HourseHight; i++)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null)
                    {
                        if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(3, i);

                    }
                }
            }
            if (!Is)
            {
                //Castle
                for (int i = 0; i < CastleHigh; i++)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null)
                    {
                        if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(4, i);

                    }
                }
            }
            if (!Is)
            {
                //minister
                for (int i = 0; i < MinisterHigh; i++)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null)
                    {
                        if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(5, i);


                    }
                }
            }
            if (!Is)
            {
                //king
                for (int i = 0; i < KingHigh; i++)
                {
                    if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null)
                    {
                        if (KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(6, i);


                    }
                }
            }
            return Is;
        }
        //when there is index notified deeper computational node
        bool IsThereCalculatedAStarGreedyNode(int i, int Kind)
        {
            bool Is = false;
            //soldier
            if (Kind == 1)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null)
                {
                    if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        Is = true;

                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(1, i);


                }
            }
            else
            if (Kind == 2)
            {
                //elephant
                if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null)
                {
                    if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                    {
                        Is = true;

                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(2, i);

                }

            }
            else
            if (Kind == 3)
            {
                //hourse
                if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null)
                {
                    if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                    {
                        Is = true;

                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(3, i);


                }

            }
            else
            if (Kind == 4)
            {
                //Castle
                if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null)
                {
                    if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                    {
                        Is = true;

                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(4, i);


                }

            }
            else
            if (Kind == 5)
            {
                //minister
                if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null)
                {
                    if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                    {
                        Is = true;

                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(5, i);


                }

            }
            else
            if (Kind == 6)
            {
                //king
                if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null)
                {
                    if (KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                    {
                        Is = true;

                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(6, i);


                }

            }
            return Is;
        }
        //when there is all deeper computational nodes return true else return false
        bool IsThereNotAllOfEmptyOrNonCalculatedAStarGreedyNode(int Order, int Kind, int i)
        {
            bool Is = true;
            //soldier
            if (Kind == 1)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; j++)
                        Is = Is && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//elephant
                if (Kind == 2)
            {
                if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; j++)
                        Is = Is && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//hourse
                if (Kind == 3)
            {
                if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; j++)
                        Is = Is && HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
            }
            else//Castle
                if (Kind == 4)
            {
                if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; j++)
                        Is = Is && CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//minister
                if (Kind == 5)
            {
                if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; j++)
                        Is = Is && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//king
            if (Kind == 6)
            {
                if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < KingOnTable[i].KingThinking[0].AStarGreedy.Count; j++)
                        Is = Is && KingOnTable[i].KingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            return Is;
        }
        //when there is at least one non compuational deeper determined NON existence of deeper computational indexed deeper node 
        bool IsThereEmptyOrNonCalculatedAStarGreedyNode(int Order, int Kind, int i, int j)
        {
            bool Is = false;

            if (!IsThereNotAllOfEmptyOrNonCalculatedAStarGreedyNode(Order, Kind, i))
            {
                //soldier
                if (Kind == 1)
                {
                    if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                        Is = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else//elephant
                    if (Kind == 2)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                        Is = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else//hourse
                    if (Kind == 3)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                        Is = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
                else//Castle
                    if (Kind == 4)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                        Is = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
                else//minister
                    if (Kind == 5)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                        Is = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
                else//king
                if (Kind == 6)
                {
                    if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                        Is = KingOnTable[i].KingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
            }
            return (!Is);
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeSolderGray(ref int PreviousLessS, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Soldeir
            for (ik = 0; ik < SodierMidle; ik++)
            {
                if (SolderesOnTable == null || SolderesOnTable[ik] == null || SolderesOnTable[ik].SoldierThinking == null || SolderesOnTable[ik].SoldierThinking[0] == null || SolderesOnTable[ik].SoldierThinking[0].HeuristicListSolder == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].HeuristicListSolder.Count; j++)
                {
                    //when node is serving node continue
                    if (SolderesOnTable[ik].SoldierThinking[0].IsSupHu[j]
                      )
                        continue;

                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 1, ik, j))
                            continue;
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, ik, j, 0))
                            continue;
                        //when is self
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {

                            }

                            else
                            {
                                PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                                Index[0] = ik;
                                jIndex[0] = j;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {

                            }

                            else
                            {
                                PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                                Index[0] = ik;
                                jIndex[0] = j;
                            }
                        }

                    }
                }

                //Elephant
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeSolderGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeElephantGray(ref int PreviousLessE, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Elephant
            for (ik = 0; ik < ElefantMidle; ik++)
            {
                if (ElephantOnTable == null || ElephantOnTable[ik] == null || ElephantOnTable[ik].ElefantThinking == null || ElephantOnTable[ik].ElefantThinking[0] == null || ElephantOnTable[ik].ElefantThinking[0].HeuristicListElefant == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].HeuristicListElefant.Count; j++)
                {
                    //when node is serving node continue
                    if (ElephantOnTable[ik].ElefantThinking[0].IsSupHu[j]
               )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 2, ik, j))
                            continue;

                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, ik, j, 0))
                            continue;


                        //when is self
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }

                            else
                            {
                                PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                                Index[1] = ik;
                                jIndex[1] = j;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }

                            else
                            {
                                PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                                Index[1] = ik;
                                jIndex[1] = j;
                            }
                        }

                    }
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeElephantGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeHourseGray(ref int PreviousLessH, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Hourse.
            for (ik = 0; ik < HourseMidle; ik++)
            {
                if (HoursesOnTable == null || HoursesOnTable[ik] == null || HoursesOnTable[ik].HourseThinking == null || HoursesOnTable[ik].HourseThinking[0] == null || HoursesOnTable[ik].HourseThinking[0].HeuristicListHourse == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].HeuristicListHourse.Count; j++)
                {
                    //when node is serving node continue
                    if (HoursesOnTable[ik].HourseThinking[0].IsSupHu[j]
                  )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 3, ik, j))
                            continue;

                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, ik, j, 0))
                            continue;

                        //when is self
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }

                            else
                            {
                                PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                                Index[2] = ik;
                                jIndex[2] = j;
                            }
                        }
                        else
                        {

                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }

                            else
                            {
                                PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                                Index[2] = ik;
                                jIndex[2] = j;
                            }
                        }

                    }
                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeHourseGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeCastleGray(ref int PreviousLessB, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Castle.
            for (ik = 0; ik < CastleMidle; ik++)
            {
                if (CastlesOnTable == null || CastlesOnTable[ik] == null || CastlesOnTable[ik].CastleThinking == null || CastlesOnTable[ik].CastleThinking[0] == null || CastlesOnTable[ik].CastleThinking[0].HeuristicListCastle == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < CastlesOnTable[ik].CastleThinking[0].HeuristicListCastle.Count; j++)
                {
                    //when node is serving node continue
                    if (CastlesOnTable[ik].CastleThinking[0].IsSupHu[j]
                 )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 4, ik, j))
                            continue;

                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, ik, j, 0))
                            continue;

                        //when is self
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }

                            else
                            {
                                PreviousLessB = CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                                Index[3] = ik;
                                jIndex[3] = j;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {

                            }

                            else
                            {
                                PreviousLessB = CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                                Index[3] = ik;
                                jIndex[3] = j;
                            }
                        }
                    }
                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeMinisterGray(ref int PreviousLessM, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Minister.
            for (ik = 0; ik < MinisterMidle; ik++)
            {
                if (MinisterOnTable == null || MinisterOnTable[ik] == null || MinisterOnTable[ik].MinisterThinking == null || MinisterOnTable[ik].MinisterThinking[0] == null || MinisterOnTable[ik].MinisterThinking[0].HeuristicListMinister == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].HeuristicListMinister.Count; j++)
                {
                    //when node is serving node continue
                    if (MinisterOnTable[ik].MinisterThinking[0].IsSupHu[j]
                      )
                        continue;

                    //when node is empty deeper and there is not computatiional node continue
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 5, ik, j))
                        continue;


                    //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, ik, j, 0))
                        continue;


                    Object O = new Object();
                    lock (O)
                    {

                        //when is self
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }

                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }

                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                            }
                        }

                    }
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeMinisterGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeKingGray(ref int PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //King.
            for (ik = 0; ik < KingMidle; ik++)
            {
                if (KingOnTable == null || KingOnTable[ik] == null || KingOnTable[ik].KingThinking == null || KingOnTable[ik].KingThinking[0] == null || KingOnTable[ik].KingThinking[0].HeuristicListKing == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < KingOnTable[ik].KingThinking[0].HeuristicListKing.Count; j++)
                {
                    //when node is serving node continue
                    if (KingOnTable[ik].KingThinking[0].IsSupHu[j]
                      )
                        continue;

                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 6, ik, j))
                            continue;

                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(KingOnTable[ik].KingThinking[0].TableListKing[j], Order, ik, j, 0))
                            continue;

                        //when is self
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }

                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }

                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                            }
                        }

                    }
                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeKingGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeSolder(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {

                //when do permite
                if (Index[0] != -1)
                {
                    if (SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count == 0)
                        SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]]));
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][0], SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][1], a, SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]], Order, false, FOUND, LeafAStarGreedy);

                }
            }

            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeSolder:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeElephant(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[1] != -1)
                {
                    if (ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count == 0)
                        ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]]));
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][0], ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][1], a, ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]], Order, false, FOUND, LeafAStarGreedy);

                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeElephant:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeHourse(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[2] != -1)
                {
                    if (HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count == 0)
                        HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]]));
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][0], HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][1], a, HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]], Order, false, FOUND, LeafAStarGreedy);

                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeHourse:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeCastle(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[3] != -1)
                {
                    if (CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count == 0)
                        CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(CastlesOnTable[Index[3]].CastleThinking[0].TableListCastle[jIndex[3]]));
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, CastlesOnTable[Index[3]].CastleThinking[0].RowColumnCastle[jIndex[3]][0], CastlesOnTable[Index[3]].CastleThinking[0].RowColumnCastle[jIndex[3]][1], a, CastlesOnTable[Index[3]].CastleThinking[0].TableListCastle[jIndex[3]], Order, false, FOUND, LeafAStarGreedy);

                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeCastle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeMinister(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[4] != -1)
                {
                    if (MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count == 0)
                        MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]]));
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][0], MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][1], a, MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]], Order, false, FOUND, LeafAStarGreedy);

                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeMinister:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeKing(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[5] != -1)
                {
                    if (KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count == 0)
                        KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]]));
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][0], KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][1], a, KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]], Order, false, FOUND, LeafAStarGreedy);

                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeKing:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeSolderBrown(ref int PreviousLessS, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (ik = SodierMidle; ik < SodierHigh; ik++)
            {
                if (SolderesOnTable == null || SolderesOnTable[ik] == null || SolderesOnTable[ik].SoldierThinking == null || SolderesOnTable[ik].SoldierThinking[0] == null || SolderesOnTable[ik].SoldierThinking[0].HeuristicListSolder == null
                    )
                    continue;
                //Soldier.
                //when there is computational lists
                for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].HeuristicListSolder.Count; j++)
                {
                    //when node is serving node continue
                    if (SolderesOnTable[ik].SoldierThinking[0].IsSupHu[j]
                   )
                        continue;
                    //when node is empty deeper and there is not computatiional node continue
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 1, ik, j))
                        continue;

                 
                    //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, ik, j, 0))
                        continue;


                    //when is self
                    if (AllDraw.OrderPlate == Order)
                    {

                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }

                        else
                        {
                            Index[0] = ik;
                            jIndex[0] = j;
                            PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }

                        else
                        {
                            Index[0] = ik;
                            jIndex[0] = j;
                            PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }
                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeSolderBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeElephantBrown(ref int PreviousLessE, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Elephant
            for (ik = ElefantMidle; ik < ElefantHigh; ik++)
            {
                if (ElephantOnTable == null || ElephantOnTable[ik] == null || ElephantOnTable[ik].ElefantThinking == null || ElephantOnTable[ik].ElefantThinking[0] == null || ElephantOnTable[ik].ElefantThinking[0].HeuristicListElefant == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].HeuristicListElefant.Count; j++)
                {
                    //when node is serving node continue
                    if (ElephantOnTable[ik].ElefantThinking[0].IsSupHu[j]
                 )
                        continue;

                    //when node is empty deeper and there is not computatiional node continue
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 2, ik, j))
                        continue;

                  
                    //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, ik, j, 0))
                        continue;

                    //when is self
                    if (AllDraw.OrderPlate == Order)
                    {

                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                        }

                        else
                        {
                            Index[1] = ik;
                            jIndex[1] = j;
                            PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                        }

                        else
                        {
                            Index[1] = ik;
                            jIndex[1] = j;
                            PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }


                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeElephantBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeHourseBrown(ref int PreviousLessH, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Hourse.
            for (ik = HourseMidle; ik < HourseHight; ik++)
            {
                if (HoursesOnTable == null || HoursesOnTable[ik] == null || HoursesOnTable[ik].HourseThinking == null || HoursesOnTable[ik].HourseThinking[0] == null || HoursesOnTable[ik].HourseThinking[0].HeuristicListHourse == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].HeuristicListHourse.Count; j++)
                {
                    //when node is serving node continue
                    if (HoursesOnTable[ik].HourseThinking[0].IsSupHu[j]
                    )
                        continue;
                    //when node is empty deeper and there is not computatiional node continue
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 3, ik, j))
                        continue;

                      //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, ik, j, 0))
                        continue;

                    //when is self
                    if (AllDraw.OrderPlate == Order)
                    {

                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                        }

                        else
                        {
                            Index[2] = ik;
                            jIndex[2] = j;
                            PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }

                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                        }

                        else
                        {
                            Index[2] = ik;
                            jIndex[2] = j;
                            PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }

                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeHourseBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //main blitz for determination about best movment of every objects
        public int FullGameMakimgBlitz(ref int[] Index, ref int[] jIndex, int Order, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int Kind = -1;
            int PS = Int32.MinValue, PE = Int32.MinValue, PH = Int32.MinValue, PB = Int32.MinValue, PM = Int32.MinValue, PK = Int32.MinValue;
            if (Order != AllDraw.OrderPlate)
            {
                PS = Int32.MaxValue;
                PE = Int32.MaxValue;
                PH = Int32.MaxValue;
                PB = Int32.MaxValue;
                PM = Int32.MaxValue;
                PK = Int32.MaxValue;

            }

            int[] index = { -1, -1, -1, -1, -1, -1 };
            int[] jindex = { -1, -1, -1, -1, -1, -1 };
            if (Order == 1)
            {
                Object O = new Object();
                lock (O)
                {
                    BlitzGameThinkingTreeSolderGray(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeElephantGray(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeHourseGray(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastleGray(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeMinisterGray(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeKingGray(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                }

            }
            else
            {
                Object O = new Object();
                lock (O)
                {
                    BlitzGameThinkingTreeSolderBrown(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeElephantBrown(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeHourseBrown(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastleBrown(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeMinisterBrown(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeKingBrown(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                }
            }
            int JI = -1;
            Object O1 = new Object();
            lock (O1)
            {

                if (Order == OrderPlate)
                    JI = MaxOfSixHeuristic(PS, PE, PH, PB, PM, PK);
                else
                    JI = MinOfSixHeuristic(PS, PE, PH, PB, PM, PK);
            }
            if (JI != -1)
            {
                Kind = JI;
                for (var i = 0; i < 6; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        Index[i] = index[i];
                        jIndex[i] = jindex[i];
                    }
                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameMakimgBlitz:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return System.Math.Abs(Kind);
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeCastleBrown(ref int PreviousLessB, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Castles.
            for (ik = CastleMidle; ik < CastleHigh; ik++)
            {
                if (CastlesOnTable == null || CastlesOnTable[ik] == null || CastlesOnTable[ik].CastleThinking == null || CastlesOnTable[ik].CastleThinking[0] == null || CastlesOnTable[ik].CastleThinking[0].HeuristicListCastle == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < CastlesOnTable[ik].CastleThinking[0].HeuristicListCastle.Count; j++)
                {
                    //when node is serving node continue
                    if (CastlesOnTable[ik].CastleThinking[0].IsSupHu[j]
                    )
                        continue;

                    //when node is empty deeper and there is not computatiional node continue
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 4, ik, j))
                        continue;

              
                    //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, ik, j, 0))
                        continue;


                    //when is self
                    if (AllDraw.OrderPlate == Order)
                    {

                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                        }


                        else
                        {
                            Index[3] = ik;
                            jIndex[3] = j;
                            PreviousLessB = CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }

                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {

                        }


                        else
                        {
                            Index[3] = ik;
                            jIndex[3] = j;
                            PreviousLessB = CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }

                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeCastleBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeMinisterBrown(ref int PreviousLessM, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Minister.
            for (ik = MinisterMidle; ik < MinisterHigh; ik++)
            {
                if (MinisterOnTable == null || MinisterOnTable[ik] == null || MinisterOnTable[ik].MinisterThinking == null || MinisterOnTable[ik].MinisterThinking[0] == null || MinisterOnTable[ik].MinisterThinking[0].HeuristicListMinister == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].HeuristicListMinister.Count; j++)
                {
                    //when node is serving node continue
                    if (MinisterOnTable[ik].MinisterThinking[0].IsSupHu[j]
                      )
                        continue;

     
                        //when node is empty deeper and there is not computatiional node continue
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 5, ik, j))
                        continue;

                      //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, ik, j, 0))
                        continue;

                    //when is self
                    if (AllDraw.OrderPlate == Order)
                    {

                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                        }
                        else
                        //if (KingDan(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order))
                        {
                            Index[4] = ik;
                            jIndex[4] = j;
                            PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        //if (KingDan(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order))
                        {
                            Index[4] = ik;
                            jIndex[4] = j;
                            PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }
                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeMinisterBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeKingBrown(ref int PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //King.
            for (ik = KingMidle; ik < KingHigh; ik++)
            {
                if (KingOnTable == null || KingOnTable[ik] == null || KingOnTable[ik].KingThinking == null || KingOnTable[ik].KingThinking[0] == null || KingOnTable[ik].KingThinking[0].HeuristicListKing == null
                    )
                    continue;
                //when there is computational lists
                for (j = 0; j < KingOnTable[ik].KingThinking[0].HeuristicListKing.Count; j++)
                {
                    //when node is serving node continue
                    if (KingOnTable[ik].KingThinking[0].IsSupHu[j]
                     )
                        continue;
                    
                        //when node is empty deeper and there is not computatiional node continue
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 6, ik, j))
                        continue;

                   
                    //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(KingOnTable[ik].KingThinking[0].TableListKing[j], Order, ik, j, 0))
                        continue;

                    //when is self
                    if (AllDraw.OrderPlate == Order)
                    {

                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }

                        else
                        {
                            Index[5] = ik;
                            jIndex[5] = j;
                            PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }

                        else
                        {
                            Index[5] = ik;
                            jIndex[5] = j;
                            PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled);
                        }
                    }


                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTreeKingBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTree(int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            Color a;
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            //Order *= -1;
            //ChessRules.CurrentOrder *= -1;
            int[] Index = new int[6];

            int[] jIndex = new int[6];
            int PreviousLessS = Int32.MinValue, PreviousLessE = Int32.MinValue, PreviousLessH = Int32.MinValue, PreviousLessB = Int32.MinValue, PreviousLessM = Int32.MinValue, PreviousLessK = Int32.MinValue;
            if (Order != OrderPlate)
            {
                PreviousLessS = Int32.MaxValue;
                PreviousLessE = Int32.MaxValue;
                PreviousLessH = Int32.MaxValue;
                PreviousLessB = Int32.MaxValue;
                PreviousLessM = Int32.MaxValue;
                PreviousLessK = Int32.MaxValue;

            }
            //For Gray Order calculating foreach Objects Maximum total Heuristic Count Incl;usively.
            if (Order == 1)
            {
                Object O1 = new Object();
                lock (O1)
                {
                    Index[0] = -1;
                    BlitzGameThinkingTreeSolderGray(ref PreviousLessS, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[1] = -1;
                    BlitzGameThinkingTreeElephantGray(ref PreviousLessE, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[2] = -1;
                    BlitzGameThinkingTreeHourseGray(ref PreviousLessH, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[3] = -1;
                    BlitzGameThinkingTreeCastleGray(ref PreviousLessB, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[4] = -1;
                    BlitzGameThinkingTreeMinisterGray(ref PreviousLessM, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[5] = -1;
                    BlitzGameThinkingTreeKingGray(ref PreviousLessK, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                }
                int JI = -1;
                Object O2 = new Object();
                lock (O2)
                {

                    JI = MaxOfSixHeuristic(PreviousLessS, PreviousLessE, PreviousLessH, PreviousLessB, PreviousLessM, PreviousLessK);
                }

                Object O3 = new Object();
                lock (O3)
                {
                    if (JI != -1)
                    {
                        if (JI == 0)
                            BlitzGameTreeCreationThinkingTreeSolder(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 1)

                            BlitzGameTreeCreationThinkingTreeElephant(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 2)

                            BlitzGameTreeCreationThinkingTreeHourse(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 3)
                            BlitzGameTreeCreationThinkingTreeCastle(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 4)
                            BlitzGameTreeCreationThinkingTreeMinister(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 5)
                            BlitzGameTreeCreationThinkingTreeKing(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                    }
                }
            }
            //For Brown Order Blitz Game Calculate Maximum Heuristic Inclusive AStarGreedy First Game Search.
            else
            {
                Object O1 = new Object();
                lock (O1)
                {
                    Index[0] = -1;
                    BlitzGameThinkingTreeSolderBrown(ref PreviousLessS, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[1] = -1;
                    BlitzGameThinkingTreeElephantBrown(ref PreviousLessE, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[2] = -1;
                    BlitzGameThinkingTreeHourseBrown(ref PreviousLessH, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[3] = -1;
                    BlitzGameThinkingTreeCastleBrown(ref PreviousLessB, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[4] = -1;
                    BlitzGameThinkingTreeMinisterBrown(ref PreviousLessM, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[5] = -1;
                    BlitzGameThinkingTreeKingBrown(ref PreviousLessK, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                }
                int JI = -1;
                Object O2 = new Object();
                lock (O2)
                {
                    JI = MaxOfSixHeuristic(PreviousLessS, PreviousLessE, PreviousLessH, PreviousLessB, PreviousLessM, PreviousLessK);
                }
                Object O3 = new Object();
                lock (O3)
                {
                    if (JI != -1)
                    {
                        BlitzGameTreeCreationThinkingTreeSolder(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;

                        BlitzGameTreeCreationThinkingTreeElephant(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;

                        if (JI == 2)

                            BlitzGameTreeCreationThinkingTreeHourse(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;

                        if (JI == 3)
                            BlitzGameTreeCreationThinkingTreeCastle(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 4)
                            BlitzGameTreeCreationThinkingTreeMinister(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;

                        if (JI == 5)
                            BlitzGameTreeCreationThinkingTreeKing(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);


                    }
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzGameThinkingTree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //calculate statistic move
        String Alphabet(int RowRealesed)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            String A = "";
            if (RowRealesed == 0)
                A = "a";
            else
                if (RowRealesed == 1)
                A = "b";
            else
                    if (RowRealesed == 2)
                A = "c";
            else
                        if (RowRealesed == 3)
                A = "d";
            else
                            if (RowRealesed == 4)
                A = "e";
            else
                                if (RowRealesed == 5)
                A = "f";
            else
                                    if (RowRealesed == 6)
                A = "g";
            else
                                        if (RowRealesed == 7)
                A = "h";
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("Alphabet:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return A;




        }
        //calculate statistic move
        String Number(int ColumnRealeased)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            String A = "";
            if (ColumnRealeased == 7)
                A = "0";
            else
                if (ColumnRealeased == 6)
                A = "1";
            else
                    if (ColumnRealeased == 5)
                A = "2";
            else
                        if (ColumnRealeased == 4)
                A = "3";
            else
                            if (ColumnRealeased == 3)
                A = "4";
            else
                                if (ColumnRealeased == 2)
                A = "5";
            else
                                    if (ColumnRealeased == 1)
                A = "6";
            else
                                        if (ColumnRealeased == 0)
                A = "7";
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("Number:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return A;




        }
        //number of bounry object
        int SumOfObjects(AllDraw A, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int Sum = 0;
            if (A == null)
                return Sum;
            if (Order == 1)
            {
                for (var i = 0; i < A.SodierMidle; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.ElefantMidle; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.HourseMidle; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.CastleMidle; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.MinisterMidle; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.KingMidle; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].WinOcuuredatChiled;
                }

            }
            else
            {
                for (var i = A.SodierMidle; i < A.SodierHigh; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.ElefantMidle; i < A.ElefantHigh; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.HourseMidle; i < A.HourseHight; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.CastleMidle; i < A.CastleHigh; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].WinOcuuredatChiled;
                }

                for (var i = A.MinisterMidle; i < A.MinisterHigh; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.KingMidle; i < A.KingHigh; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].WinOcuuredatChiled;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("SumOfObjects:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Sum;
        }
        //victome transfer leafs to rooots chiled
        int SumMinusOfObjects(AllDraw A, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int Sum = 0;
            if (A == null)
                return Sum;
            if (Order == 1)
            {
                for (var i = 0; i < A.SodierMidle; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.ElefantMidle; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.HourseMidle; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.CastleMidle; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.MinisterMidle; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.KingMidle; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].LoseOcuuredatChiled;
                }

            }
            else
            {
                for (var i = A.SodierMidle; i < A.SodierHigh; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = A.ElefantMidle; i < A.ElefantHigh; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = A.HourseMidle; i < A.HourseHight; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = A.CastleMidle; i < A.CastleHigh; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].LoseOcuuredatChiled;
                }

                for (var i = A.MinisterMidle; i < A.MinisterHigh; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = A.KingMidle; i < A.KingHigh; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].LoseOcuuredatChiled;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("SumMinusOfObjects:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Sum;
        }
        //Semaphore determination about Thinking operational completed.
        bool ReturnFullGameThinkingTreeSemaphore(int ik, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //soldier
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].ThinkingBegin && (!SolderesOnTable[ik].SoldierThinking[0].ThinkingFinished))
                    return true;
            }
            else//elephant
                if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].ThinkingBegin && (!ElephantOnTable[ik].ElefantThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 3)//hourse
            {
                if (HoursesOnTable[ik].HourseThinking[0].ThinkingBegin && (!HoursesOnTable[ik].HourseThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 4)//Castle
            {
                if (CastlesOnTable[ik].CastleThinking[0].ThinkingBegin && (!CastlesOnTable[ik].CastleThinking[0].ThinkingFinished))
                    return true;
            }
            else
                if (kind == 5)//minister
            {
                if (MinisterOnTable[ik].MinisterThinking[0].ThinkingBegin && (!MinisterOnTable[ik].MinisterThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 6)//king
            {
                if (KingOnTable[ik].KingThinking[0].ThinkingBegin && (!KingOnTable[ik].KingThinking[0].ThinkingFinished))
                    return true;
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("ReturnFullGameThinkingTreeSemaphore:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return false;
        }
        //determination about learning autamata semaphores permit of operational computational 
        bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(int ik, int kind, bool Penalty, int j)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //when is learning autamata
            if (Penalty)
            {
                //soldier
                if (kind == 1)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else//elephant
                                if (kind == 2)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 3)//hourse
                {
                    if (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 4)//Castle
                {
                    if (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                    if (kind == 5)//minister
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 6)//king
                {
                    if (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
            }
            else//brown
            {
                if (kind == 1)//soldier
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                         if (kind == 2)//elephant
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 3)//hourse
                {
                    if (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 4)//Castle
                {
                    if (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                    if (kind == 5)//minister
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 6)//king
                {
                    if (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return false;
        }
        //determiniation about deeper increamental of a part
        void BlitzNotValidFullGameThinkingTreePartOne(int ik, int Order, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //soldier
            if (kind == 1)
            {
                //when valid 
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count > SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy == null)
                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 2)///elephant
            {
                //when valid 
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count > ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy == null)
                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid 
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count > HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy == null)
                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid 
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count > CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy == null)
                        CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid 
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count > MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy == null)
                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid 
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count > KingOnTable[ik].KingThinking[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinking[0].AStarGreedy == null)
                        KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                    KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzNotValidFullGameThinkingTreePartOne:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //determiniation about deeper increamental of a part
        void BlitzNotValidFullGameThinkingTreePartTow(int ik, int Order, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (kind == 1)//soldier
            {
                //when valid 
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count > SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy == null)
                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 2)//elephant
            {
                //when valid 
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count > ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy == null)
                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid 
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count > HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy == null)
                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid 
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count > CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy == null)
                        CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid 
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count > MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy == null)
                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid 
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count > KingOnTable[ik].KingThinking[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinking[0].AStarGreedy == null)
                        KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                    KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }    //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzNotValidFullGameThinkingTreePartTow:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //determiniation about deeper increamental of a part
        void BlitzNotValidFullGameThinkingTreePartThree(int ik, int Order, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //long Time = TimeElapced.TimeNow();Spaces++;
            //soldier
            if (kind == 1)
            {
                //when valid 
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count > SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy == null)
                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 2)//elephant
            {
                //when valid 
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count > ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy == null)
                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid 
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count > HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy == null)
                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid 
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count > CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy == null)
                        CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid 
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count > MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy == null)
                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid 
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count > KingOnTable[ik].KingThinking[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinking[0].AStarGreedy == null)
                        KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                    KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("BlitzNotValidFullGameThinkingTreePartThree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //operantinal of creation of current deeper node and set string making
        void FullGameThinkingTreeInitialization(int ik, int j, int Order, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //soldier
            if (kind == 1)
            {
                //when valid do create of deeper node and string making
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count == SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy == null)
                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].TableList.Add(CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]));
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 2)//elephant 
            {
                //when valid do create of deeper node and string making
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count == ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy == null)
                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].TableList.Add(CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]));
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid do create of deeper node and string making
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count == HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy == null)
                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].TableList.Add(CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]));
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid do create of deeper node and string making
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count == CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy == null)
                        CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]));
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid do create of deeper node and string making
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count == MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy == null)
                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].TableList.Add(CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]));
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid do create of deeper node and string making
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count == KingOnTable[ik].KingThinking[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinking[0].AStarGreedy == null)
                        KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].TableList.Clear();
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]));
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeInitialization:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //main operation of full game deeper created compuational to deeper need.
        void OpOfFullGameThinkingTree(int ik, int j, int Order, int iAStarGreedy, int ii, int jj, Color a, int kind, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //soldier
            if (kind == 1)
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 1))
                //return;

                //minitor
                OutPutAction = " " + Alphabet(SolderesOnTable[ik].SoldierThinking[0].Row) + Number(SolderesOnTable[ik].SoldierThinking[0].Column) + Alphabet(SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][0]) + Number(SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][1]);
                //if (Order == 1)
                //OutPut.Append("\r\nPerception Soldier AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                //else
                //OutPut.Append("\r\nPerception Soldier AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                //operational 
                PerceptionCount++;
                var iii = SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][0];
                var jjj = SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]);
                int Ord = Order;
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                var array1 = Task.Factory.StartNew(() => SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                //array1.ConfigureAwait(false);
                array1.Wait(); array1.Dispose();//TH.Add(array1);
            }
            else if (kind == 2)//elephant 
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 2))
                //return;

                //minitor
                OutPutAction = " " + Alphabet(ElephantOnTable[ik].ElefantThinking[0].Row) + Number(ElephantOnTable[ik].ElefantThinking[0].Column) + Alphabet(ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][0]) + Number(ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][1]);
                //if (Order == 1)
                //OutPut.Append("\r\nPerception Elephant AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                //else
                //OutPut.Append("\r\nPerception Elephant AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                //operational 
                PerceptionCount++;
                var iii = ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][0];
                var jjj = ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]);
                int Ord = Order;
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;

                var array1 = Task.Factory.StartNew(() => ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy));
                //array1.ConfigureAwait(false);
                array1.Wait(); array1.Dispose();//TH.Add(array1);

            }
            else if (kind == 3)//hourse
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 3))
                //return;

                //minitor
                OutPutAction = " " + Alphabet(HoursesOnTable[ik].HourseThinking[0].Row) + Number(HoursesOnTable[ik].HourseThinking[0].Column) + Alphabet(HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][0]) + Number(HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][1]);
                //if (Order == 1)
                //OutPut.Append("\r\nPerception Hourse AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                //else
                //OutPut.Append("\r\nPerception Hourse AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                //operational 
                PerceptionCount++;
                var iii = HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][0];
                var jjj = HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]);
                int Ord = Order;
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                var array1 = Task.Factory.StartNew(() => HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy));
                //array1.ConfigureAwait(false);
                array1.Wait(); array1.Dispose();//TH.Add(array1);


            }
            else if (kind == 4)//Castle
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 4))
                //return;

                //minitor
                OutPutAction = " " + Alphabet(CastlesOnTable[ik].CastleThinking[0].Row) + Number(CastlesOnTable[ik].CastleThinking[0].Column) + Alphabet(CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][0]) + Number(CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][1]);
                //if (Order == 1)
                //OutPut.Append("\r\nPerception Castle AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                //else
                //OutPut.Append("\r\nPerception Castle AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                //operational 
                PerceptionCount++;
                var iii = CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][0];
                var jjj = CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]);
                int Ord = Order;
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                var array1 = Task.Factory.StartNew(() => CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy));
                //array1.ConfigureAwait(false);
                array1.Wait(); array1.Dispose();//TH.Add(array1);

            }
            else if (kind == 5)//minister
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 5))
                //return;

                //minitor
                OutPutAction = " " + Alphabet(MinisterOnTable[ik].MinisterThinking[0].Row) + Number(MinisterOnTable[ik].MinisterThinking[0].Column) + Alphabet(MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][0]) + Number(MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][1]);
                //if (Order == 1)
                //OutPut.Append("\r\nPerception Minister AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                //else
                //OutPut.Append("\r\nPerception Minister AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                //operational 
                PerceptionCount++;
                var iii = MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][0];
                var jjj = MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]);
                int Ord = Order;
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;

                var array1 = Task.Factory.StartNew(() => MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy));
                //array1.ConfigureAwait(false);
                array1.Wait(); array1.Dispose();//TH.Add(array1);

            }
            else if (kind == 6)//king
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 6))
                //return;

                //minitor
                OutPutAction = " " + Alphabet(KingOnTable[ik].KingThinking[0].Row) + Number(KingOnTable[ik].KingThinking[0].Column) + Alphabet(KingOnTable[ik].KingThinking[0].RowColumnKing[j][0]) + Number(KingOnTable[ik].KingThinking[0].RowColumnKing[j][1]);
                //if (Order == 1)
                //OutPut.Append("\r\nPerception King AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                //else
                //OutPut.Append("\r\nPerception King AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                //operational 
                PerceptionCount++;
                var iii = KingOnTable[ik].KingThinking[0].RowColumnKing[j][0];
                var jjj = KingOnTable[ik].KingThinking[0].RowColumnKing[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]);
                int Ord = Order;
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;

                var array1 = Task.Factory.StartNew(() => KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy));
                //array1.ConfigureAwait(false);

                array1.Wait(); array1.Dispose();//TH.Add(array1);


            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("OpOfFullGameThinkingTree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        bool ReturnFullGameThinkingTreeIligalSemaphore(int ik, int kind)
        {
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count == 0)
                    return true;
            }
            else//elephant
              if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count == 0)
                    return true;
            }
            else if (kind == 3)//hourse
            {
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count == 0)
                    return true;
            }
            else if (kind == 4)//Castle
            {
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count == 0)
                    return true;
            }
            else
                if (kind == 5)//minister
            {
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count == 0)
                    return true;
            }
            else if (kind == 6)//king
            {
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count == 0)
                    return true;
            }
            return false;
        }

        //decicion for deeper satisfied boundry condition of full game methods group
        void ReturnFullGameThinkingTreeSemaphoreAs(int Order, int iAStarGreedy, int ik, int Kind)
        {
            Object OO1 = new Object();
            lock (OO1)
            {
                TaskBegin++;
                //main decistion
                while (ReturnFullGameThinkingTreeSemaphore(ik, Kind))
                {

                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        break;

                }


            }
        }
        //deeper for soldier
        bool FullGameThinkingTreeSoldier(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 1))
                    return false;

                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, iAStarGreedy, ik, 1));
                //array.ConfigureAwait(false);
                array.Wait(); array.Dispose();

                Object OOOO = new Object();
                lock (OOOO)
                {

                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;

                }

                //Parallel.For(0, SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count; j++)
                {
                    if (IsSupHuTrue(ik, j, 0, 1))
                        continue;
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;

                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, ik, j, 0))
                            continue;
                        //sereved continuce
                        if (SolderesOnTable[ik].SoldierThinking[0].IsSupHu[j])
                            continue;
                        //self do
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 1, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[0] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[0])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                            continue;
                                        }
                                        else//computational lists semaphore
                                        if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 1);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 1);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);

                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 1);
                                }
                                //when deeper is valid
                                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();

                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 1, FOUND, LeafAStarGreedy);

                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 1, false, j)

                            )
                            {

                                //when do permite
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[0] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[0])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                            continue;
                                        }
                                        else//computational lists semaphore
                                        if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 1);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 1);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 1);
                                }
                                //when deeper is valid
                                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();

                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 1, FOUND, LeafAStarGreedy);

                                        Do = true;
                                    }
                                }


                            }
                        }

                    }
                }//);

                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            //non learning autamata victory leafs
            for (int h = 0; h < SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinking[0].AStarGreedy != null; h++)
                SolderesOnTable[ik].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[h], Order);
            //non learning autamata victom leafs
            for (int h = 0; h < SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinking[0].AStarGreedy != null; h++)
                SolderesOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[h], Order);
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeSoldier:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
            //Elephant
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeSoldierGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[0] = true;


                Parallel.For(0, SodierMidle, ik =>
                //for (var ik = 0; ik < SodierMidle; ik++)
                {
                    if (SolderesOnTable != null && SolderesOnTable[ik] != null && SolderesOnTable[ik].SoldierThinking != null && SolderesOnTable[ik].SoldierThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeSoldier(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);


                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeSoldierGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeElephant(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 2))
                    return false;

                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, iAStarGreedy, ik, 2));
                array.Wait(); array.Dispose();

                Object OOOO = new Object();
                lock (OOOO)
                {


                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;



                }

                ////Parallel.For(0, ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        if (IsSupHuTrue(ik, j, 0, 2))
                            continue;
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;

                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, ik, j, 0))
                            continue;

                        //sereved continuce
                        if (ElephantOnTable[ik].ElefantThinking[0].IsSupHu[j])
                            continue;

                        //self do
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 2, true, j)
                            )
                            {

                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[1] != -1)
                                    {

                                        //object kind semaphore
                                        if (ik != Index[1])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[1])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 2);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 2);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);

                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 2);

                                    //when deeper is valid
                                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Object O = new Object();
                                        lock (O)
                                        {
                                            //do deeper
                                            OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 2, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 2, false, j)

                            )
                            {

                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[1] != -1)
                                    {

                                        //object kind semaphore
                                        if (ik != Index[1])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[1])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 2);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 2);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);

                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 2);

                                    //when deeper is valid
                                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Object O = new Object();
                                        lock (O)
                                        {
                                            //do deeper
                                            OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 2, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }

                                }
                            }
                        }

                    }
                }//);


                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            //non learning autamata victory leafs
            for (int h = 0; h < ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinking[0].AStarGreedy != null; h++)
                ElephantOnTable[ik].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[h], Order);
            //non learning autamata victom leafs
            for (int h = 0; h < ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinking[0].AStarGreedy != null; h++)
                ElephantOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[h], Order);
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeElephant:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeElephantGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[1] = true;

                //Elephant

                Parallel.For(0, ElefantMidle, ik =>
                //for (var ik = 0; ik < ElefantMidle; ik++)
                {
                    if (ElephantOnTable != null && ElephantOnTable[ik] != null && ElephantOnTable[ik].ElefantThinking != null && ElephantOnTable[ik].ElefantThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeElephant(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);
                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeElephantGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeHourse(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 3))
                    return false;

                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, iAStarGreedy, ik, 3));
                array.Wait(); array.Dispose();


                Object OOOO = new Object();
                lock (OOOO)
                {


                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;


                }

                ////Parallel.For(0, HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        if (IsSupHuTrue(ik, j, 0, 3))
                            continue;

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;

                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, ik, j, 0))
                            continue;

                        //sereved continuce
                        if (HoursesOnTable[ik].HourseThinking[0].IsSupHu[j])
                            continue;


                        //self do
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 3, true, j)
                            )
                            {

                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[2] != -1)
                                    {

                                        //object kind semaphore
                                        if (ik != Index[2])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[2])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 3);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 3);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);


                                Object O3 = new Object();
                                lock (O3)
                                {
                                    FullGameThinkingTreeInitialization(ik, j, Order, 3);
                                }
                                //HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, false,ref HaveKilled);
                                //ParameterizedThreadStart start = new ParameterizedThreadStart(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 3, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }

                            }
                            else
                            {
                                //when certification for continued of code satisfied
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 3, false, j)

                                )
                                {

                                    //when blitz game (limited game)
                                    if (AllDraw.Blitz)
                                    {
                                        //when do permite
                                        if (Index[2] != -1)
                                        {

                                            //object kind semaphore
                                            if (ik != Index[2])
                                            {
                                                //satisfied of created deeper one
                                                BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                                continue;
                                            }
                                            else
                                                if (j != jindex[2])
                                            {
                                                //satisfied of created deeper tow
                                                BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 3);
                                                continue;
                                            }
                                        }
                                        else
                                        {
                                            //satisfied of created deeper three
                                            BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 3);
                                            continue;
                                        }
                                    }
                                    else
                                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);



                                    Object O3 = new Object();
                                    lock (O3)
                                    {
                                        //initiate for satisfied full game primary conditions
                                        FullGameThinkingTreeInitialization(ik, j, Order, 3);
                                    }
                                    //HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, false,ref HaveKilled);
                                    //ParameterizedThreadStart start = new ParameterizedThreadStart(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                    //when deeper is valid
                                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Object O = new Object();
                                        lock (O)
                                        {
                                            //do deeper
                                            OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 3, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }

                                }
                            }
                        }

                    }
                }//);


                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            //non learning autamata victory leafs
            for (int h = 0; h < HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinking[0].AStarGreedy != null; h++)
                HoursesOnTable[ik].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[h], Order);
            //non learning autamata victom leafs
            for (int h = 0; h < HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinking[0].AStarGreedy != null; h++)
                HoursesOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[h], Order);
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeHourse:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeHourseGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[2] = true;

                //Hourse.

                Parallel.For(0, HourseMidle, ik =>
                //for (var ik = 0; ik < HourseMidle; ik++)
                {
                    if (HoursesOnTable != null && HoursesOnTable[ik] != null && HoursesOnTable[ik].HourseThinking != null && HoursesOnTable[ik].HourseThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeHourse(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);


                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeHourseGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeCastle(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 4))
                    return false;

                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, iAStarGreedy, ik, 4));
                array.Wait(); array.Dispose();

                Object OOOO = new Object();
                lock (OOOO)
                {


                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;


                }

                ////Parallel.For(0, CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count; j++)
                {
                    if (IsSupHuTrue(ik, j, 0, 4))
                        continue;
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;

                    }
                    //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, ik, j, 0))
                        continue;

                    //sereved continuce
                    if (CastlesOnTable[ik].CastleThinking[0].IsSupHu[j])
                        continue;
                    Object ooo = new Object();
                    lock (ooo)
                    {

                        //self do
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 4, true, j)
                            )
                            {

                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[3] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[3])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 4);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 4);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);

                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 4);
                                }
                                //CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, false,ref HaveKilled);
                                //ParameterizedThreadStart start = new ParameterizedThreadStart(CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                //when deeper is valid
                                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 4, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 4, false, j)

                            )
                            {

                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[3] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[3])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 4);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 4);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);

                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 4);
                                }
                                //CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, false,ref HaveKilled);
                                //ParameterizedThreadStart start = new ParameterizedThreadStart(CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                //when deeper is valid
                                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 4, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }

                            }
                        }

                    }
                }//);
                /*if (tHA.Count > 1)
                {
                    var array = Task.Factory.StartNew(() => Parallel.ForEach(tHA, items => Task.WaitAll(items)));
                    //array.Start();
                    Task.WaitAll(array);
                }*/
                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            //non learning autamata victory leafs
            for (int h = 0; h < CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinking[0].AStarGreedy != null; h++)
                CastlesOnTable[ik].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[ik].CastleThinking[0].AStarGreedy[h], Order);
            for (int h = 0; h < CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinking[0].AStarGreedy != null; h++)
                CastlesOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(CastlesOnTable[ik].CastleThinking[0].AStarGreedy[h], Order);
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeCastle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeCastleGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[3] = true;

                //Castle.

                Parallel.For(0, CastleMidle, ik =>
                //for (var ik = 0; ik < CastleMidle; ik++)
                {
                    if (CastlesOnTable != null && CastlesOnTable[ik] != null && CastlesOnTable[ik].CastleThinking != null && CastlesOnTable[ik].CastleThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastle(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);


                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeMinister(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 5))
                    return false;

                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, iAStarGreedy, ik, 5));
                array.Wait(); array.Dispose();


                Object OOOO = new Object();
                lock (OOOO)
                {


                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;



                }

                ////Parallel.For(0, MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        if (IsSupHuTrue(ik, j, 0, 5))
                            continue;
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;

                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, ik, j, 0))
                            continue;

                        //sereved continuce
                        if (MinisterOnTable[ik].MinisterThinking[0].IsSupHu[j])
                            continue;




                        //self do
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 5, true, j)
                            )
                            {

                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[4] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[4])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[4])

                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 5);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 5);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);

                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 5);
                                }
                                //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, false,ref HaveKilled);
                                //ParameterizedThreadStart start = new ParameterizedThreadStart(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                //when deeper is valid
                                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 5, FOUND, LeafAStarGreedy);
                                        Do = true;

                                    }

                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 5, false, j)

                            )
                            {

                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[4] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[4])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[4])

                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 5);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 5);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);

                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 5);
                                }
                                //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, false,ref HaveKilled);
                                //ParameterizedThreadStart start = new ParameterizedThreadStart(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 5, FOUND, LeafAStarGreedy);
                                        Do = true;

                                    }

                                }

                            }
                        }

                    }
                }//);


                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            //non learning autamata victory leafs
            for (int h = 0; h < MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinking[0].AStarGreedy != null; h++)
                MinisterOnTable[ik].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[h], Order);
            //non learning autamata victom leafs
            for (int h = 0; h < MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinking[0].AStarGreedy != null; h++)
                MinisterOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[h], Order);
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeMinister:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeMinisterGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[4] = true;

                //Minister.

                Parallel.For(0, MinisterMidle, ik =>
                //for (var ik = 0; ik < MinisterMidle; ik++)
                {
                    if (MinisterOnTable != null && MinisterOnTable[ik] != null && MinisterOnTable[ik].MinisterThinking != null && MinisterOnTable[ik].MinisterThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeMinister(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);


                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeMinisterGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeKing(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 6))
                    return false;

                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, iAStarGreedy, ik, 6));
                array.Wait(); array.Dispose();


                Object OOOO = new Object();
                lock (OOOO)
                {


                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;




                }

                if (KingOnTable[ik].KingThinking[0].TableListKing.Count == 0)
                    return Do;
                // //Parallel.For(0, KingOnTable[ik].KingThinking[0].TableListKing.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < KingOnTable[ik].KingThinking[0].TableListKing.Count; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {

                        if (IsSupHuTrue(ik, j, 0, 6))
                            continue;
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;

                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(KingOnTable[ik].KingThinking[0].TableListKing[j], Order, ik, j, 0))
                            continue;

                        //sereved continuce
                        if (KingOnTable[ik].KingThinking[0].IsSupHu[j])
                            continue;

                        //when is self
                        if (AllDraw.OrderPlate == Order)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 6, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {

                                    //when do permite
                                    if (Index[5] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[5])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[5])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 6);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 6);
                                        continue;
                                    }

                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);

                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 6);
                                }
                                //KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, KingOnTable[ik].KingThinking[0].TableListKing[j], Order, false,ref HaveKilled);
                                //ParameterizedThreadStart start = new ParameterizedThreadStart(KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                //when deeper is valid
                                if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 6, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 6, false, j)

                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[5] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[5])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[5])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 6);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 6);
                                        continue;
                                    }

                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);

                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                    FullGameThinkingTreeInitialization(ik, j, Order, 6);
                                }
                                //KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, KingOnTable[ik].KingThinking[0].TableListKing[j], Order, false,ref HaveKilled);
                                //ParameterizedThreadStart start = new ParameterizedThreadStart(KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 6, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }

                    }
                }//);


                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            //non learning autamata victory leafs
            for (int h = 0; h < KingOnTable[ik].KingThinking[0].AStarGreedy.Count && KingOnTable[ik].KingThinking[0].AStarGreedy != null; h++)
                KingOnTable[ik].WinOcuuredatChiled += SumOfObjects(KingOnTable[ik].KingThinking[0].AStarGreedy[h], Order);
            //non learning autamata victom leafs
            for (int h = 0; h < KingOnTable[ik].KingThinking[0].AStarGreedy.Count && KingOnTable[ik].KingThinking[0].AStarGreedy != null; h++)
                KingOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(KingOnTable[ik].KingThinking[0].AStarGreedy[h], Order);
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeKing:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeKingGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                //int ik;
                //King.
                ThinkingAllowed[5] = true;

                Parallel.For(0, KingMidle, ik =>
                //for (var ik = 0; ik < KingMidle; ik++)
                {
                    if (KingOnTable != null && KingOnTable[ik] != null && KingOnTable[ik].KingThinking != null && KingOnTable[ik].KingThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeKing(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);


                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeKingGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeSoldierBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                ThinkingAllowed[6] = true;

                Parallel.For(SodierMidle, SodierHigh, ik =>
                //for (var ik = SodierMidle; ik < SodierHigh; ik++)
                {
                    if (SolderesOnTable != null && SolderesOnTable[ik] != null && SolderesOnTable[ik].SoldierThinking != null && SolderesOnTable[ik].SoldierThinking[0] != null
                        )
                    {
                        //Soldier.
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeSoldier(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);
                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeSoldierBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeElephantBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[7] = true;

                //Elephant

                Parallel.For(ElefantMidle, ElefantHigh, ik =>
                //for (var ik = ElefantMidle; ik < ElefantHigh; ik++)
                {
                    if (ElephantOnTable != null && ElephantOnTable[ik] != null && ElephantOnTable[ik].ElefantThinking != null && ElephantOnTable[ik].ElefantThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeElephant(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);
                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeElephantBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeHourseBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[8] = true;

                //Hourse.

                Parallel.For(HourseMidle, HourseHight, ik =>
                //for (var ik = HourseMidle; ik < HourseHight; ik++)
                {
                    if (HoursesOnTable != null && HoursesOnTable[ik] != null && HoursesOnTable[ik].HourseThinking != null && HoursesOnTable[ik].HourseThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeHourse(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);
                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeHourseBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeCastleBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[9] = true;

                //Castles.

                Parallel.For(CastleMidle, CastleHigh, ik =>
                //for (var ik = CastleMidle; ik < CastleHigh; ik++)
                {
                    if (CastlesOnTable != null && CastlesOnTable[ik] != null && CastlesOnTable[ik].CastleThinking != null && CastlesOnTable[ik].CastleThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastle(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);
                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeCastleBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeMinisterBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[10] = true;

                //Minister.

                Parallel.For(MinisterMidle, MinisterHigh, ik =>
                //for (var ik = MinisterMidle; ik < MinisterHigh; ik++)
                {
                    if (MinisterOnTable != null && MinisterOnTable[ik] != null && MinisterOnTable[ik].MinisterThinking != null && MinisterOnTable[ik].MinisterThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeMinister(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);
                        }
                    }
                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeMinisterBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeKingBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[11] = true;

                //King.

                Parallel.For(KingMidle, KingHigh, ik =>
                //for (var ik = KingMidle; ik < KingHigh; ik++)
                {

                    if (KingOnTable != null && KingOnTable[ik] != null && KingOnTable[ik].KingThinking != null && KingOnTable[ik].KingThinking[0] != null
                        )
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeKing(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                            array.Wait(); array.Dispose();//TH.Add(array);
                        }
                    }

                });
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeKingBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        public bool FullGameThinkingTreeGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            Object OOOOO = new Object();
            lock (OOOOO)
            {
                bool Do = false;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;

                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        Parallel.Invoke(() =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                                int Ord1 = OrderP;
                                Color a1 = a;
                                int iAStarGreedy1 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeSoldierBrown(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);
                                var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierGray(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy));
                                array1.Wait(); array1.Dispose();//TH.Add(array1);
                                //array1.Start();
                                //Object tttt1 = new Object(); lock (tttt1) { array1.Wait(); array1.Dispose();//TH.Add(array1); }

                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;

                                int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                                int Ord2 = Order;
                                Color a2 = a;
                                int iAStarGreedy2 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeElephantBrown(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                                var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantGray(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy));
                                array2.Wait(); array2.Dispose();//TH.Add(array2);
                                //array2.Start();
                                //Object tttt2 = new Object(); lock (tttt2) { array2.Wait(); array2.Dispose();//TH.Add(array2); }

                                //Initiatye Variables.
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;

                                int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                                int Ord3 = Order;
                                Color a3 = a;
                                int iAStarGreedy3 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeHourseBrown(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                                var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseGray(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy));
                                array3.Wait(); array3.Dispose();//TH.Add(array3);
                                ///array3.Start();
                                //Object tttt3 = new Object(); lock (tttt3) { array3.Wait(); array3.Dispose();//TH.Add(array3); }

                                //Initiatye Variables.
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;

                                int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                                int Ord4 = Order;
                                Color a4 = a;
                                int iAStarGreedy4 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeCastleBrown(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                                var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleGray(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy));
                                array4.Wait(); array4.Dispose();//TH.Add(array4);
                                //array4.Start();
                                //Object tttt4 = new Object(); lock (tttt4) { array4.Wait(); array4.Dispose();//TH.Add(array4); }

                                //Initiatye Variables.
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;
                                int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                                int Ord5 = Order;
                                Color a5 = a;
                                int iAStarGreedy5 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeMinisterBrown(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                                var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterGray(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy));
                                array5.Wait(); array5.Dispose();//TH.Add(array5);
                                //array5.Start();
                                //Object tttt5 = new Object(); lock (tttt5) { array5.Wait(); array5.Dispose();//TH.Add(array5); }

                                //Initiatye Variables.
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;
                                int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                                int Ord6 = Order;
                                Color a6 = a;
                                int iAStarGreedy6 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeKingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                                var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingGray(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
                                array6.Wait(); array6.Dispose();//TH.Add(array6);
                                //array6.Start();
                                //Object tttt6 = new Object(); lock (tttt6) { array6.Wait(); array6.Dispose();//TH.Add(array6); }
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        });
                    }
                });
                output.Wait(); output.Dispose();//TH.Add(output);
                //Parallel.ForEach(TH, items => Task.WaitAll(items));
                //for (int g = 0; g < TH.Count; g++)
                //TH[g].Dispose();
                TH.Clear();
                return Do;
            }
        }
        public bool FullGameThinkingTreeBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            Object OOOOO = new Object();
            lock (OOOOO)
            {
                bool Do = false;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;

                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        Parallel.Invoke(() =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                                int Ord1 = OrderP;
                                Color a1 = a;
                                int iAStarGreedy1 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeSoldierBrown(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);
                                var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierBrown(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy));
                                array1.Wait(); array1.Dispose();//TH.Add(array1);
                                //array1.Start();
                                //Object tttt1 = new Object(); lock (tttt1) { array1.Wait(); array1.Dispose();//TH.Add(array1); }

                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;

                                int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                                int Ord2 = Order;
                                Color a2 = a;
                                int iAStarGreedy2 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeElephantBrown(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                                var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantBrown(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy));
                                array2.Wait(); array2.Dispose();//TH.Add(array2);
                                //array2.Start();
                                //Object tttt2 = new Object(); lock (tttt2) { array2.Wait(); array2.Dispose();//TH.Add(array2); }

                                //Initiatye Variables.
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;

                                int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                                int Ord3 = Order;
                                Color a3 = a;
                                int iAStarGreedy3 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeHourseBrown(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                                var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseBrown(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy));
                                array3.Wait(); array3.Dispose();//TH.Add(array3);
                                ///array3.Start();
                                //Object tttt3 = new Object(); lock (tttt3) { array3.Wait(); array3.Dispose();//TH.Add(array3); }

                                //Initiatye Variables.
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;

                                int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                                int Ord4 = Order;
                                Color a4 = a;
                                int iAStarGreedy4 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeCastleBrown(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                                var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleBrown(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy));
                                array4.Wait(); array4.Dispose();//TH.Add(array4);
                                //array4.Start();
                                //Object tttt4 = new Object(); lock (tttt4) { array4.Wait(); array4.Dispose();//TH.Add(array4); }

                                //Initiatye Variables.
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;
                                int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                                int Ord5 = Order;
                                Color a5 = a;
                                int iAStarGreedy5 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeMinisterBrown(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                                var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterBrown(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy));
                                array5.Wait(); array5.Dispose();//TH.Add(array5);
                                //array5.Start();
                                //Object tttt5 = new Object(); lock (tttt5) { array5.Wait(); array5.Dispose();//TH.Add(array5); }

                                //Initiatye Variables.
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }, () =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order == 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //Order *= -1;
                                //ChessRules.CurrentOrder *= -1;
                                int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                                int Ord6 = Order;
                                Color a6 = a;
                                int iAStarGreedy6 = iAStarGreedy;
                                //Do |= this.FullGameThinkingTreeKingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                                var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
                                array6.Wait(); array6.Dispose();//TH.Add(array6);
                                //array6.Start();
                                //Object tttt6 = new Object(); lock (tttt6) { array6.Wait(); array6.Dispose();//TH.Add(array6); }
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        });
                    }
                });
                output.Wait(); output.Dispose();//TH.Add(output);
                //Parallel.ForEach(TH, items => Task.WaitAll(items));
                //for (int g = 0; g < TH.Count; g++)
                //TH[g].Dispose();
                TH.Clear();
                return Do;
            }
        }
        //full game main method for deeper decicion and making
        public bool FullGameThinkingTree(int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            bool Do = false;
            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            Color a;
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;

            Object OOOOO = new Object();
            lock (OOOOO)
            {

                //when search finished stop and return
                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    return false;

            }
            Object O = new Object();
            lock (O)
            {
                //when blitz game (limited game)
                if (AllDraw.Blitz)
                    FullGameMakimgBlitz(ref Index, ref jindex, Order, LeafAStarGreedy);
            }
            /*Object OO = new Object();
            lock (OO)
            {

                if (Order == -1)
                {
                    //Index[0] = -1;
                    //Soldeir
                    //Initiatye Variables.
                    int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                    int Ord1 = OrderP;
                    Color a1 = a;
                    int iAStarGreedy1 = iAStarGreedy;
                    var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierGray(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND));
                    //array1.Start();
                    //Object tttt1 = new Object(); lock (tttt1) { array1.Wait(); array1.Dispose();//TH.Add(array1); }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                    int Ord2 = Order;
                    Color a2 = a;
                    int iAStarGreedy2 = iAStarGreedy;
                    var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantGray(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND));
                    //array2.Start();
                   //Object tttt2 = new Object(); lock (tttt2) { array2.Wait(); array2.Dispose();//TH.Add(array2); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                    int Ord3 = Order;
                    Color a3 = a;
                    int iAStarGreedy3 = iAStarGreedy;
                    var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseGray(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND));
                    ///array3.Start();
                    //Object tttt3 = new Object(); lock (tttt3) { array3.Wait(); array3.Dispose();//TH.Add(array3); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                    int Ord4 = Order;
                    Color a4 = a;
                    int iAStarGreedy4 = iAStarGreedy;
                    var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleGray(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND));
                    //array4.Start();
                    //Object tttt4 = new Object(); lock (tttt4) { array4.Wait(); array4.Dispose();//TH.Add(array4); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;
                    int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                    int Ord5 = Order;
                    Color a5 = a;
                    int iAStarGreedy5 = iAStarGreedy;
                    var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterGray(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND));
                    //array5.Start();
                    //Object tttt5 = new Object(); lock (tttt5) { array5.Wait(); array5.Dispose();//TH.Add(array5); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;
                    int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                    int Ord6 = Order;
                    Color a6 = a;
                    int iAStarGreedy6 = iAStarGreedy;
                    var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingGray(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND));
                    //array6.Start();
                    //Object tttt6 = new Object(); lock (tttt6) { array6.Wait(); array6.Dispose();//TH.Add(array6); }

                }
                //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
                else
                {
                    int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                    int Ord1 = OrderP;
                    Color a1 = a;
                    int iAStarGreedy1 = iAStarGreedy;
                    var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierBrown(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND));
                    //array1.Start();
                    //Object tttt1 = new Object(); lock (tttt1) { array1.Wait(); array1.Dispose();//TH.Add(array1); }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                    int Ord2 = Order;
                    Color a2 = a;
                    int iAStarGreedy2 = iAStarGreedy;
                    var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantBrown(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND));
                    //array2.Start();
                   //Object tttt2 = new Object(); lock (tttt2) { array2.Wait(); array2.Dispose();//TH.Add(array2); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                    int Ord3 = Order;
                    Color a3 = a;
                    int iAStarGreedy3 = iAStarGreedy;
                    var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseBrown(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND));
                    ///array3.Start();
                    //Object tttt3 = new Object(); lock (tttt3) { array3.Wait(); array3.Dispose();//TH.Add(array3); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                    int Ord4 = Order;
                    Color a4 = a;
                    int iAStarGreedy4 = iAStarGreedy;
                    var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleBrown(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND));
                    //array4.Start();
                    //Object tttt4 = new Object(); lock (tttt4) { array4.Wait(); array4.Dispose();//TH.Add(array4); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;
                    int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                    int Ord5 = Order;
                    Color a5 = a;
                    int iAStarGreedy5 = iAStarGreedy;
                    var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterBrown(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND));
                    //array5.Start();
                    //Object tttt5 = new Object(); lock (tttt5) { array5.Wait(); array5.Dispose();//TH.Add(array5); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;
                    int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                    int Ord6 = Order;
                    Color a6 = a;
                    int iAStarGreedy6 = iAStarGreedy;
                    var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND));
                    //array6.Start();
                    //Object tttt6 = new Object(); lock (tttt6) { array6.Wait(); array6.Dispose();//TH.Add(array6); }
                }
                
            }
            */
            if (TH == null)
                TH = new List<Task>();

            if (Order == 1)
            {
                //Index[0] = -1;
                //Soldeir
                //Initiatye Variables.               
                var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeGray(a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                //array.Start();
                array.Wait(); array.Dispose();


            }
            //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
            else
            {
                var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeBrown(a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                // array.Start();
                array.Wait(); array.Dispose();
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //full game decicion making second method
        bool FullGameThinkingTreeObject(int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //
            bool Do = false;
            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            Color a;
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            ////Order *= -1;
            //Index = -1;
            //jindex = -1;
            //Kind =
            Object O = new Object();
            lock (O)
            {
                //when blitz game (limited game)
                if (AllDraw.Blitz)
                    FullGameMakimgBlitz(ref Index, ref jindex, Order, LeafAStarGreedy);
            }
            if (Order == 1)
            {
                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        Parallel.For(0, MaxGrayMidle(), i =>
                        {
                            Parallel.Invoke(() =>

                            {
                                Object ooo = new Object();
                                lock (ooo)
                                {
                                    if (i < SodierMidle)
                                    {
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (Order == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                                            int Ord1 = OrderP;
                                            Color a1 = a;
                                            int iAStarGreedy1 = iAStarGreedy;
                                            int i1 = i;
                                            Do |= FullGameThinkingTreeSoldier(i1, a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);
                                            //var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierGray(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND));
                                            //array1.Start();
                                            //Object tttt1 = new Object(); lock (tttt1) { array1.Wait(); array1.Dispose();//TH.Add(array1); }

                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                        }
                                    }
                                }
                            }, () =>
                            {
                                Object ooo = new Object();
                                lock (ooo)
                                {

                                    if (i < ElefantMidle)
                                    {
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (Order == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            //Order *= -1;
                                            //ChessRules.CurrentOrder *= -1;

                                            int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                                            int Ord2 = Order;
                                            Color a2 = a;
                                            int iAStarGreedy2 = iAStarGreedy;
                                            int i2 = i;
                                            Do |= this.FullGameThinkingTreeElephant(i2, a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                                            //Initiatye Variables.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                        }
                                    }
                                }
                            }, () =>
                            {
                                Object ooo = new Object();
                                lock (ooo)
                                {

                                    if (i < HourseMidle)
                                    {
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (Order == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            //Order *= -1;
                                            //ChessRules.CurrentOrder *= -1;

                                            int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                                            int Ord3 = Order;
                                            Color a3 = a;
                                            int iAStarGreedy3 = iAStarGreedy;
                                            int i3 = i;
                                            Do |= this.FullGameThinkingTreeHourse(i3, a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                                            //Initiatye Variables.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                        }
                                    }
                                }
                            }, () =>
                            {
                                Object ooo = new Object();
                                lock (ooo)
                                {

                                    if (i < CastleMidle)
                                    {
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (Order == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            //Order *= -1;
                                            //ChessRules.CurrentOrder *= -1;

                                            int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                                            int Ord4 = Order;
                                            Color a4 = a;
                                            int iAStarGreedy4 = iAStarGreedy;
                                            int i4 = i;
                                            Do |= this.FullGameThinkingTreeCastle(i4, a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                                            //Initiatye Variables.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                        }
                                    }
                                }
                            }, () =>
                            {
                                Object ooo = new Object();
                                lock (ooo)
                                {

                                    if (i < MinisterMidle)
                                    {
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (Order == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            //Order *= -1;
                                            //ChessRules.CurrentOrder *= -1;
                                            int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                                            int Ord5 = Order;
                                            Color a5 = a;
                                            int iAStarGreedy5 = iAStarGreedy;
                                            int i5 = i;
                                            Do |= this.FullGameThinkingTreeMinister(i5, a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                                            //Initiatye Variables.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                        }
                                    }
                                }
                            }, () =>
                            {
                                Object ooo = new Object();
                                lock (ooo)
                                {

                                    if (i < KingMidle)

                                    {
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (Order == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            //Order *= -1;
                                            //ChessRules.CurrentOrder *= -1;
                                            int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                                            int Ord6 = Order;
                                            Color a6 = a;
                                            int iAStarGreedy6 = iAStarGreedy;
                                            int i6 = i;
                                            Do |= this.FullGameThinkingTreeKing(i6, a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                        }
                                    }
                                }
                            });
                        });
                    }
                });
                output.Wait(); output.Dispose();

            }
            //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
            else
            {
                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        Parallel.For(MinBrownMidle(), MaxGrayMidle(), i =>
                        {
                            Parallel.Invoke(() =>
                            {
                                Object ooo = new Object();
                                lock (ooo)
                                {

                                    if (i >= SodierMidle && i < SodierHigh)
                                    {

                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (Order == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                                            int Ord1 = OrderP;
                                            Color a1 = a;
                                            int iAStarGreedy1 = iAStarGreedy;
                                            int i1 = i;
                                            Do |= this.FullGameThinkingTreeSoldier(i1, a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                        }
                                    }
                                }
                            }, () =>
                            {
                                if (i >= ElefantMidle && i < ElefantHigh)
                                {
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        if (Order == 1)
                                            a = Color.Gray;
                                        else
                                            a = Color.Brown;
                                        int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                                        int Ord2 = Order;
                                        Color a2 = a;
                                        int iAStarGreedy2 = iAStarGreedy;
                                        int i2 = i;
                                        Do |= this.FullGameThinkingTreeElephant(i2, a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                                        //Initiatye Variables.
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                    }
                                }
                            }, () =>
                            {
                                if (i >= HourseMidle && i < HourseHight)
                                {
                                    Object O1 = new Object();
                                    lock (O1)
                                    {
                                        if (Order == 1)
                                            a = Color.Gray;
                                        else
                                            a = Color.Brown;

                                        int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                                        int Ord3 = Order;
                                        Color a3 = a;
                                        int iAStarGreedy3 = iAStarGreedy;
                                        int i3 = i;
                                        Do |= this.FullGameThinkingTreeHourse(i3, a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                                        //Initiatye Variables.
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                    }
                                }
                            }, () =>
                            {
                                if (i >= CastleMidle && i < CastleHigh)
                                {
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        if (Order == 1)
                                            a = Color.Gray;
                                        else
                                            a = Color.Brown;
                                        int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                                        int Ord4 = Order;
                                        Color a4 = a;
                                        int iAStarGreedy4 = iAStarGreedy;
                                        int i4 = i;
                                        Do |= this.FullGameThinkingTreeCastle(i4, a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                                        //Initiatye Variables.
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                    }
                                }
                            }, () =>
                            {
                                if (i >= MinisterMidle && i < MinisterHigh)
                                {
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        if (Order == 1)
                                            a = Color.Gray;
                                        else
                                            a = Color.Brown;
                                        int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                                        int Ord5 = Order;
                                        Color a5 = a;
                                        int iAStarGreedy5 = iAStarGreedy;
                                        int i5 = i;
                                        Do |= this.FullGameThinkingTreeMinister(i5, a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                                        //Initiatye Variables.
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                    }
                                }

                            }, () =>
                            {
                                if (i >= KingMidle && i < KingHigh)
                                {
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        if (Order == 1)
                                            a = Color.Gray;
                                        else
                                            a = Color.Brown;
                                        if (Order == 1)
                                            a = Color.Gray;
                                        else
                                            a = Color.Brown;
                                        int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                                        int Ord6 = Order;
                                        Color a6 = a;
                                        int iAStarGreedy6 = iAStarGreedy;
                                        int i6 = i;
                                        Do |= this.FullGameThinkingTreeKing(i6, a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                    }
                                }
                            });
                        });
                    }
                });
                output.Wait(); output.Dispose();
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FullGameThinkingTreeObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        //clone a table
        int[,] CloneATable(int[,] Tab)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int[,] Tabl = new int[8, 8];
            for (var i = 0; i < 8; i++)
                for (var j = 0; j < 8; j++)
                    Tabl[i, j] = Tab[i, j];
            ////{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CloneATable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Tabl;
        }
        //return maximum of six type values 
        int MaxOfSixHeuristic(int _1, int _2, int _3, int _4, int _5, int _6)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int[] LessB = new int[6];
            LessB[0] = _1;
            LessB[1] = _2;
            LessB[2] = _3;
            LessB[3] = _4;
            LessB[4] = _5;
            LessB[5] = _6;

            int Value = -1;
            int Les = Int32.MinValue;
            for (var i = 0; i < 6; i++)
            {
                if (LessB[i] > Les)
                {
                    Les = LessB[i];
                    Value = i;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("MaxOfSixHeuristic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Value;
        }
        //return minimum pf six type values
        int MinOfSixHeuristic(int _1, int _2, int _3, int _4, int _5, int _6)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int[] LessB = new int[6];
            LessB[0] = _1;
            LessB[1] = _2;
            LessB[2] = _3;
            LessB[3] = _4;
            LessB[4] = _5;
            LessB[5] = _6;

            int Value = -1;
            int Les = Int32.MaxValue;
            for (var i = 0; i < 6; i++)
            {
                if (LessB[i] < Les)
                {
                    Les = LessB[i];
                    Value = i;
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("MinOfSixHeuristic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Value;
        }
        //best movement indexes founder method.
        List<List<int>> FoundOfBestMovments(int AStarGreedy, ref List<int> i, ref List<int> j, ref List<int> k, AllDraw Dummy, Color a, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //initiate local variables.
            List<List<int>> p = new List<List<int>>();

            for (var ii = 0; ii < 6; ii++)
            {
                List<int> pl = new List<int>();
                p.Add(pl);

                Less = Int32.MinValue;
            }
            List<AllDraw> DummyList = new List<AllDraw>();
            DummyList.Add(Dummy);
            MaxHeuristicAStarGreedytBackWard.Clear();
            //found best movment depend of max Heuristic.
            Dummy.HeuristicAStarGreedySearch(0, a, Order, false);
            //proccess from a stored global variable decicion making.
            if (MaxHeuristicAStarGreedytBackWard[0][1] != -1)//soldier.
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][2]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][3]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][4]);
                p[0].Add(MaxHeuristicAStarGreedytBackWard[0][2]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][5] != -1)//Elephant
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][6]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][7]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][8]);
                p[1].Add(MaxHeuristicAStarGreedytBackWard[0][6]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][9] != -1)//Hourse
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][10]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][11]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][12]);
                p[2].Add(MaxHeuristicAStarGreedytBackWard[0][10]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][13] != -1)//Castles.
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][14]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][15]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][16]);
                p[3].Add(MaxHeuristicAStarGreedytBackWard[0][14]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][17] != -1)//Minister
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][18]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][19]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][20]);
                p[4].Add(MaxHeuristicAStarGreedytBackWard[0][18]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][21] != -1)//King.
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][22]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][23]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][24]);
                p[5].Add(MaxHeuristicAStarGreedytBackWard[0][22]);
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("FoundOfBestMovments:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

            //not found
            return p;
        }

        //Copying of Items of Enemy Non Move and Current Moved.
        public AllDraw CopyRemeiningItems(AllDraw ADummy, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Initiate Local Variables.
            AllDraw Dummy = new AllDraw(OrderPlate, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
            Dummy.TableList.Add(CloneATable(TableList[0]));
            Dummy.SolderesOnTable = new DrawSoldier[SodierHigh];
            Dummy.ElephantOnTable = new DrawElefant[ElefantHigh];
            Dummy.HoursesOnTable = new DrawHourse[HourseHight];
            Dummy.CastlesOnTable = new DrawCastle[CastleHigh];
            Dummy.MinisterOnTable = new DrawMinister[MinisterHigh];
            Dummy.KingOnTable = new DrawKing[KingHigh];
            //For All Sodiers Movments.
            for (var i = 0; i < SodierHigh; i++)
            {

                //Construction of Current Solders. 
                Dummy.SolderesOnTable[i] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, SolderesOnTable[i].Row, SolderesOnTable[i].Column, SolderesOnTable[i].color, CloneATable(SolderesOnTable[i].Table), SolderesOnTable[i].Order, false, SolderesOnTable[i].Current);

            }
            //For All Elephant Objects.
            for (var i = 0; i < ElefantHigh; i++)
            {

                //Construction of Curren Elephant.
                Dummy.ElephantOnTable[i] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ElephantOnTable[i].Row, ElephantOnTable[i].Column, ElephantOnTable[i].color, CloneATable(ElephantOnTable[i].Table), ElephantOnTable[i].Order, false, ElephantOnTable[i].Current);

            }
            //for All Hourse Objects.
            for (var i = 0; i < HourseHight; i++)
            {

                //Construction of Hourse Objects.
                Dummy.HoursesOnTable[i] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, HoursesOnTable[i].Row, HoursesOnTable[i].Column, HoursesOnTable[i].color, CloneATable(HoursesOnTable[i].Table), HoursesOnTable[i].Order, false, HoursesOnTable[i].Current);

            }
            //For All Castles Objects.
            for (var i = 0; i < CastleHigh; i++)
            {

                //Construction of Castles Objects.
                Dummy.CastlesOnTable[i] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CastlesOnTable[i].Row, CastlesOnTable[i].Column, CastlesOnTable[i].color, CloneATable(CastlesOnTable[i].Table), CastlesOnTable[i].Order, false, CastlesOnTable[i].Current);

            }
            //For All Minister Objects.
            for (var i = 0; i < MinisterHigh; i++)
            {

                //Construction of Current Minister.
                Dummy.MinisterOnTable[i] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, MinisterOnTable[i].Row, MinisterOnTable[i].Column, MinisterOnTable[i].color, CloneATable(MinisterOnTable[i].Table), MinisterOnTable[i].Order, false, MinisterOnTable[i].Current);

            }
            //For All King Objects.
            for (var i = 0; i < KingHigh; i++)
            {

                //Construction of Kings Objects.
                Dummy.KingOnTable[i] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, KingOnTable[i].Row, KingOnTable[i].Column, KingOnTable[i].color, CloneATable(KingOnTable[i].Table), KingOnTable[i].Order, false, KingOnTable[i].Current);

            }
            //Gray Order.
            if (Order == 1)
            {
                //For Gray Soders Objects.
                for (var i = 0; i < SodierMidle; i++)
                {

                    //Clone a Movments.
                    ADummy.SolderesOnTable[i].Clone(ref Dummy.SolderesOnTable[i]);

                }
                //For Gray Elephant.
                for (var i = 0; i < ElefantMidle; i++)
                {

                    //Clone a  Movments.
                    ADummy.ElephantOnTable[i].Clone(ref Dummy.ElephantOnTable[i]);

                }
                //For Gray Hourses.
                for (var i = 0; i < HourseMidle; i++)
                {

                    //Clone a Movments.
                    ADummy.HoursesOnTable[i].Clone(ref Dummy.HoursesOnTable[i]);

                }
                //For Gray Castles.
                for (var i = 0; i < CastleMidle; i++)
                {

                    //Clone a Movments.
                    ADummy.CastlesOnTable[i].Clone(ref Dummy.CastlesOnTable[i]);

                }
                //For Gray Ministers.
                for (var i = 0; i < MinisterMidle; i++)
                {

                    //Clone a Movments.
                    ADummy.MinisterOnTable[i].Clone(ref Dummy.MinisterOnTable[i]);

                }
                //For Gray King.
                for (var i = 0; i < KingMidle; i++)
                {

                    //Clone a Movments.
                    ADummy.KingOnTable[i].Clone(ref Dummy.KingOnTable[i]);

                }
                //For All Solders.
            }
            else//For Order Brown.
            {
                {
                    //For Brown Solders.
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {

                        //Clone a Movments.
                        ADummy.SolderesOnTable[i].Clone(ref Dummy.SolderesOnTable[i]);

                    }
                    //For All Brown Elephants.
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {

                        //Clone a Enemy.
                        ADummy.ElephantOnTable[i].Clone(ref Dummy.ElephantOnTable[i]);

                    }
                    //For All Brown Hourses.
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {

                        //Clone a Enemy.
                        ADummy.HoursesOnTable[i].Clone(ref Dummy.HoursesOnTable[i]);

                    }
                    //For Brown Castles. 
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {

                        //Clone a Movments.
                        ADummy.CastlesOnTable[i].Clone(ref Dummy.CastlesOnTable[i]);

                    }
                    //For Gray Minsters.
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {

                        //Clone a Enemy.
                        ADummy.MinisterOnTable[i].Clone(ref Dummy.MinisterOnTable[i]);

                    }
                    //For Brown Kings.
                    for (var i = KingMidle; i < KingHigh; i++)
                    {

                        //Clone a Enemy.
                        ADummy.KingOnTable[i].Clone(ref Dummy.KingOnTable[i]);

                    }
                }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CopyRemeiningItems:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            //Return Constructed Tables.
            return Dummy;


        }
        //determiniation and detection of zeros
        public bool TableZero(int[,] Ta)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Zerro = true;
            for (var i = 0; i < 8; i++)
                for (var j = 0; j < 8; j++)
                    if (Ta[i, j] != 0)
                        Zerro = false;
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("TableZero:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Zerro;
        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionSoldier(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Count; j++)
            {

                if (SolderesOnTable[i].SoldierThinking[0].LearningVarsObject.Count == SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Count)
                    if (SolderesOnTable[i].SoldierThinking[0].LearningVarsObject[j][1] && (!SolderesOnTable[i].SoldierThinking[0].LearningVarsObject[j][4]))
                    {
                        SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate();
                        //if(Regrad)
                        //SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].LearningAlgorithmRegard();
                        //else
                        if (!Regrad)
                            SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].LearningAlgorithmPenalty();
                        SolderesOnTable[i].SoldierThinking[0].HeuristicPenaltyValuePerform(SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j], Order, ref SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][0], true);
                    }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CheckedMateConfiguratiionSoldier:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionElephant(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Count; j++)
            {

                if (ElephantOnTable[i].ElefantThinking[0].LearningVarsObject.Count == ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Count)
                    if (ElephantOnTable[i].ElefantThinking[0].LearningVarsObject[j][1] && (!ElephantOnTable[i].ElefantThinking[0].LearningVarsObject[j][4]))
                    {
                        ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate();
                        //if(Regrad)
                        //ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard();
                        //else
                        if (!Regrad)
                            ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                        ElephantOnTable[i].ElefantThinking[0].HeuristicPenaltyValuePerform(ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j], Order, ref ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][0], true);
                    }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CheckedMateConfiguratiionElephant:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionHourse(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Count; j++)
            {

                if (HoursesOnTable[i].HourseThinking[0].LearningVarsObject.Count == HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Count)
                    if (HoursesOnTable[i].HourseThinking[0].LearningVarsObject[j][1] && (!HoursesOnTable[i].HourseThinking[0].LearningVarsObject[j][4]))
                    {
                        HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate();
                        //if(Regrad)
                        //HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard();
                        //else
                        if (!Regrad)
                            HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();
                        HoursesOnTable[i].HourseThinking[0].HeuristicPenaltyValuePerform(HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j], Order, ref HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][0], true);
                    }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CheckedMateConfiguratiionHourse:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionCastle(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Count; j++)
            {

                if (CastlesOnTable[i].CastleThinking[0].LearningVarsObject.Count == CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Count)
                    if (CastlesOnTable[i].CastleThinking[0].LearningVarsObject[j][1] && (!CastlesOnTable[i].CastleThinking[0].LearningVarsObject[j][4]))
                    {
                        CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].Initiate();
                        //if(Regrad)
                        //CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard();
                        //else
                        if (!Regrad)
                            CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();
                        CastlesOnTable[i].CastleThinking[0].HeuristicPenaltyValuePerform(CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j], Order, ref CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][0], true);
                    }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CheckedMateConfiguratiionCastle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionMinister(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Count; j++)
            {

                if (MinisterOnTable[i].MinisterThinking[0].LearningVarsObject.Count == MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Count)
                    if (MinisterOnTable[i].MinisterThinking[0].LearningVarsObject[j][1] && (!MinisterOnTable[i].MinisterThinking[0].LearningVarsObject[j][4]))
                    {
                        MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate();
                        //if(Regrad)
                        //MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard();
                        //else
                        if (!Regrad)
                            MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                        MinisterOnTable[i].MinisterThinking[0].HeuristicPenaltyValuePerform(MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j], Order, ref MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][0], true);
                    }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CheckedMateConfiguratiionMinister:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionking(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Count; j++)
            {

                if (KingOnTable[i].KingThinking[0].LearningVarsObject.Count == KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Count)
                    if (KingOnTable[i].KingThinking[0].LearningVarsObject[j][1] && (!KingOnTable[i].KingThinking[0].LearningVarsObject[j][4]))
                    {
                        KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate();
                        //if(Regrad)
                        //KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();
                        //else
                        if (!Regrad)
                            KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                        KingOnTable[i].KingThinking[0].HeuristicPenaltyValuePerform(KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j], Order, ref KingOnTable[i].KingThinking[0].HeuristicListKing[j][0], true);
                    }

            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CheckedMateConfiguratiionking:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //specific learning autamata network oparational
        void CheckedMateConfiguratiion(int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (ThinkingChess.LearningVarsCheckedMateOccured && ThinkingChess.LearningVarsCheckedMateOccuredOneCheckedMate)
                {
                    if (Order == 1)
                    {
                        for (var i = 0; i < SodierMidle; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)

                                CheckedMateConfiguratiionSoldier(Order, i, true);


                        for (var i = 0; i < ElefantMidle; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)

                                CheckedMateConfiguratiionElephant(Order, i, true);

                        for (var i = 0; i < HourseMidle; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)

                                CheckedMateConfiguratiionHourse(Order, i, true);

                        for (var i = 0; i < CastleMidle; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)

                                CheckedMateConfiguratiionCastle(Order, i, true);

                        for (var i = 0; i < MinisterMidle; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)

                                CheckedMateConfiguratiionMinister(Order, i, true);

                        for (var i = 0; i < KingMidle; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)

                                CheckedMateConfiguratiionking(Order, i, true);

                    }
                    else
                    {
                        for (var i = SodierMidle; i < SodierHigh; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)

                                CheckedMateConfiguratiionSoldier(Order, i, true);

                        for (var i = ElefantMidle; i < ElefantHigh; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)

                                CheckedMateConfiguratiionElephant(Order, i, true);

                        for (var i = HourseMidle; i < HourseHight; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)

                                CheckedMateConfiguratiionHourse(Order, i, true);

                        for (var i = CastleMidle; i < CastleHigh; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)

                                CheckedMateConfiguratiionCastle(Order, i, true);

                        for (var i = MinisterMidle; i < MinisterHigh; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)

                                CheckedMateConfiguratiionMinister(Order, i, true);

                        for (var i = KingMidle; i < KingHigh; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)

                                CheckedMateConfiguratiionking(Order, i, true);

                    }


                }
                else
                {
                    if (Order == 1)
                    {
                        for (var i = 0; i < SodierMidle; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)

                                CheckedMateConfiguratiionSoldier(Order, i, false);

                        for (var i = 0; i < ElefantMidle; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)

                                CheckedMateConfiguratiionElephant(Order, i, false);

                        for (var i = 0; i < HourseMidle; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)

                                CheckedMateConfiguratiionHourse(Order, i, false);

                        for (var i = 0; i < CastleMidle; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)

                                CheckedMateConfiguratiionCastle(Order, i, false);

                        for (var i = 0; i < MinisterMidle; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)

                                CheckedMateConfiguratiionMinister(Order, i, false);

                        for (var i = 0; i < KingMidle; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)

                                CheckedMateConfiguratiionking(Order, i, false);

                    }
                    else
                    {
                        for (var i = SodierMidle; i < SodierHigh; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)

                                CheckedMateConfiguratiionSoldier(Order, i, false);

                        for (var i = ElefantMidle; i < ElefantHigh; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)

                                CheckedMateConfiguratiionElephant(Order, i, false);

                        for (var i = HourseMidle; i < HourseHight; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)

                                CheckedMateConfiguratiionHourse(Order, i, false);

                        for (var i = CastleMidle; i < CastleHigh; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)

                                CheckedMateConfiguratiionCastle(Order, i, false);

                        for (var i = MinisterMidle; i < MinisterHigh; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)

                                CheckedMateConfiguratiionMinister(Order, i, false);

                        for (var i = KingMidle; i < KingHigh; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)

                                CheckedMateConfiguratiionking(Order, i, false);

                    }

                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CheckedMateConfiguratiion:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //monitor
        void SemaphoreExxedTime(int time, int Kind)
        {/*
            //long Time = TimeElapced.TimeNow();Spaces++;

            if (time > 10000)
            {
                if (Kind == 1)
                    //OutPut.Append("\r\nSolder Semaphre Full Game Exeede time");
                else
if (Kind == 2)
                    //OutPut.Append("\r\nelephant Semaphre Full Game Exeede time");
                else
if (Kind == 3)
                    //OutPut.Append("\r\nHourse Semaphre Full Game Exeede time");
                else
if (Kind == 4)
                    //OutPut.Append("\r\nCastle Semaphre Full Game Exeede time");
                else
if (Kind == 5)
                    //OutPut.Append("\r\nMinister Semaphre Full Game Exeede time");
                else if (Kind == 6)
                    //OutPut.Append("\r\nKing Semaphre Full Game Exeede time");

            }*/
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("SemaphoreExxedTime:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Main Initiate Thinking Method.
        public int[,] Initiate(int ii, int jj, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy, bool SetDept = false)
        {

            Object o = new Object();
            lock (o)
            {
                LeafSemaphoreIndex = false;

                if (tH != null)
                    tH.Clear();
                else
                    tH = new List<Task>();
                if (TH != null)
                    TH.Clear();
                else
                    TH = new List<Task>();
                ThinkingChess.Colleralation = int.MinValue;
                ThinkingChess.DeColleralation = int.MaxValue;

                if (FOUND && (!FirstTraversalTree))
                    NumberOfLeafComputation = ThinkingChess.NumbersOfAllNode;
                else
                    NumberOfLeafComputation = -1;
                ThinkingChess.IsAtLeastOneKillerAtDraw = false;
                //long Time = TimeElapced.TimeNow();Spaces++;
                var parallelOptions = new ParallelOptions();
                parallelOptions.MaxDegreeOfParallelism = PlatformHelper.ProcessorCount;
                SetDeptIgnore = SetDept;
                int[,] TableHeuristic = null;
                int Current = ChessRules.CurrentOrder;
                int DummyOrder = Order;

                Object O = new Object();
                lock (O)
                {
                    AllDraw.ActionStringReady = false;
                    ThinkingChess.LearningVarsCheckedMateOccured = false;
                    ThinkingChess.LearningVarsCheckedMateOccuredOneCheckedMate = false;
                    RegardOccurred = false;
                    Object OO21 = new Object();
                    lock (OO21)
                    {
                        TaskBegin = 0;
                        TaskEnd = 0;
                    }

                    Object OO1 = new Object();
                    lock (OO1)
                    {
                        lock (OO1)
                        {

                            if (AllDraw.THIScomboBoxMaxLevelText != "")
                                MaxDuringLevelThinkingCreation = System.Convert.ToInt32(AllDraw.THIScomboBoxMaxLevelText);

                        }
                    }
                    Object Om1 = new Object();
                    lock (Om1)
                    {
                        MinThinkingTreeDepth = 0;
                    }

                    ThinkingChess.FoundFirstMating = 0;
                    ThinkingChess.FoundFirstSelfMating = 0;
                    //Monitor Log File Appending First Line. 
                    Object On = new Object();
                    lock (On)
                    {

                        //OutPut.Append("\n\r=====================================================================================================================================================================<br/>");
                        //OutPut.Append("\n\rMovment Number: " + AllDraw.MovmentsNumber);

                    }
                    //Initiate Local and Global Variables.            
                    Object ol = new Object();
                    lock (ol)
                    {
                        CurrentHeuristic = Int32.MinValue;
                        MaxHeuristicxT = Int32.MinValue;
                        DrawCastle.MaxHeuristicxB = Int32.MinValue;
                        DrawElefant.MaxHeuristicxE = Int32.MinValue;
                        DrawHourse.MaxHeuristicxH = Int32.MinValue;
                        DrawKing.MaxHeuristicxK = Int32.MinValue;
                        DrawMinister.MaxHeuristicxM = Int32.MinValue;
                        DrawSoldier.MaxHeuristicxS = Int32.MinValue;
                        MovementsAStarGreedyHeuristicFoundT = false;
                        DrawTable = false;
                        ChessRules.CheckBrownObjectDangourFirstTimesOcured = false;
                        ChessRules.CheckGrayObjectDangourFirstTimesOcured = false;
                    }
                }

                MaxHeuristicAStarGreedytBackWard.Clear();

                int[,] Tab = null;

                if (!FOUND)
                {
                    Object O7 = new Object();
                    lock (O7)
                    {
                        ThinkingChess.NotSolvedKingDanger = false;
                        LoopHeuristicIndex = 0;
                        Less = Int32.MinValue;
                    }
                }
                //THIS.Invoke((MethodInvoker)delegate()
                {
                    Object OOO = new Object();
                    lock (OOO)
                    {
                        if (!SetDept)
                            MaxAStarGreedy = System.Convert.ToInt32(AllDraw.MaxDuringLevelThinkingCreation);
                        AllDraw.AStarGreedyiLevelMax = MaxAStarGreedy;
                        AStarGreedyiLevelMax = System.Convert.ToInt32(AllDraw.MaxDuringLevelThinkingCreation);
                        AllDraw.MaxAStarGreedyHeuristicProgress = 6;
                        for (var i = 0; i <= MaxAStarGreedy; i++)
                            AllDraw.MaxAStarGreedyHeuristicProgress += AllDraw.MaxAStarGreedyHeuristicProgress * 6;
                        increasedProgress = (int)((int)999999999 / (int)(AllDraw.MaxAStarGreedyHeuristicProgress));
                        Object Omm1 = new Object();
                        lock (Omm1)
                        {
                            AStarGreedytMaxCount = (int)MaxAStarGreedy;
                        }
                    }
                }//);

                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                int iiii = ii, jjjj = jj, Ord = Order;
                int MaxAStarGreedy1 = 0;
                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (MaxAStarGreedy == 0)
                        MaxAStarGreedy = PlatformHelper.ProcessorCount;
                    MaxAStarGreedy1 = MaxAStarGreedy;

                    int[,] Tabl = CloneATable(Table);
                    Color aaa = a;
                    //var array = Task.Factory.StartNew(() => InitiateAStarGreedyt(MaxAStarGreedy1, iiii, jjjj, aaa, Tabl, Ord, false, FOUND, LeafAStarGreedy));
                    //array.Wait(); array.Dispose();
                    InitiateAStarGreedyt(MaxAStarGreedy1, iiii, jjjj, aaa, Tabl, Ord, false, FOUND, LeafAStarGreedy);
                }
                Object Om = new Object();
                lock (Om)
                {
                    MinThinkingTreeDepth = MaxAStarGreedy - MinThinkingTreeDepth;
                    //Initaite Local Varibales.
                    Tab = new int[8, 8];
                    Less = Int32.MinValue;
                }
                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                Object OO = new Object();
                lock (OO)
                {
                    //OutPut.Append("\r\nMinimum Thinking Tree Depth:" + MinThinkingTreeDepth.ToString() + "!");
                }
                //Order = OrderP;
                NumberOfLeafComputation = -1;


                TableHeuristic = HeuristicAStarGreedySearch(0, a, Order, false);
                if ((TableHeuristic == null || ((TableZero(TableHeuristic)))) && UsePenaltyRegardMechnisamT)
                {


                    Object OOoOO = new Object();
                    lock (OOoOO)
                    {
                        //OutPut.Append("\r\nTable Zero.Possibly Full Penalty!");



                        bool aa = UsePenaltyRegardMechnisamT;
                        UsePenaltyRegardMechnisamT = false;
                        //THISDummy = THISDummy.RemovePenalltyFromFirstBranches(Order);
                        RemovePenalltyFromFirstBranches(Order);
                        MaxAStarGreedy = 1;
                        AStarGreedyiLevelMax = 1;
                        Less = Int32.MinValue;
                        //TableHeuristic = THISDummy.HeuristicAStarGreedySearchPenalties(0, a, Order, false,ref HaveKilled);
                        //TableHeuristic = THISDummy.HeuristicAStarGreedySearch(0, a, Order, false,ref HaveKilled);
                        TableHeuristic = HeuristicAStarGreedySearch(0, a, Order, false);
                        //THISDummy.UsePenaltyRegardMechnisamT = aa;
                        UsePenaltyRegardMechnisamT = aa;
                    }


                }
                else
                if ((TableHeuristic == null || ((TableZero(TableHeuristic)))))
                    //OutPut.Append("\r\nTable Zero.Possibly Full failed!");

                    //If Table Found.

                    if (TableHeuristic != null)
                    {
                        Object OOOOO = new Object();
                        lock (OOOOO)
                        {
                            Ord = Order;
                            if (Ord == 1)
                            {
                                //OutPut.Append("\r\nHeuristic Find Best Movements AStarGreedy " + AStarGreedy.ToString() + " By Bob!");
                            }
                            else
                            {
                                //OutPut.Append("\r\nHeuristic Find Best Movements AStarGreedy " + AStarGreedy.ToString() + " By Alice!");

                            }
                        }
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = Current;
                    }
                    else
                    {
                        Object OOoOO = new Object();
                        lock (OOoOO)
                        {
                            //Clear AStarGreedy Varibales.
                            AllDraw.StoreADraw.Clear();
                            TableCurrent.Clear();
                            AStarGreedy = 0;
                        }

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = Current;
                        //THISDummy.Dispose();
                        Object Omm = new Object();
                        lock (Omm)
                        {
                            DrawTable = true;
                            FoundATable = true;
                        }
                    }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("Initiate:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return CloneATable(TableHeuristic);
            }
        }
        //Identification of Illegal AStarGreedy First and Common Hurist Movments.
        public bool IsEnemyThingsinStable(int[,] TableHeuristic, int[,] TableAction, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Iniatiet Local Variables.
            int[,] Cromosom1 = TableHeuristic;
            int[,] Cromosom2 = TableAction;
            bool and = true;

            bool Find = false;
            //bool Hit = false;
            int FindNumber = 0;
            int
                  CromosomRowFirst = -1, CromosomColumnFirst = -1,
                  CromosomRow = -1, CromosomColumn = -1;
            //Initiate Local Variables.

            //For All Table Home
            for (var i = 0; i < 8; i++)
            {
                for (var j = 0; j < 8; j++)
                {
                    //Gray Order.
                    if (Order == 1)
                    {
                        //Situation 11.
                        if (and)
                        {
                            //All The Brown Object Ignored.
                            if (Cromosom1[i, j] < 0 && Cromosom2[i, j] < 0)
                                continue;
                        }
                        else///Situation 2.
                        {
                            //All The Brown Ojects Ignored.
                            if (Cromosom1[i, j] < 0 || Cromosom2[i, j] < 0)
                                continue;
                        }
                    }
                    else//Brown Order.
                    {
                        //Situation 1.
                        if (and)
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 && Cromosom2[i, j] > 0)
                                continue;

                        }
                        else
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 || Cromosom2[i, j] > 0)
                                continue;
                        }
                    }
                    if (!(ArrangmentsChanged))
                    {
                        {
                            if (Order == 1 && j == 6 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j + 1] > 0) || (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0) || (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j + 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j + 1;
                                    }
                                    Find = true;
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;

                                }

                            }
                            else
                                if (Order == -1 && j == 1 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j - 1] < 0) || (Cromosom2[i + 1, j - 1] < 0 && Cromosom1[i + 1, j - 1] > 0) || (Cromosom2[i - 1, j - 1] < 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == -1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j - 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j - 1;
                                    }
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }

                            //Castles King Validity Condition.
                            if (Order == 1 && j == 0)
                            {
                                //Small Gray Castles King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleGray = true;
                                    CastlesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleGray = true;
                                    CastlesKing = true;
                                }

                            }
                            else if (j == 7)
                            {
                                //Small Castles King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                                else//Big Castles King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleBrown = true;
                                    CastlesKing = true;
                                }

                            }

                        }
                    }
                    else
                    {
                        {
                            if (Order == 1 && j == 1 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j - 1] > 0) || (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0) || (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j - 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j - 1;
                                    }
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;

                                }

                            }
                            else
                                if (Order == -1 && j == 6 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j + 1] < 0) || (Cromosom2[i + 1, j + 1] < 0 && Cromosom1[i + 1, j + 1] > 0) || (Cromosom2[i - 1, j + 1] < 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == -1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j + 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j + 1;
                                    }
                                    Find = true;
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }

                            //Castles King Validity Condition.
                            if (Order == 1 && j == 7)
                            {
                                //Small Gray Castles King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleGray = true;
                                    CastlesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleGray = true;
                                    CastlesKing = true;
                                }

                            }
                            else if (j == 0)
                            {
                                //Small Castles King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                                else//Big Castles King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleBrown = true;
                                    CastlesKing = true;
                                }

                            }

                        }
                    }

                    //When To Same Location Tbles are Different in Gen.
                    if (Cromosom1[i, j] != Cromosom2[i, j])
                    {
                        //When Cromosom 2 is Empty.
                        if (Cromosom2[i, j] == 0)
                        {
                            //Initiate Location of Table.
                            continue;
                        }
                        else
                        {
                            //Situation 1.0
                            if (and)
                            {
                                //When Cromosom1 Current Location is Empty.
                                if (Cromosom1[i, j] == 0)
                                {
                                    //Initiate Location of Gen.
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    continue;
                                }
                            }
                        }
                        //Store Location of Gen and Calculate Gen Numbers.
                        CromosomRow = i;
                        CromosomColumn = j;
                        Find = true;
                        FindNumber++;
                    }
                }
            }
            //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("IsEnemyThingsinStable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            //If Gen Foundation is Valid. 
            if (((FindNumber == 1 || FindNumber == 2) && Find) || CastlesKing || AllDraw.SodierConversionOcuured)
                return Find;
            //Gen Not Found.
            return false;
        }
        //web translator monitor strings
        List<int[]> WhereNumbers(String Tag)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object OOOO = new Object();
            lock (OOOO)
            {

                List<int[]> TagList = new List<int[]>();
                for (var i = 0; i < Tag.Length; i++)
                {
                    if (i + 1 < Tag.Length)
                    {
                        for (var j = i + 1; j < i + RefrigtzDLL.AllDraw.MaxAStarGreedy.ToString().Length + 1; j++)
                        {

                            int A = System.Convert.ToInt32(Tag.Substring(i, j - i));
                            if (A >= 0 && A <= AllDraw.MaxAStarGreedy)
                            {
                                int[] Loc = new int[2];
                                Loc[0] = i;
                                Loc[1] = j - i;
                                TagList.Add(Loc);
                            }




                        }
                    }
                }
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("WhereNumbers:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

                return TagList;
            }
        }
        String CreateHtmlTag(String Tag)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //List<int[]> List = new List<int[]>();
                //List = WhereNumbers(Tag);
                //for (var i = 0; i < List.Count; i++)
                //Tag = Tag.Replace(Tag.Substring(List[i][0], List[i][1]), "<font Color=\"Gold\">" + Tag.Substring(List[i][0], List[i][1]) + "</font>");

                if (Tag.Contains("Thinking"))
                    Tag = Tag.Replace("Thinking", "<font Color=\"Green\">" + "Thinking" + "</font>");
                if (Tag.Contains("Perception"))
                    Tag = Tag.Replace("Perception", "<font Color=\"Green\">" + "Perception" + "</font>");
                if (Tag.Contains("Bob"))
                    Tag = Tag.Replace("Bob", "<font Color=\"Gray\">" + "Bob" + "</font>");
                if (Tag.Contains("Alice"))
                    Tag = Tag.Replace("Alice", "<font Color=\"Brown\">" + "Brown" + "</font>");
                if (Tag.Contains("AstarGreedy "))
                    Tag = Tag.Replace("AstarGreedy ", "<font Color=\"Yellow\">" + "AstarGreedy " + "</font>");
                if (Tag.Contains("Level"))
                    Tag = Tag.Replace("Level", "<font Color=\"Blue\">" + "Level" + "</Font>");
                /*              if (Tag.Contains("Soldeir"))
                                  Tag = Tag.Replace("Soldeir", "<font Color=\"Silver\">" + "Soldeir" + "</font>");
                              else
                              if (Tag.Contains("Elephant"))
                                  Tag = Tag.Replace("Elephant", "<font Color=\"Silver\">" + "Elephant" + "</font>");
                              else
                              if (Tag.Contains("Hourse"))
                                  Tag = Tag.Replace("Hourse", "<font Color=\"Silver\">" + "Hourse" + "</font>");
                              else
                              if (Tag.Contains("Castle"))
                                  Tag = Tag.Replace("Castle", "<font Color=\"Silver\">" + "Castle" + "</font>");
                              else
                              if (Tag.Contains("Minister"))
                                  Tag = Tag.Replace("Minister", "<font Color=\"Silver\">" + "Minister" + "</font>");
                              else
                              if (Tag.Contains("King"))
                                  Tag = Tag.Replace("King", "<font Color=\"Silver\">" + "King" + "</font>");
              */
                String R = "<font Color=\"Red\">" + Tag + "</font>";
                //{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CreateHtmlTag:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return R;
            }
        }
        public void RewriteAllDrawRec(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            Object o = new Object();
            lock (o)
            {


                AllDraw Node = this;


                if (DummyFileStream.Position >= DummyFileStream.Length)
                    return;


                ////Node = (AllDraw)Formatters.Deserialize(DummyFileStream);

                Formatters.Serialize(DummyFileStream, Node.SodierMidle);
                Formatters.Serialize(DummyFileStream, Node.SodierHigh);
                for (int i = 0; i < Node.SodierHigh; i++)
                {
                    if (Node.SolderesOnTable == null)
                        continue;
                    if (Node.SolderesOnTable[i] == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking[0] == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy == null)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j]);

                        Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }
                Formatters.Serialize(DummyFileStream, Node.ElefantMidle);
                Formatters.Serialize(DummyFileStream, Node.ElefantHigh);
                for (int i = 0; i < Node.ElefantHigh; i++)
                {
                    if (Node.ElephantOnTable == null)
                        continue;
                    if (Node.ElephantOnTable[i] == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking[0] == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy == null)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j]);
                        Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);

                    }
                }
                Formatters.Serialize(DummyFileStream, Node.HourseMidle);
                Formatters.Serialize(DummyFileStream, Node.HourseHight);
                for (int i = 0; i < Node.HourseHight; i++)
                {
                    if (Node.HoursesOnTable == null)
                        continue;
                    if (Node.HoursesOnTable[i] == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking[0] == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy == null)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j]);
                        Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }

                }
                Formatters.Serialize(DummyFileStream, Node.CastleMidle);
                Formatters.Serialize(DummyFileStream, Node.CastleHigh);
                for (int i = 0; i < Node.CastleHigh; i++)
                {
                    if (Node.CastlesOnTable == null)
                        continue;
                    if (Node.CastlesOnTable[i] == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking[0] == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy == null)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy[j]);
                        Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }

                Formatters.Serialize(DummyFileStream, Node.MinisterMidle);
                Formatters.Serialize(DummyFileStream, Node.MinisterHigh);
                for (int i = 0; i < Node.MinisterHigh; i++)
                {
                    if (Node.MinisterOnTable == null)
                        continue;
                    if (Node.MinisterOnTable[i] == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking[0] == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy == null)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j]);
                        Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }

                }
                Formatters.Serialize(DummyFileStream, Node.KingMidle);
                Formatters.Serialize(DummyFileStream, Node.KingHigh);
                for (int i = 0; i < Node.KingHigh; i++)
                {
                    if (Node.KingOnTable == null)
                        continue;
                    if (Node.KingOnTable[i] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0].AStarGreedy == null)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.KingOnTable[i].KingThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.KingOnTable[i].KingThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.KingOnTable[i].KingThinking[0].AStarGreedy[j]);
                        Node.KingOnTable[i].KingThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }

            }
        }
        public AllDraw LoaderEC(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            Object o = new Object();
            lock (o)
            {

                //bool Act = false;
                AllDraw Node = this;

                if (DummyFileStream.Position >= DummyFileStream.Length)
                    return Node;



                //Node = (AllDraw)Formatters.Deserialize(DummyFileStream);

                Node.SodierMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.SodierHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.SodierHigh; i++)
                {
                    if (Node.SolderesOnTable == null)
                        continue;
                    if (Node.SolderesOnTable[i] == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking[0] == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy == null)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {

                            Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].LoaderEC(Quantum , Order * -1, DummyFileStream, Formatters);
                            Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                Node.ElefantMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.ElefantHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.ElefantHigh; i++)
                {
                    if (Node.ElephantOnTable == null)
                        continue;
                    if (Node.ElephantOnTable[i] == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking[0] == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy == null)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Clear();

                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].LoaderEC(Quantum , Order * -1, DummyFileStream, Formatters);
                            Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                Node.HourseMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.HourseHight = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.HourseHight; i++)
                {
                    if (Node.HoursesOnTable == null)
                        continue;
                    if (Node.HoursesOnTable[i] == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking[0] == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy == null)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].LoaderEC(Quantum , Order * -1, DummyFileStream, Formatters);
                            Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }

                    }
                }
                Node.CastleMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.CastleHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.CastleHigh; i++)
                {
                    if (Node.CastlesOnTable == null)
                        continue;
                    if (Node.CastlesOnTable[i] == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking[0] == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy == null)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].LoaderEC(Quantum , Order * -1, DummyFileStream, Formatters);
                            Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].AStarGreedyString = Node;

                        }
                    }
                }
                Node.MinisterMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.MinisterHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.MinisterHigh; i++)
                {
                    if (Node.MinisterOnTable == null)
                        continue;
                    if (Node.MinisterOnTable[i] == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking[0] == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy == null)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].LoaderEC(Quantum , Order * -1, DummyFileStream, Formatters);
                            Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }

                    }
                }
                Node.KingMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.KingHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.KingHigh; i++)
                {
                    if (Node.KingOnTable == null)
                        continue;
                    if (Node.KingOnTable[i] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0].AStarGreedy == null)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.KingOnTable[i].KingThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.KingOnTable[i].KingThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.KingOnTable[i].KingThinking[0].AStarGreedy[j].LoaderEC(Quantum , Order * -1, DummyFileStream, Formatters);
                            Node.KingOnTable[i].KingThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                //  if (!Act)
                //   return this;
                //this = (AllDraw)Formatters.Deserialize(DummyFileStream);



                //return CreateAllDrawFromMemmory(Last, new AllDraw(MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsT), Order);
                return Node;
                //return Node.al;
            }
        }
    }
}
//End of Documentation.
